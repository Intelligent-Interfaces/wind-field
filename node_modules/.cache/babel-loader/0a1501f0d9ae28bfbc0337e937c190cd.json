{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { Volume } from \"../component/channel/Volume\";\nimport \"../core/context/Destination\";\nimport \"../core/clock/Transport\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { defaultArg } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isDefined, isUndef } from \"../core/util/TypeCheck\";\nimport { assert, assertContextRunning } from \"../core/util/Debug\";\nimport { GT } from \"../core/util/Math\";\n/**\n * Base class for sources.\n * start/stop of this.context.transport.\n *\n * ```\n * // Multiple state change events can be chained together,\n * // but must be set in the correct order and with ascending times\n * // OK\n * state.start().stop(\"+0.2\");\n * // OK\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n * // BAD\n * state.stop(\"+0.2\").start();\n * // BAD\n * state.start(\"+0.3\").stop(\"+0.2\");\n * ```\n */\n\nvar Source =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Source, _super);\n\n  function Source(options) {\n    var _this = _super.call(this, options) || this;\n    /**\n     * Sources have no inputs\n     */\n\n\n    _this.input = undefined;\n    /**\n     * Keep track of the scheduled state.\n     */\n\n    _this._state = new StateTimeline(\"stopped\");\n    /**\n     * The synced `start` callback function from the transport\n     */\n\n    _this._synced = false;\n    /**\n     * Keep track of all of the scheduled event ids\n     */\n\n    _this._scheduled = [];\n    /**\n     * Placeholder functions for syncing/unsyncing to transport\n     */\n\n    _this._syncedStart = noOp;\n    _this._syncedStop = noOp;\n    _this._state.memory = 100;\n    _this._state.increasing = true;\n    _this._volume = _this.output = new Volume({\n      context: _this.context,\n      mute: options.mute,\n      volume: options.volume\n    });\n    _this.volume = _this._volume.volume;\n    readOnly(_this, \"volume\");\n    _this.onstop = options.onstop;\n    return _this;\n  }\n\n  Source.getDefaults = function () {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      mute: false,\n      onstop: noOp,\n      volume: 0\n    });\n  };\n\n  Object.defineProperty(Source.prototype, \"state\", {\n    /**\n     * Returns the playback state of the source, either \"started\" or \"stopped\".\n     * @example\n     * import { Player } from \"tone\";\n     * const player = new Player(\"https://tonejs.github.io/examples/audio/FWDL.mp3\", () => {\n     * \tplayer.start();\n     * \tconsole.log(player.state);\n     * }).toDestination();\n     */\n    get: function () {\n      if (this._synced) {\n        if (this.context.transport.state === \"started\") {\n          return this._state.getValueAtTime(this.context.transport.seconds);\n        } else {\n          return \"stopped\";\n        }\n      } else {\n        return this._state.getValueAtTime(this.now());\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Source.prototype, \"mute\", {\n    /**\n     * Mute the output.\n     * @example\n     * import { Oscillator } from \"tone\";\n     * const osc = new Oscillator().toDestination().start();\n     * // mute the output\n     * osc.mute = true;\n     */\n    get: function () {\n      return this._volume.mute;\n    },\n    set: function (mute) {\n      this._volume.mute = mute;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Ensure that the scheduled time is not before the current time.\n   * Should only be used when scheduled unsynced.\n   */\n\n  Source.prototype._clampToCurrentTime = function (time) {\n    if (this._synced) {\n      return time;\n    } else {\n      return Math.max(time, this.context.currentTime);\n    }\n  };\n  /**\n   * Start the source at the specified time. If no time is given,\n   * start the source now.\n   * @param  time When the source should be started.\n   * @example\n   * import { Oscillator } from \"tone\";\n   * const source = new Oscillator().toDestination();\n   * source.start(\"+0.5\"); // starts the source 0.5 seconds from now\n   */\n\n\n  Source.prototype.start = function (time, offset, duration) {\n    var _this = this;\n\n    var computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n    computedTime = this._clampToCurrentTime(computedTime); // if it's started, stop it and restart it\n\n    if (this._state.getValueAtTime(computedTime) === \"started\") {\n      // time should be strictly greater than the previous start time\n      assert(GT(computedTime, this._state.get(computedTime).time), \"Start time must be strictly greater than previous start time\");\n\n      this._state.cancel(computedTime);\n\n      this._state.setStateAtTime(\"started\", computedTime);\n\n      this.log(\"restart\", computedTime);\n      this.restart(computedTime, offset, duration);\n    } else {\n      this.log(\"start\", computedTime);\n\n      this._state.setStateAtTime(\"started\", computedTime);\n\n      if (this._synced) {\n        // add the offset time to the event\n        var event_1 = this._state.get(computedTime);\n\n        if (event_1) {\n          event_1.offset = this.toSeconds(defaultArg(offset, 0));\n          event_1.duration = duration ? this.toSeconds(duration) : undefined;\n        }\n\n        var sched = this.context.transport.schedule(function (t) {\n          _this._start(t, offset, duration);\n        }, computedTime);\n\n        this._scheduled.push(sched); // if it's already started\n\n\n        if (this.context.transport.state === \"started\") {\n          this._syncedStart(this.now(), this.context.transport.seconds);\n        }\n      } else {\n        this._start(computedTime, offset, duration);\n      }\n\n      assertContextRunning(this.context);\n    }\n\n    return this;\n  };\n  /**\n   * Stop the source at the specified time. If no time is given,\n   * stop the source now.\n   * @param  time When the source should be stopped.\n   * @example\n   * import { Oscillator } from \"tone\";\n   * const source = new Oscillator().toDestination();\n   * source.start();\n   * source.stop(\"+0.5\"); // stops the source 0.5 seconds from now\n   */\n\n\n  Source.prototype.stop = function (time) {\n    var computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n    computedTime = this._clampToCurrentTime(computedTime);\n\n    if (this._state.getValueAtTime(computedTime) === \"started\" || isDefined(this._state.getNextState(\"started\", computedTime))) {\n      this.log(\"stop\", computedTime);\n\n      if (!this._synced) {\n        this._stop(computedTime);\n      } else {\n        var sched = this.context.transport.schedule(this._stop.bind(this), computedTime);\n\n        this._scheduled.push(sched);\n      }\n\n      this._state.cancel(computedTime);\n\n      this._state.setStateAtTime(\"stopped\", computedTime);\n    }\n\n    return this;\n  };\n  /**\n   * Restart the source.\n   */\n\n\n  Source.prototype.restart = function (time, offset, duration) {\n    time = this.toSeconds(time);\n\n    if (this._state.getValueAtTime(time) === \"started\") {\n      this._state.cancel(time);\n\n      this._restart(time, offset, duration);\n    }\n\n    return this;\n  };\n  /**\n   * Sync the source to the Transport so that all subsequent\n   * calls to `start` and `stop` are synced to the TransportTime\n   * instead of the AudioContext time.\n   *\n   * @example\n   * import { Oscillator, Transport } from \"tone\";\n   * const osc = new Oscillator().toDestination();\n   * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n   * osc.sync().start(0).stop(0.3);\n   * // start the transport.\n   * Transport.start();\n   * // set it to loop once a second\n   * Transport.loop = true;\n   * Transport.loopEnd = 1;\n   */\n\n\n  Source.prototype.sync = function () {\n    var _this = this;\n\n    if (!this._synced) {\n      this._synced = true;\n\n      this._syncedStart = function (time, offset) {\n        if (offset > 0) {\n          // get the playback state at that time\n          var stateEvent = _this._state.get(offset); // listen for start events which may occur in the middle of the sync'ed time\n\n\n          if (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n            // get the offset\n            var startOffset = offset - _this.toSeconds(stateEvent.time);\n\n            var duration = void 0;\n\n            if (stateEvent.duration) {\n              duration = _this.toSeconds(stateEvent.duration) - startOffset;\n            }\n\n            _this._start(time, _this.toSeconds(stateEvent.offset) + startOffset, duration);\n          }\n        }\n      };\n\n      this._syncedStop = function (time) {\n        var seconds = _this.context.transport.getSecondsAtTime(Math.max(time - _this.sampleTime, 0));\n\n        if (_this._state.getValueAtTime(seconds) === \"started\") {\n          _this._stop(time);\n        }\n      };\n\n      this.context.transport.on(\"start\", this._syncedStart);\n      this.context.transport.on(\"loopStart\", this._syncedStart);\n      this.context.transport.on(\"stop\", this._syncedStop);\n      this.context.transport.on(\"pause\", this._syncedStop);\n      this.context.transport.on(\"loopEnd\", this._syncedStop);\n    }\n\n    return this;\n  };\n  /**\n   * Unsync the source to the Transport. See Source.sync\n   */\n\n\n  Source.prototype.unsync = function () {\n    var _this = this;\n\n    if (this._synced) {\n      this.context.transport.off(\"stop\", this._syncedStop);\n      this.context.transport.off(\"pause\", this._syncedStop);\n      this.context.transport.off(\"loopEnd\", this._syncedStop);\n      this.context.transport.off(\"start\", this._syncedStart);\n      this.context.transport.off(\"loopStart\", this._syncedStart);\n    }\n\n    this._synced = false; // clear all of the scheduled ids\n\n    this._scheduled.forEach(function (id) {\n      return _this.context.transport.clear(id);\n    });\n\n    this._scheduled = [];\n\n    this._state.cancel(0);\n\n    return this;\n  };\n  /**\n   * Clean up.\n   */\n\n\n  Source.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.onstop = noOp;\n    this.unsync();\n\n    this._volume.dispose();\n\n    this._state.dispose();\n\n    return this;\n  };\n\n  return Source;\n}(ToneAudioNode);\n\nexport { Source };","map":{"version":3,"sources":["../../../Tone/source/Source.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { Volume } from \"../component/channel/Volume\";\nimport \"../core/context/Destination\";\nimport \"../core/clock/Transport\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { defaultArg } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isDefined, isUndef } from \"../core/util/TypeCheck\";\nimport { assert, assertContextRunning } from \"../core/util/Debug\";\nimport { GT } from \"../core/util/Math\";\n/**\n * Base class for sources.\n * start/stop of this.context.transport.\n *\n * ```\n * // Multiple state change events can be chained together,\n * // but must be set in the correct order and with ascending times\n * // OK\n * state.start().stop(\"+0.2\");\n * // OK\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n * // BAD\n * state.stop(\"+0.2\").start();\n * // BAD\n * state.start(\"+0.3\").stop(\"+0.2\");\n * ```\n */\nvar Source = /** @class */ (function (_super) {\n    tslib_1.__extends(Source, _super);\n    function Source(options) {\n        var _this = _super.call(this, options) || this;\n        /**\n         * Sources have no inputs\n         */\n        _this.input = undefined;\n        /**\n         * Keep track of the scheduled state.\n         */\n        _this._state = new StateTimeline(\"stopped\");\n        /**\n         * The synced `start` callback function from the transport\n         */\n        _this._synced = false;\n        /**\n         * Keep track of all of the scheduled event ids\n         */\n        _this._scheduled = [];\n        /**\n         * Placeholder functions for syncing/unsyncing to transport\n         */\n        _this._syncedStart = noOp;\n        _this._syncedStop = noOp;\n        _this._state.memory = 100;\n        _this._state.increasing = true;\n        _this._volume = _this.output = new Volume({\n            context: _this.context,\n            mute: options.mute,\n            volume: options.volume,\n        });\n        _this.volume = _this._volume.volume;\n        readOnly(_this, \"volume\");\n        _this.onstop = options.onstop;\n        return _this;\n    }\n    Source.getDefaults = function () {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            mute: false,\n            onstop: noOp,\n            volume: 0,\n        });\n    };\n    Object.defineProperty(Source.prototype, \"state\", {\n        /**\n         * Returns the playback state of the source, either \"started\" or \"stopped\".\n         * @example\n         * import { Player } from \"tone\";\n         * const player = new Player(\"https://tonejs.github.io/examples/audio/FWDL.mp3\", () => {\n         * \tplayer.start();\n         * \tconsole.log(player.state);\n         * }).toDestination();\n         */\n        get: function () {\n            if (this._synced) {\n                if (this.context.transport.state === \"started\") {\n                    return this._state.getValueAtTime(this.context.transport.seconds);\n                }\n                else {\n                    return \"stopped\";\n                }\n            }\n            else {\n                return this._state.getValueAtTime(this.now());\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Source.prototype, \"mute\", {\n        /**\n         * Mute the output.\n         * @example\n         * import { Oscillator } from \"tone\";\n         * const osc = new Oscillator().toDestination().start();\n         * // mute the output\n         * osc.mute = true;\n         */\n        get: function () {\n            return this._volume.mute;\n        },\n        set: function (mute) {\n            this._volume.mute = mute;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Ensure that the scheduled time is not before the current time.\n     * Should only be used when scheduled unsynced.\n     */\n    Source.prototype._clampToCurrentTime = function (time) {\n        if (this._synced) {\n            return time;\n        }\n        else {\n            return Math.max(time, this.context.currentTime);\n        }\n    };\n    /**\n     * Start the source at the specified time. If no time is given,\n     * start the source now.\n     * @param  time When the source should be started.\n     * @example\n     * import { Oscillator } from \"tone\";\n     * const source = new Oscillator().toDestination();\n     * source.start(\"+0.5\"); // starts the source 0.5 seconds from now\n     */\n    Source.prototype.start = function (time, offset, duration) {\n        var _this = this;\n        var computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n        computedTime = this._clampToCurrentTime(computedTime);\n        // if it's started, stop it and restart it\n        if (this._state.getValueAtTime(computedTime) === \"started\") {\n            // time should be strictly greater than the previous start time\n            assert(GT(computedTime, this._state.get(computedTime).time), \"Start time must be strictly greater than previous start time\");\n            this._state.cancel(computedTime);\n            this._state.setStateAtTime(\"started\", computedTime);\n            this.log(\"restart\", computedTime);\n            this.restart(computedTime, offset, duration);\n        }\n        else {\n            this.log(\"start\", computedTime);\n            this._state.setStateAtTime(\"started\", computedTime);\n            if (this._synced) {\n                // add the offset time to the event\n                var event_1 = this._state.get(computedTime);\n                if (event_1) {\n                    event_1.offset = this.toSeconds(defaultArg(offset, 0));\n                    event_1.duration = duration ? this.toSeconds(duration) : undefined;\n                }\n                var sched = this.context.transport.schedule(function (t) {\n                    _this._start(t, offset, duration);\n                }, computedTime);\n                this._scheduled.push(sched);\n                // if it's already started\n                if (this.context.transport.state === \"started\") {\n                    this._syncedStart(this.now(), this.context.transport.seconds);\n                }\n            }\n            else {\n                this._start(computedTime, offset, duration);\n            }\n            assertContextRunning(this.context);\n        }\n        return this;\n    };\n    /**\n     * Stop the source at the specified time. If no time is given,\n     * stop the source now.\n     * @param  time When the source should be stopped.\n     * @example\n     * import { Oscillator } from \"tone\";\n     * const source = new Oscillator().toDestination();\n     * source.start();\n     * source.stop(\"+0.5\"); // stops the source 0.5 seconds from now\n     */\n    Source.prototype.stop = function (time) {\n        var computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n        computedTime = this._clampToCurrentTime(computedTime);\n        if (this._state.getValueAtTime(computedTime) === \"started\" || isDefined(this._state.getNextState(\"started\", computedTime))) {\n            this.log(\"stop\", computedTime);\n            if (!this._synced) {\n                this._stop(computedTime);\n            }\n            else {\n                var sched = this.context.transport.schedule(this._stop.bind(this), computedTime);\n                this._scheduled.push(sched);\n            }\n            this._state.cancel(computedTime);\n            this._state.setStateAtTime(\"stopped\", computedTime);\n        }\n        return this;\n    };\n    /**\n     * Restart the source.\n     */\n    Source.prototype.restart = function (time, offset, duration) {\n        time = this.toSeconds(time);\n        if (this._state.getValueAtTime(time) === \"started\") {\n            this._state.cancel(time);\n            this._restart(time, offset, duration);\n        }\n        return this;\n    };\n    /**\n     * Sync the source to the Transport so that all subsequent\n     * calls to `start` and `stop` are synced to the TransportTime\n     * instead of the AudioContext time.\n     *\n     * @example\n     * import { Oscillator, Transport } from \"tone\";\n     * const osc = new Oscillator().toDestination();\n     * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n     * osc.sync().start(0).stop(0.3);\n     * // start the transport.\n     * Transport.start();\n     * // set it to loop once a second\n     * Transport.loop = true;\n     * Transport.loopEnd = 1;\n     */\n    Source.prototype.sync = function () {\n        var _this = this;\n        if (!this._synced) {\n            this._synced = true;\n            this._syncedStart = function (time, offset) {\n                if (offset > 0) {\n                    // get the playback state at that time\n                    var stateEvent = _this._state.get(offset);\n                    // listen for start events which may occur in the middle of the sync'ed time\n                    if (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n                        // get the offset\n                        var startOffset = offset - _this.toSeconds(stateEvent.time);\n                        var duration = void 0;\n                        if (stateEvent.duration) {\n                            duration = _this.toSeconds(stateEvent.duration) - startOffset;\n                        }\n                        _this._start(time, _this.toSeconds(stateEvent.offset) + startOffset, duration);\n                    }\n                }\n            };\n            this._syncedStop = function (time) {\n                var seconds = _this.context.transport.getSecondsAtTime(Math.max(time - _this.sampleTime, 0));\n                if (_this._state.getValueAtTime(seconds) === \"started\") {\n                    _this._stop(time);\n                }\n            };\n            this.context.transport.on(\"start\", this._syncedStart);\n            this.context.transport.on(\"loopStart\", this._syncedStart);\n            this.context.transport.on(\"stop\", this._syncedStop);\n            this.context.transport.on(\"pause\", this._syncedStop);\n            this.context.transport.on(\"loopEnd\", this._syncedStop);\n        }\n        return this;\n    };\n    /**\n     * Unsync the source to the Transport. See Source.sync\n     */\n    Source.prototype.unsync = function () {\n        var _this = this;\n        if (this._synced) {\n            this.context.transport.off(\"stop\", this._syncedStop);\n            this.context.transport.off(\"pause\", this._syncedStop);\n            this.context.transport.off(\"loopEnd\", this._syncedStop);\n            this.context.transport.off(\"start\", this._syncedStart);\n            this.context.transport.off(\"loopStart\", this._syncedStart);\n        }\n        this._synced = false;\n        // clear all of the scheduled ids\n        this._scheduled.forEach(function (id) { return _this.context.transport.clear(id); });\n        this._scheduled = [];\n        this._state.cancel(0);\n        return this;\n    };\n    /**\n     * Clean up.\n     */\n    Source.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this.onstop = noOp;\n        this.unsync();\n        this._volume.dispose();\n        this._state.dispose();\n        return this;\n    };\n    return Source;\n}(ToneAudioNode));\nexport { Source };\n//# sourceMappingURL=Source.js.map"]},"metadata":{},"sourceType":"module"}