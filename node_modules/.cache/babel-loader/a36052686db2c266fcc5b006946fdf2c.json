{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Envelope } from \"./Envelope\";\n/**\n * AmplitudeEnvelope is a Tone.Envelope connected to a gain node.\n * Unlike Tone.Envelope, which outputs the envelope's value, AmplitudeEnvelope accepts\n * an audio signal as the input and will apply the envelope to the amplitude\n * of the signal.\n * Read more about ADSR Envelopes on [Wikipedia](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope).\n *\n * @example\n * import { AmplitudeEnvelope, Oscillator } from \"tone\";\n * const ampEnv = new AmplitudeEnvelope({\n * \tattack: 0.1,\n * \tdecay: 0.2,\n * \tsustain: 1.0,\n * \trelease: 0.8\n * }).toDestination();\n * // create an oscillator and connect it\n * const osc = new Oscillator().connect(ampEnv).start();\n * // trigger the envelopes attack and release \"8t\" apart\n * ampEnv.triggerAttackRelease(\"8t\");\n * @category Component\n */\n\nvar AmplitudeEnvelope =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(AmplitudeEnvelope, _super);\n\n  function AmplitudeEnvelope() {\n    var _this = _super.call(this, optionsFromArguments(AmplitudeEnvelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"])) || this;\n\n    _this.name = \"AmplitudeEnvelope\";\n    _this._gainNode = new Gain({\n      context: _this.context,\n      gain: 0\n    });\n    _this.output = _this._gainNode;\n    _this.input = _this._gainNode;\n\n    _this._sig.connect(_this._gainNode.gain);\n\n    _this.output = _this._gainNode;\n    _this.input = _this._gainNode;\n    return _this;\n  }\n  /**\n   * Clean up\n   */\n\n\n  AmplitudeEnvelope.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._gainNode.dispose();\n\n    return this;\n  };\n\n  return AmplitudeEnvelope;\n}(Envelope);\n\nexport { AmplitudeEnvelope };","map":{"version":3,"sources":["../../../../Tone/component/envelope/AmplitudeEnvelope.ts"],"names":[],"mappings":";AAAA,SAAS,IAAT,QAAqB,yBAArB;AAEA,SAAS,oBAAT,QAAqC,0BAArC;AACA,SAAS,QAAT,QAA0C,YAA1C;AAEA;;;;;;;;;;;;;;;;;;;;;;AAqBA,IAAA,iBAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAuC,EAAA,OAAA,CAAA,SAAA,CAAA,iBAAA,EAAA,MAAA;;AAsBtC,WAAA,iBAAA,GAAA;AAAA,QAAA,KAAA,GACC,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,oBAAoB,CAAC,iBAAiB,CAAC,WAAlB,EAAD,EAAkC,SAAlC,EAA6C,CAAC,QAAD,EAAW,OAAX,EAAoB,SAApB,EAA+B,SAA/B,CAA7C,CAA1B,KAAkH,IADnH;;AApBS,IAAA,KAAA,CAAA,IAAA,GAAe,mBAAf;AAED,IAAA,KAAA,CAAA,SAAA,GAAkB,IAAI,IAAJ,CAAS;AAClC,MAAA,OAAO,EAAE,KAAI,CAAC,OADoB;AAElC,MAAA,IAAI,EAAE;AAF4B,KAAT,CAAlB;AAIR,IAAA,KAAA,CAAA,MAAA,GAAe,KAAI,CAAC,SAApB;AACA,IAAA,KAAA,CAAA,KAAA,GAAc,KAAI,CAAC,SAAnB;;AAeC,IAAA,KAAI,CAAC,IAAL,CAAU,OAAV,CAAkB,KAAI,CAAC,SAAL,CAAe,IAAjC;;AACA,IAAA,KAAI,CAAC,MAAL,GAAc,KAAI,CAAC,SAAnB;AACA,IAAA,KAAI,CAAC,KAAL,GAAa,KAAI,CAAC,SAAlB;;AACA;AAED;;;;;AAGA,EAAA,iBAAA,CAAA,SAAA,CAAA,OAAA,GAAA,YAAA;AACC,IAAA,MAAA,CAAA,SAAA,CAAM,OAAN,CAAa,IAAb,CAAa,IAAb;;AACA,SAAK,SAAL,CAAe,OAAf;;AACA,WAAO,IAAP;AACA,GAJD;;AAKD,SAAA,iBAAA;AAAC,CArCD,CAAuC,QAAvC,CAAA","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Envelope } from \"./Envelope\";\n/**\n * AmplitudeEnvelope is a Tone.Envelope connected to a gain node.\n * Unlike Tone.Envelope, which outputs the envelope's value, AmplitudeEnvelope accepts\n * an audio signal as the input and will apply the envelope to the amplitude\n * of the signal.\n * Read more about ADSR Envelopes on [Wikipedia](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope).\n *\n * @example\n * import { AmplitudeEnvelope, Oscillator } from \"tone\";\n * const ampEnv = new AmplitudeEnvelope({\n * \tattack: 0.1,\n * \tdecay: 0.2,\n * \tsustain: 1.0,\n * \trelease: 0.8\n * }).toDestination();\n * // create an oscillator and connect it\n * const osc = new Oscillator().connect(ampEnv).start();\n * // trigger the envelopes attack and release \"8t\" apart\n * ampEnv.triggerAttackRelease(\"8t\");\n * @category Component\n */\nvar AmplitudeEnvelope = /** @class */ (function (_super) {\n    tslib_1.__extends(AmplitudeEnvelope, _super);\n    function AmplitudeEnvelope() {\n        var _this = _super.call(this, optionsFromArguments(AmplitudeEnvelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"])) || this;\n        _this.name = \"AmplitudeEnvelope\";\n        _this._gainNode = new Gain({\n            context: _this.context,\n            gain: 0,\n        });\n        _this.output = _this._gainNode;\n        _this.input = _this._gainNode;\n        _this._sig.connect(_this._gainNode.gain);\n        _this.output = _this._gainNode;\n        _this.input = _this._gainNode;\n        return _this;\n    }\n    /**\n     * Clean up\n     */\n    AmplitudeEnvelope.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this._gainNode.dispose();\n        return this;\n    };\n    return AmplitudeEnvelope;\n}(Envelope));\nexport { AmplitudeEnvelope };\n//# sourceMappingURL=AmplitudeEnvelope.js.map"]},"metadata":{},"sourceType":"module"}