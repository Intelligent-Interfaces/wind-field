{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { Timeline } from \"./Timeline\";\nimport { assertRange } from \"./Debug\";\n/**\n * A Timeline State. Provides the methods: `setStateAtTime(\"state\", time)` and `getValueAtTime(time)`\n * @param initial The initial state of the StateTimeline.  Defaults to `undefined`\n */\n\nvar StateTimeline =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(StateTimeline, _super);\n\n  function StateTimeline(initial) {\n    if (initial === void 0) {\n      initial = \"stopped\";\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.name = \"StateTimeline\";\n    _this._initial = initial;\n\n    _this.setStateAtTime(_this._initial, 0);\n\n    return _this;\n  }\n  /**\n   * Returns the scheduled state scheduled before or at\n   * the given time.\n   * @param  time  The time to query.\n   * @return  The name of the state input in setStateAtTime.\n   */\n\n\n  StateTimeline.prototype.getValueAtTime = function (time) {\n    var event = this.get(time);\n\n    if (event !== null) {\n      return event.state;\n    } else {\n      return this._initial;\n    }\n  };\n  /**\n   * Add a state to the timeline.\n   * @param  state The name of the state to set.\n   * @param  time  The time to query.\n   * @param options Any additional options that are needed in the timeline.\n   */\n\n\n  StateTimeline.prototype.setStateAtTime = function (state, time, options) {\n    assertRange(time, 0);\n    this.add(Object.assign({}, options, {\n      state: state,\n      time: time\n    }));\n    return this;\n  };\n  /**\n   * Return the event before the time with the given state\n   * @param  state The state to look for\n   * @param  time  When to check before\n   * @return  The event with the given state before the time\n   */\n\n\n  StateTimeline.prototype.getLastState = function (state, time) {\n    // time = this.toSeconds(time);\n    var index = this._search(time);\n\n    for (var i = index; i >= 0; i--) {\n      var event_1 = this._timeline[i];\n\n      if (event_1.state === state) {\n        return event_1;\n      }\n    }\n  };\n  /**\n   * Return the event after the time with the given state\n   * @param  state The state to look for\n   * @param  time  When to check from\n   * @return  The event with the given state after the time\n   */\n\n\n  StateTimeline.prototype.getNextState = function (state, time) {\n    // time = this.toSeconds(time);\n    var index = this._search(time);\n\n    if (index !== -1) {\n      for (var i = index; i < this._timeline.length; i++) {\n        var event_2 = this._timeline[i];\n\n        if (event_2.state === state) {\n          return event_2;\n        }\n      }\n    }\n  };\n\n  return StateTimeline;\n}(Timeline);\n\nexport { StateTimeline };","map":{"version":3,"sources":["../../../../Tone/core/util/StateTimeline.ts"],"names":[],"mappings":";AACA,SAAS,QAAT,QAAwC,YAAxC;AACA,SAAS,WAAT,QAA4B,SAA5B;AASA;;;;;AAIA,IAAA,aAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAsE,EAAA,OAAA,CAAA,SAAA,CAAA,aAAA,EAAA,MAAA;;AASrE,WAAA,aAAA,CAAY,OAAZ,EAA8C;AAAlC,QAAA,OAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,OAAA,GAAA,SAAA;AAAkC;;AAA9C,QAAA,KAAA,GACC,MAAA,CAAA,IAAA,CAAA,IAAA,KAAO,IADR;;AAPS,IAAA,KAAA,CAAA,IAAA,GAAe,eAAf;AASR,IAAA,KAAI,CAAC,QAAL,GAAgB,OAAhB;;AACA,IAAA,KAAI,CAAC,cAAL,CAAoB,KAAI,CAAC,QAAzB,EAAmC,CAAnC;;;AACA;AAED;;;;;;;;AAMA,EAAA,aAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,IAAf,EAA4B;AAC3B,QAAM,KAAK,GAAG,KAAK,GAAL,CAAS,IAAT,CAAd;;AACA,QAAI,KAAK,KAAK,IAAd,EAAoB;AACnB,aAAO,KAAK,CAAC,KAAb;AACA,KAFD,MAEO;AACN,aAAO,KAAK,QAAZ;AACA;AACD,GAPD;AASA;;;;;;;;AAMA,EAAA,aAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,KAAf,EAAqC,IAArC,EAAoD,OAApD,EAA+E;AAC9E,IAAA,WAAW,CAAC,IAAD,EAAO,CAAP,CAAX;AACA,SAAK,GAAL,CAAS,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,OAAlB,EAA2B;AACnC,MAAA,KAAK,EAAA,KAD8B;AAEnC,MAAA,IAAI,EAAA;AAF+B,KAA3B,CAAT;AAIA,WAAO,IAAP;AACA,GAPD;AASA;;;;;;;;AAMA,EAAA,aAAA,CAAA,SAAA,CAAA,YAAA,GAAA,UAAa,KAAb,EAAmC,IAAnC,EAA+C;AAC9C;AACA,QAAM,KAAK,GAAG,KAAK,OAAL,CAAa,IAAb,CAAd;;AACA,SAAK,IAAI,CAAC,GAAG,KAAb,EAAoB,CAAC,IAAI,CAAzB,EAA4B,CAAC,EAA7B,EAAiC;AAChC,UAAM,OAAK,GAAG,KAAK,SAAL,CAAe,CAAf,CAAd;;AACA,UAAI,OAAK,CAAC,KAAN,KAAgB,KAApB,EAA2B;AAC1B,eAAO,OAAP;AACA;AACD;AACD,GATD;AAWA;;;;;;;;AAMA,EAAA,aAAA,CAAA,SAAA,CAAA,YAAA,GAAA,UAAa,KAAb,EAAmC,IAAnC,EAA+C;AAC9C;AACA,QAAM,KAAK,GAAG,KAAK,OAAL,CAAa,IAAb,CAAd;;AACA,QAAI,KAAK,KAAK,CAAC,CAAf,EAAkB;AACjB,WAAK,IAAI,CAAC,GAAG,KAAb,EAAoB,CAAC,GAAG,KAAK,SAAL,CAAe,MAAvC,EAA+C,CAAC,EAAhD,EAAoD;AACnD,YAAM,OAAK,GAAG,KAAK,SAAL,CAAe,CAAf,CAAd;;AACA,YAAI,OAAK,CAAC,KAAN,KAAgB,KAApB,EAA2B;AAC1B,iBAAO,OAAP;AACA;AACD;AACD;AACD,GAXD;;AAYD,SAAA,aAAA;AAAC,CAhFD,CAAsE,QAAtE,CAAA","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { Timeline } from \"./Timeline\";\nimport { assertRange } from \"./Debug\";\n/**\n * A Timeline State. Provides the methods: `setStateAtTime(\"state\", time)` and `getValueAtTime(time)`\n * @param initial The initial state of the StateTimeline.  Defaults to `undefined`\n */\nvar StateTimeline = /** @class */ (function (_super) {\n    tslib_1.__extends(StateTimeline, _super);\n    function StateTimeline(initial) {\n        if (initial === void 0) { initial = \"stopped\"; }\n        var _this = _super.call(this) || this;\n        _this.name = \"StateTimeline\";\n        _this._initial = initial;\n        _this.setStateAtTime(_this._initial, 0);\n        return _this;\n    }\n    /**\n     * Returns the scheduled state scheduled before or at\n     * the given time.\n     * @param  time  The time to query.\n     * @return  The name of the state input in setStateAtTime.\n     */\n    StateTimeline.prototype.getValueAtTime = function (time) {\n        var event = this.get(time);\n        if (event !== null) {\n            return event.state;\n        }\n        else {\n            return this._initial;\n        }\n    };\n    /**\n     * Add a state to the timeline.\n     * @param  state The name of the state to set.\n     * @param  time  The time to query.\n     * @param options Any additional options that are needed in the timeline.\n     */\n    StateTimeline.prototype.setStateAtTime = function (state, time, options) {\n        assertRange(time, 0);\n        this.add(Object.assign({}, options, {\n            state: state,\n            time: time,\n        }));\n        return this;\n    };\n    /**\n     * Return the event before the time with the given state\n     * @param  state The state to look for\n     * @param  time  When to check before\n     * @return  The event with the given state before the time\n     */\n    StateTimeline.prototype.getLastState = function (state, time) {\n        // time = this.toSeconds(time);\n        var index = this._search(time);\n        for (var i = index; i >= 0; i--) {\n            var event_1 = this._timeline[i];\n            if (event_1.state === state) {\n                return event_1;\n            }\n        }\n    };\n    /**\n     * Return the event after the time with the given state\n     * @param  state The state to look for\n     * @param  time  When to check from\n     * @return  The event with the given state after the time\n     */\n    StateTimeline.prototype.getNextState = function (state, time) {\n        // time = this.toSeconds(time);\n        var index = this._search(time);\n        if (index !== -1) {\n            for (var i = index; i < this._timeline.length; i++) {\n                var event_2 = this._timeline[i];\n                if (event_2.state === state) {\n                    return event_2;\n                }\n            }\n        }\n    };\n    return StateTimeline;\n}(Timeline));\nexport { StateTimeline };\n//# sourceMappingURL=StateTimeline.js.map"]},"metadata":{},"sourceType":"module"}