{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { dbToGain, gainToDb } from \"../type/Conversions\";\nimport { isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { ToneWithContext } from \"./ToneWithContext\";\nimport { EQ } from \"../util/Math\";\nimport { assert, assertRange } from \"../util/Debug\";\n/**\n * Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n */\n\nvar Param =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Param, _super);\n\n  function Param() {\n    var _this = _super.call(this, optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"])) || this;\n\n    _this.name = \"Param\";\n    _this.overridden = false;\n    /**\n     * The minimum output value\n     */\n\n    _this._minOutput = 1e-7;\n    var options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n    assert(isDefined(options.param) && (isAudioParam(options.param) || options.param instanceof Param), \"param must be an AudioParam\");\n\n    while (!isAudioParam(options.param)) {\n      options.param = options.param._param;\n    }\n\n    _this._swappable = isDefined(options.swappable) ? options.swappable : false;\n\n    if (_this._swappable) {\n      _this.input = _this.context.createGain(); // initialize\n\n      _this._param = options.param;\n\n      _this.input.connect(_this._param);\n    } else {\n      _this._param = _this.input = options.param;\n    }\n\n    _this._events = new Timeline(1000);\n    _this._initialValue = _this._param.defaultValue;\n    _this.units = options.units;\n    _this.convert = options.convert;\n    _this._minValue = options.minValue;\n    _this._maxValue = options.maxValue; // if the value is defined, set it immediately\n\n    if (isDefined(options.value) && options.value !== _this._toType(_this._initialValue)) {\n      _this.setValueAtTime(options.value, 0);\n    }\n\n    return _this;\n  }\n\n  Param.getDefaults = function () {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      convert: true,\n      units: \"number\"\n    });\n  };\n\n  Object.defineProperty(Param.prototype, \"value\", {\n    get: function () {\n      var now = this.now();\n      return this.getValueAtTime(now);\n    },\n    set: function (value) {\n      this.cancelScheduledValues(this.now());\n      this.setValueAtTime(value, this.now());\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Param.prototype, \"minValue\", {\n    get: function () {\n      // if it's not the default minValue, return it\n      if (isDefined(this._minValue)) {\n        return this._minValue;\n      } else if (this.units === \"time\" || this.units === \"frequency\" || this.units === \"normalRange\" || this.units === \"positive\" || this.units === \"transportTime\" || this.units === \"ticks\" || this.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n        return 0;\n      } else if (this.units === \"audioRange\") {\n        return -1;\n      } else if (this.units === \"decibels\") {\n        return -Infinity;\n      } else {\n        return this._param.minValue;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Param.prototype, \"maxValue\", {\n    get: function () {\n      if (isDefined(this._maxValue)) {\n        return this._maxValue;\n      } else if (this.units === \"normalRange\" || this.units === \"audioRange\") {\n        return 1;\n      } else {\n        return this._param.maxValue;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Type guard based on the unit name\n   */\n\n  Param.prototype._is = function (arg, type) {\n    return this.units === type;\n  };\n  /**\n   * Make sure the value is always in the defined range\n   */\n\n\n  Param.prototype._assertRange = function (value) {\n    if (isDefined(this.maxValue) && isDefined(this.minValue)) {\n      assertRange(value, this._fromType(this.minValue), this._fromType(this.maxValue));\n    }\n\n    return value;\n  };\n  /**\n   * Convert the given value from the type specified by Param.units\n   * into the destination value (such as Gain or Frequency).\n   */\n\n\n  Param.prototype._fromType = function (val) {\n    if (this.convert && !this.overridden) {\n      if (this._is(val, \"time\")) {\n        return this.toSeconds(val);\n      } else if (this._is(val, \"decibels\")) {\n        return dbToGain(val);\n      } else if (this._is(val, \"frequency\")) {\n        return this.toFrequency(val);\n      } else {\n        return val;\n      }\n    } else if (this.overridden) {\n      // if it's overridden, should only schedule 0s\n      return 0;\n    } else {\n      return val;\n    }\n  };\n  /**\n   * Convert the parameters value into the units specified by Param.units.\n   */\n\n\n  Param.prototype._toType = function (val) {\n    if (this.convert && this.units === \"decibels\") {\n      return gainToDb(val);\n    } else {\n      return val;\n    }\n  }; //-------------------------------------\n  // ABSTRACT PARAM INTERFACE\n  // all docs are generated from ParamInterface.ts\n  //-------------------------------------\n\n\n  Param.prototype.setValueAtTime = function (value, time) {\n    var computedTime = this.toSeconds(time);\n\n    var numericValue = this._fromType(value);\n\n    assert(isFinite(numericValue) && isFinite(computedTime), \"Invalid argument(s) to setValueAtTime: \" + JSON.stringify(value) + \", \" + JSON.stringify(time));\n\n    this._assertRange(numericValue);\n\n    this.log(this.units, \"setValueAtTime\", value, computedTime);\n\n    this._events.add({\n      time: computedTime,\n      type: \"setValueAtTime\",\n      value: numericValue\n    });\n\n    this._param.setValueAtTime(numericValue, computedTime);\n\n    return this;\n  };\n\n  Param.prototype.getValueAtTime = function (time) {\n    var computedTime = Math.max(this.toSeconds(time), 0);\n\n    var after = this._events.getAfter(computedTime);\n\n    var before = this._events.get(computedTime);\n\n    var value = this._initialValue; // if it was set by\n\n    if (before === null) {\n      value = this._initialValue;\n    } else if (before.type === \"setTargetAtTime\" && (after === null || after.type === \"setValueAtTime\")) {\n      var previous = this._events.getBefore(before.time);\n\n      var previousVal = void 0;\n\n      if (previous === null) {\n        previousVal = this._initialValue;\n      } else {\n        previousVal = previous.value;\n      }\n\n      if (before.type === \"setTargetAtTime\") {\n        value = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n      }\n    } else if (after === null) {\n      value = before.value;\n    } else if (after.type === \"linearRampToValueAtTime\" || after.type === \"exponentialRampToValueAtTime\") {\n      var beforeValue = before.value;\n\n      if (before.type === \"setTargetAtTime\") {\n        var previous = this._events.getBefore(before.time);\n\n        if (previous === null) {\n          beforeValue = this._initialValue;\n        } else {\n          beforeValue = previous.value;\n        }\n      }\n\n      if (after.type === \"linearRampToValueAtTime\") {\n        value = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n      } else {\n        value = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n      }\n    } else {\n      value = before.value;\n    }\n\n    return this._toType(value);\n  };\n\n  Param.prototype.setRampPoint = function (time) {\n    time = this.toSeconds(time);\n    var currentVal = this.getValueAtTime(time);\n    this.cancelAndHoldAtTime(time);\n\n    if (this._fromType(currentVal) === 0) {\n      currentVal = this._toType(this._minOutput);\n    }\n\n    this.setValueAtTime(currentVal, time);\n    return this;\n  };\n\n  Param.prototype.linearRampToValueAtTime = function (value, endTime) {\n    var numericValue = this._fromType(value);\n\n    var computedTime = this.toSeconds(endTime);\n    assert(isFinite(numericValue) && isFinite(computedTime), \"Invalid argument(s) to linearRampToValueAtTime: \" + JSON.stringify(value) + \", \" + JSON.stringify(endTime));\n\n    this._assertRange(numericValue);\n\n    this._events.add({\n      time: computedTime,\n      type: \"linearRampToValueAtTime\",\n      value: numericValue\n    });\n\n    this.log(this.units, \"linearRampToValueAtTime\", value, computedTime);\n\n    this._param.linearRampToValueAtTime(numericValue, computedTime);\n\n    return this;\n  };\n\n  Param.prototype.exponentialRampToValueAtTime = function (value, endTime) {\n    var numericValue = this._fromType(value);\n\n    numericValue = Math.max(this._minOutput, numericValue);\n\n    this._assertRange(numericValue);\n\n    var computedTime = this.toSeconds(endTime);\n    assert(isFinite(numericValue) && isFinite(computedTime), \"Invalid argument(s) to exponentialRampToValueAtTime: \" + JSON.stringify(value) + \", \" + JSON.stringify(endTime)); // store the event\n\n    this._events.add({\n      time: computedTime,\n      type: \"exponentialRampToValueAtTime\",\n      value: numericValue\n    });\n\n    this.log(this.units, \"exponentialRampToValueAtTime\", value, computedTime);\n\n    this._param.exponentialRampToValueAtTime(numericValue, computedTime);\n\n    return this;\n  };\n\n  Param.prototype.exponentialRampTo = function (value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n    return this;\n  };\n\n  Param.prototype.linearRampTo = function (value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n    return this;\n  };\n\n  Param.prototype.targetRampTo = function (value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.exponentialApproachValueAtTime(value, startTime, rampTime);\n    return this;\n  };\n\n  Param.prototype.exponentialApproachValueAtTime = function (value, time, rampTime) {\n    time = this.toSeconds(time);\n    rampTime = this.toSeconds(rampTime);\n    var timeConstant = Math.log(rampTime + 1) / Math.log(200);\n    this.setTargetAtTime(value, time, timeConstant); // at 90% start a linear ramp to the final value\n\n    this.cancelAndHoldAtTime(time + rampTime * 0.9);\n    this.linearRampToValueAtTime(value, time + rampTime);\n    return this;\n  };\n\n  Param.prototype.setTargetAtTime = function (value, startTime, timeConstant) {\n    var numericValue = this._fromType(value); // The value will never be able to approach without timeConstant > 0.\n\n\n    assert(isFinite(timeConstant) && timeConstant > 0, \"timeConstant must be a number greater than 0\");\n    var computedTime = this.toSeconds(startTime);\n\n    this._assertRange(numericValue);\n\n    assert(isFinite(numericValue) && isFinite(computedTime), \"Invalid argument(s) to setTargetAtTime: \" + JSON.stringify(value) + \", \" + JSON.stringify(startTime));\n\n    this._events.add({\n      constant: timeConstant,\n      time: computedTime,\n      type: \"setTargetAtTime\",\n      value: numericValue\n    });\n\n    this.log(this.units, \"setTargetAtTime\", value, computedTime, timeConstant);\n\n    this._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n\n    return this;\n  };\n\n  Param.prototype.setValueCurveAtTime = function (values, startTime, duration, scaling) {\n    if (scaling === void 0) {\n      scaling = 1;\n    }\n\n    duration = this.toSeconds(duration);\n    startTime = this.toSeconds(startTime);\n    var startingValue = this._fromType(values[0]) * scaling;\n    this.setValueAtTime(this._toType(startingValue), startTime);\n    var segTime = duration / (values.length - 1);\n\n    for (var i = 1; i < values.length; i++) {\n      var numericValue = this._fromType(values[i]) * scaling;\n      this.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n    }\n\n    return this;\n  };\n\n  Param.prototype.cancelScheduledValues = function (time) {\n    var computedTime = this.toSeconds(time);\n    assert(isFinite(computedTime), \"Invalid argument to cancelScheduledValues: \" + JSON.stringify(time));\n\n    this._events.cancel(computedTime);\n\n    this._param.cancelScheduledValues(computedTime);\n\n    this.log(this.units, \"cancelScheduledValues\", computedTime);\n    return this;\n  };\n\n  Param.prototype.cancelAndHoldAtTime = function (time) {\n    var computedTime = this.toSeconds(time);\n\n    var valueAtTime = this._fromType(this.getValueAtTime(computedTime)); // remove the schedule events\n\n\n    assert(isFinite(computedTime), \"Invalid argument to cancelAndHoldAtTime: \" + JSON.stringify(time));\n    this.log(this.units, \"cancelAndHoldAtTime\", computedTime, \"value=\" + valueAtTime); // if there is an event at the given computedTime\n    // and that even is not a \"set\"\n\n    var before = this._events.get(computedTime);\n\n    var after = this._events.getAfter(computedTime);\n\n    if (before && EQ(before.time, computedTime)) {\n      // remove everything after\n      if (after) {\n        this._param.cancelScheduledValues(after.time);\n\n        this._events.cancel(after.time);\n      } else {\n        this._param.cancelAndHoldAtTime(computedTime);\n\n        this._events.cancel(computedTime + this.sampleTime);\n      }\n    } else if (after) {\n      this._param.cancelScheduledValues(after.time); // cancel the next event(s)\n\n\n      this._events.cancel(after.time);\n\n      if (after.type === \"linearRampToValueAtTime\") {\n        this.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);\n      } else if (after.type === \"exponentialRampToValueAtTime\") {\n        this.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);\n      }\n    } // set the value at the given time\n\n\n    this._events.add({\n      time: computedTime,\n      type: \"setValueAtTime\",\n      value: valueAtTime\n    });\n\n    this._param.setValueAtTime(valueAtTime, computedTime);\n\n    return this;\n  };\n\n  Param.prototype.rampTo = function (value, rampTime, startTime) {\n    if (rampTime === void 0) {\n      rampTime = 0.1;\n    }\n\n    if (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n      this.exponentialRampTo(value, rampTime, startTime);\n    } else {\n      this.linearRampTo(value, rampTime, startTime);\n    }\n\n    return this;\n  };\n  /**\n   * Apply all of the previously scheduled events to the passed in Param or AudioParam.\n   * The applied values will start at the context's current time and schedule\n   * all of the events which are scheduled on this Param onto the passed in param.\n   */\n\n\n  Param.prototype.apply = function (param) {\n    var now = this.context.currentTime; // set the param's value at the current time and schedule everything else\n\n    param.setValueAtTime(this.getValueAtTime(now), now); // if the previous event was a curve, then set the rest of it\n\n    var previousEvent = this._events.get(now);\n\n    if (previousEvent && previousEvent.type === \"setTargetAtTime\") {\n      // approx it until the next event with linear ramps\n      var nextEvent = this._events.getAfter(previousEvent.time); // or for 2 seconds if there is no event\n\n\n      var endTime = nextEvent ? nextEvent.time : now + 2;\n      var subdivisions = (endTime - now) / 10;\n\n      for (var i = now; i < endTime; i += subdivisions) {\n        param.linearRampToValueAtTime(this.getValueAtTime(i), i);\n      }\n    }\n\n    this._events.forEachAfter(this.context.currentTime, function (event) {\n      if (event.type === \"cancelScheduledValues\") {\n        param.cancelScheduledValues(event.time);\n      } else if (event.type === \"setTargetAtTime\") {\n        param.setTargetAtTime(event.value, event.time, event.constant);\n      } else {\n        param[event.type](event.value, event.time);\n      }\n    });\n\n    return this;\n  };\n  /**\n   * Replace the Param's internal AudioParam. Will apply scheduled curves\n   * onto the parameter and replace the connections.\n   */\n\n\n  Param.prototype.setParam = function (param) {\n    assert(this._swappable, \"The Param must be assigned as 'swappable' in the constructor\");\n    var input = this.input;\n    input.disconnect(this._param);\n    this.apply(param);\n    this._param = param;\n    input.connect(this._param);\n    return this;\n  };\n\n  Param.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._events.dispose();\n\n    return this;\n  };\n\n  Object.defineProperty(Param.prototype, \"defaultValue\", {\n    get: function () {\n      return this._toType(this._param.defaultValue);\n    },\n    enumerable: true,\n    configurable: true\n  }); //-------------------------------------\n  // \tAUTOMATION CURVE CALCULATIONS\n  // \tMIT License, copyright (c) 2014 Jordan Santell\n  //-------------------------------------\n  // Calculates the the value along the curve produced by setTargetAtTime\n\n  Param.prototype._exponentialApproach = function (t0, v0, v1, timeConstant, t) {\n    return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n  }; // Calculates the the value along the curve produced by linearRampToValueAtTime\n\n\n  Param.prototype._linearInterpolate = function (t0, v0, t1, v1, t) {\n    return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n  }; // Calculates the the value along the curve produced by exponentialRampToValueAtTime\n\n\n  Param.prototype._exponentialInterpolate = function (t0, v0, t1, v1, t) {\n    return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n  };\n\n  return Param;\n}(ToneWithContext);\n\nexport { Param };","map":{"version":3,"sources":["../../../../Tone/core/context/Param.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { dbToGain, gainToDb } from \"../type/Conversions\";\nimport { isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { ToneWithContext } from \"./ToneWithContext\";\nimport { EQ } from \"../util/Math\";\nimport { assert, assertRange } from \"../util/Debug\";\n/**\n * Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n */\nvar Param = /** @class */ (function (_super) {\n    tslib_1.__extends(Param, _super);\n    function Param() {\n        var _this = _super.call(this, optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"])) || this;\n        _this.name = \"Param\";\n        _this.overridden = false;\n        /**\n         * The minimum output value\n         */\n        _this._minOutput = 1e-7;\n        var options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n        assert(isDefined(options.param) &&\n            (isAudioParam(options.param) || options.param instanceof Param), \"param must be an AudioParam\");\n        while (!isAudioParam(options.param)) {\n            options.param = options.param._param;\n        }\n        _this._swappable = isDefined(options.swappable) ? options.swappable : false;\n        if (_this._swappable) {\n            _this.input = _this.context.createGain();\n            // initialize\n            _this._param = options.param;\n            _this.input.connect(_this._param);\n        }\n        else {\n            _this._param = _this.input = options.param;\n        }\n        _this._events = new Timeline(1000);\n        _this._initialValue = _this._param.defaultValue;\n        _this.units = options.units;\n        _this.convert = options.convert;\n        _this._minValue = options.minValue;\n        _this._maxValue = options.maxValue;\n        // if the value is defined, set it immediately\n        if (isDefined(options.value) && options.value !== _this._toType(_this._initialValue)) {\n            _this.setValueAtTime(options.value, 0);\n        }\n        return _this;\n    }\n    Param.getDefaults = function () {\n        return Object.assign(ToneWithContext.getDefaults(), {\n            convert: true,\n            units: \"number\",\n        });\n    };\n    Object.defineProperty(Param.prototype, \"value\", {\n        get: function () {\n            var now = this.now();\n            return this.getValueAtTime(now);\n        },\n        set: function (value) {\n            this.cancelScheduledValues(this.now());\n            this.setValueAtTime(value, this.now());\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Param.prototype, \"minValue\", {\n        get: function () {\n            // if it's not the default minValue, return it\n            if (isDefined(this._minValue)) {\n                return this._minValue;\n            }\n            else if (this.units === \"time\" || this.units === \"frequency\" ||\n                this.units === \"normalRange\" || this.units === \"positive\" ||\n                this.units === \"transportTime\" || this.units === \"ticks\" ||\n                this.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n                return 0;\n            }\n            else if (this.units === \"audioRange\") {\n                return -1;\n            }\n            else if (this.units === \"decibels\") {\n                return -Infinity;\n            }\n            else {\n                return this._param.minValue;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Param.prototype, \"maxValue\", {\n        get: function () {\n            if (isDefined(this._maxValue)) {\n                return this._maxValue;\n            }\n            else if (this.units === \"normalRange\" ||\n                this.units === \"audioRange\") {\n                return 1;\n            }\n            else {\n                return this._param.maxValue;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Type guard based on the unit name\n     */\n    Param.prototype._is = function (arg, type) {\n        return this.units === type;\n    };\n    /**\n     * Make sure the value is always in the defined range\n     */\n    Param.prototype._assertRange = function (value) {\n        if (isDefined(this.maxValue) && isDefined(this.minValue)) {\n            assertRange(value, this._fromType(this.minValue), this._fromType(this.maxValue));\n        }\n        return value;\n    };\n    /**\n     * Convert the given value from the type specified by Param.units\n     * into the destination value (such as Gain or Frequency).\n     */\n    Param.prototype._fromType = function (val) {\n        if (this.convert && !this.overridden) {\n            if (this._is(val, \"time\")) {\n                return this.toSeconds(val);\n            }\n            else if (this._is(val, \"decibels\")) {\n                return dbToGain(val);\n            }\n            else if (this._is(val, \"frequency\")) {\n                return this.toFrequency(val);\n            }\n            else {\n                return val;\n            }\n        }\n        else if (this.overridden) {\n            // if it's overridden, should only schedule 0s\n            return 0;\n        }\n        else {\n            return val;\n        }\n    };\n    /**\n     * Convert the parameters value into the units specified by Param.units.\n     */\n    Param.prototype._toType = function (val) {\n        if (this.convert && this.units === \"decibels\") {\n            return gainToDb(val);\n        }\n        else {\n            return val;\n        }\n    };\n    //-------------------------------------\n    // ABSTRACT PARAM INTERFACE\n    // all docs are generated from ParamInterface.ts\n    //-------------------------------------\n    Param.prototype.setValueAtTime = function (value, time) {\n        var computedTime = this.toSeconds(time);\n        var numericValue = this._fromType(value);\n        assert(isFinite(numericValue) && isFinite(computedTime), \"Invalid argument(s) to setValueAtTime: \" + JSON.stringify(value) + \", \" + JSON.stringify(time));\n        this._assertRange(numericValue);\n        this.log(this.units, \"setValueAtTime\", value, computedTime);\n        this._events.add({\n            time: computedTime,\n            type: \"setValueAtTime\",\n            value: numericValue,\n        });\n        this._param.setValueAtTime(numericValue, computedTime);\n        return this;\n    };\n    Param.prototype.getValueAtTime = function (time) {\n        var computedTime = Math.max(this.toSeconds(time), 0);\n        var after = this._events.getAfter(computedTime);\n        var before = this._events.get(computedTime);\n        var value = this._initialValue;\n        // if it was set by\n        if (before === null) {\n            value = this._initialValue;\n        }\n        else if (before.type === \"setTargetAtTime\" && (after === null || after.type === \"setValueAtTime\")) {\n            var previous = this._events.getBefore(before.time);\n            var previousVal = void 0;\n            if (previous === null) {\n                previousVal = this._initialValue;\n            }\n            else {\n                previousVal = previous.value;\n            }\n            if (before.type === \"setTargetAtTime\") {\n                value = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n            }\n        }\n        else if (after === null) {\n            value = before.value;\n        }\n        else if (after.type === \"linearRampToValueAtTime\" || after.type === \"exponentialRampToValueAtTime\") {\n            var beforeValue = before.value;\n            if (before.type === \"setTargetAtTime\") {\n                var previous = this._events.getBefore(before.time);\n                if (previous === null) {\n                    beforeValue = this._initialValue;\n                }\n                else {\n                    beforeValue = previous.value;\n                }\n            }\n            if (after.type === \"linearRampToValueAtTime\") {\n                value = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n            }\n            else {\n                value = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n            }\n        }\n        else {\n            value = before.value;\n        }\n        return this._toType(value);\n    };\n    Param.prototype.setRampPoint = function (time) {\n        time = this.toSeconds(time);\n        var currentVal = this.getValueAtTime(time);\n        this.cancelAndHoldAtTime(time);\n        if (this._fromType(currentVal) === 0) {\n            currentVal = this._toType(this._minOutput);\n        }\n        this.setValueAtTime(currentVal, time);\n        return this;\n    };\n    Param.prototype.linearRampToValueAtTime = function (value, endTime) {\n        var numericValue = this._fromType(value);\n        var computedTime = this.toSeconds(endTime);\n        assert(isFinite(numericValue) && isFinite(computedTime), \"Invalid argument(s) to linearRampToValueAtTime: \" + JSON.stringify(value) + \", \" + JSON.stringify(endTime));\n        this._assertRange(numericValue);\n        this._events.add({\n            time: computedTime,\n            type: \"linearRampToValueAtTime\",\n            value: numericValue,\n        });\n        this.log(this.units, \"linearRampToValueAtTime\", value, computedTime);\n        this._param.linearRampToValueAtTime(numericValue, computedTime);\n        return this;\n    };\n    Param.prototype.exponentialRampToValueAtTime = function (value, endTime) {\n        var numericValue = this._fromType(value);\n        numericValue = Math.max(this._minOutput, numericValue);\n        this._assertRange(numericValue);\n        var computedTime = this.toSeconds(endTime);\n        assert(isFinite(numericValue) && isFinite(computedTime), \"Invalid argument(s) to exponentialRampToValueAtTime: \" + JSON.stringify(value) + \", \" + JSON.stringify(endTime));\n        // store the event\n        this._events.add({\n            time: computedTime,\n            type: \"exponentialRampToValueAtTime\",\n            value: numericValue,\n        });\n        this.log(this.units, \"exponentialRampToValueAtTime\", value, computedTime);\n        this._param.exponentialRampToValueAtTime(numericValue, computedTime);\n        return this;\n    };\n    Param.prototype.exponentialRampTo = function (value, rampTime, startTime) {\n        startTime = this.toSeconds(startTime);\n        this.setRampPoint(startTime);\n        this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n        return this;\n    };\n    Param.prototype.linearRampTo = function (value, rampTime, startTime) {\n        startTime = this.toSeconds(startTime);\n        this.setRampPoint(startTime);\n        this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n        return this;\n    };\n    Param.prototype.targetRampTo = function (value, rampTime, startTime) {\n        startTime = this.toSeconds(startTime);\n        this.setRampPoint(startTime);\n        this.exponentialApproachValueAtTime(value, startTime, rampTime);\n        return this;\n    };\n    Param.prototype.exponentialApproachValueAtTime = function (value, time, rampTime) {\n        time = this.toSeconds(time);\n        rampTime = this.toSeconds(rampTime);\n        var timeConstant = Math.log(rampTime + 1) / Math.log(200);\n        this.setTargetAtTime(value, time, timeConstant);\n        // at 90% start a linear ramp to the final value\n        this.cancelAndHoldAtTime(time + rampTime * 0.9);\n        this.linearRampToValueAtTime(value, time + rampTime);\n        return this;\n    };\n    Param.prototype.setTargetAtTime = function (value, startTime, timeConstant) {\n        var numericValue = this._fromType(value);\n        // The value will never be able to approach without timeConstant > 0.\n        assert(isFinite(timeConstant) && timeConstant > 0, \"timeConstant must be a number greater than 0\");\n        var computedTime = this.toSeconds(startTime);\n        this._assertRange(numericValue);\n        assert(isFinite(numericValue) && isFinite(computedTime), \"Invalid argument(s) to setTargetAtTime: \" + JSON.stringify(value) + \", \" + JSON.stringify(startTime));\n        this._events.add({\n            constant: timeConstant,\n            time: computedTime,\n            type: \"setTargetAtTime\",\n            value: numericValue,\n        });\n        this.log(this.units, \"setTargetAtTime\", value, computedTime, timeConstant);\n        this._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n        return this;\n    };\n    Param.prototype.setValueCurveAtTime = function (values, startTime, duration, scaling) {\n        if (scaling === void 0) { scaling = 1; }\n        duration = this.toSeconds(duration);\n        startTime = this.toSeconds(startTime);\n        var startingValue = this._fromType(values[0]) * scaling;\n        this.setValueAtTime(this._toType(startingValue), startTime);\n        var segTime = duration / (values.length - 1);\n        for (var i = 1; i < values.length; i++) {\n            var numericValue = this._fromType(values[i]) * scaling;\n            this.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n        }\n        return this;\n    };\n    Param.prototype.cancelScheduledValues = function (time) {\n        var computedTime = this.toSeconds(time);\n        assert(isFinite(computedTime), \"Invalid argument to cancelScheduledValues: \" + JSON.stringify(time));\n        this._events.cancel(computedTime);\n        this._param.cancelScheduledValues(computedTime);\n        this.log(this.units, \"cancelScheduledValues\", computedTime);\n        return this;\n    };\n    Param.prototype.cancelAndHoldAtTime = function (time) {\n        var computedTime = this.toSeconds(time);\n        var valueAtTime = this._fromType(this.getValueAtTime(computedTime));\n        // remove the schedule events\n        assert(isFinite(computedTime), \"Invalid argument to cancelAndHoldAtTime: \" + JSON.stringify(time));\n        this.log(this.units, \"cancelAndHoldAtTime\", computedTime, \"value=\" + valueAtTime);\n        // if there is an event at the given computedTime\n        // and that even is not a \"set\"\n        var before = this._events.get(computedTime);\n        var after = this._events.getAfter(computedTime);\n        if (before && EQ(before.time, computedTime)) {\n            // remove everything after\n            if (after) {\n                this._param.cancelScheduledValues(after.time);\n                this._events.cancel(after.time);\n            }\n            else {\n                this._param.cancelAndHoldAtTime(computedTime);\n                this._events.cancel(computedTime + this.sampleTime);\n            }\n        }\n        else if (after) {\n            this._param.cancelScheduledValues(after.time);\n            // cancel the next event(s)\n            this._events.cancel(after.time);\n            if (after.type === \"linearRampToValueAtTime\") {\n                this.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);\n            }\n            else if (after.type === \"exponentialRampToValueAtTime\") {\n                this.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);\n            }\n        }\n        // set the value at the given time\n        this._events.add({\n            time: computedTime,\n            type: \"setValueAtTime\",\n            value: valueAtTime,\n        });\n        this._param.setValueAtTime(valueAtTime, computedTime);\n        return this;\n    };\n    Param.prototype.rampTo = function (value, rampTime, startTime) {\n        if (rampTime === void 0) { rampTime = 0.1; }\n        if (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n            this.exponentialRampTo(value, rampTime, startTime);\n        }\n        else {\n            this.linearRampTo(value, rampTime, startTime);\n        }\n        return this;\n    };\n    /**\n     * Apply all of the previously scheduled events to the passed in Param or AudioParam.\n     * The applied values will start at the context's current time and schedule\n     * all of the events which are scheduled on this Param onto the passed in param.\n     */\n    Param.prototype.apply = function (param) {\n        var now = this.context.currentTime;\n        // set the param's value at the current time and schedule everything else\n        param.setValueAtTime(this.getValueAtTime(now), now);\n        // if the previous event was a curve, then set the rest of it\n        var previousEvent = this._events.get(now);\n        if (previousEvent && previousEvent.type === \"setTargetAtTime\") {\n            // approx it until the next event with linear ramps\n            var nextEvent = this._events.getAfter(previousEvent.time);\n            // or for 2 seconds if there is no event\n            var endTime = nextEvent ? nextEvent.time : now + 2;\n            var subdivisions = (endTime - now) / 10;\n            for (var i = now; i < endTime; i += subdivisions) {\n                param.linearRampToValueAtTime(this.getValueAtTime(i), i);\n            }\n        }\n        this._events.forEachAfter(this.context.currentTime, function (event) {\n            if (event.type === \"cancelScheduledValues\") {\n                param.cancelScheduledValues(event.time);\n            }\n            else if (event.type === \"setTargetAtTime\") {\n                param.setTargetAtTime(event.value, event.time, event.constant);\n            }\n            else {\n                param[event.type](event.value, event.time);\n            }\n        });\n        return this;\n    };\n    /**\n     * Replace the Param's internal AudioParam. Will apply scheduled curves\n     * onto the parameter and replace the connections.\n     */\n    Param.prototype.setParam = function (param) {\n        assert(this._swappable, \"The Param must be assigned as 'swappable' in the constructor\");\n        var input = this.input;\n        input.disconnect(this._param);\n        this.apply(param);\n        this._param = param;\n        input.connect(this._param);\n        return this;\n    };\n    Param.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this._events.dispose();\n        return this;\n    };\n    Object.defineProperty(Param.prototype, \"defaultValue\", {\n        get: function () {\n            return this._toType(this._param.defaultValue);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    //-------------------------------------\n    // \tAUTOMATION CURVE CALCULATIONS\n    // \tMIT License, copyright (c) 2014 Jordan Santell\n    //-------------------------------------\n    // Calculates the the value along the curve produced by setTargetAtTime\n    Param.prototype._exponentialApproach = function (t0, v0, v1, timeConstant, t) {\n        return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n    };\n    // Calculates the the value along the curve produced by linearRampToValueAtTime\n    Param.prototype._linearInterpolate = function (t0, v0, t1, v1, t) {\n        return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n    };\n    // Calculates the the value along the curve produced by exponentialRampToValueAtTime\n    Param.prototype._exponentialInterpolate = function (t0, v0, t1, v1, t) {\n        return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n    };\n    return Param;\n}(ToneWithContext));\nexport { Param };\n//# sourceMappingURL=Param.js.map"]},"metadata":{},"sourceType":"module"}