{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\n\nvar TickSource =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(TickSource, _super);\n\n  function TickSource() {\n    var _this = _super.call(this, optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"])) || this;\n\n    _this.name = \"TickSource\";\n    /**\n     * The state timeline\n     */\n\n    _this._state = new StateTimeline();\n    /**\n     * The offset values of the ticks\n     */\n\n    _this._tickOffset = new Timeline();\n    var options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n    _this.frequency = new TickSignal({\n      context: _this.context,\n      units: options.units,\n      value: options.frequency\n    });\n    readOnly(_this, \"frequency\"); // set the initial state\n\n    _this._state.setStateAtTime(\"stopped\", 0); // add the first event\n\n\n    _this.setTicksAtTime(0, 0);\n\n    return _this;\n  }\n\n  TickSource.getDefaults = function () {\n    return Object.assign({\n      frequency: 1,\n      units: \"hertz\"\n    }, ToneWithContext.getDefaults());\n  };\n\n  Object.defineProperty(TickSource.prototype, \"state\", {\n    /**\n     * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n     */\n    get: function () {\n      return this.getStateAtTime(this.now());\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Start the clock at the given time. Optionally pass in an offset\n   * of where to start the tick counter from.\n   * @param  time    The time the clock should start\n   * @param offset The number of ticks to start the source at\n   */\n\n  TickSource.prototype.start = function (time, offset) {\n    var computedTime = this.toSeconds(time);\n\n    if (this._state.getValueAtTime(computedTime) !== \"started\") {\n      this._state.setStateAtTime(\"started\", computedTime);\n\n      if (isDefined(offset)) {\n        this.setTicksAtTime(offset, computedTime);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Stop the clock. Stopping the clock resets the tick counter to 0.\n   * @param time The time when the clock should stop.\n   */\n\n\n  TickSource.prototype.stop = function (time) {\n    var computedTime = this.toSeconds(time); // cancel the previous stop\n\n    if (this._state.getValueAtTime(computedTime) === \"stopped\") {\n      var event_1 = this._state.get(computedTime);\n\n      if (event_1 && event_1.time > 0) {\n        this._tickOffset.cancel(event_1.time);\n\n        this._state.cancel(event_1.time);\n      }\n    }\n\n    this._state.cancel(computedTime);\n\n    this._state.setStateAtTime(\"stopped\", computedTime);\n\n    this.setTicksAtTime(0, computedTime);\n    return this;\n  };\n  /**\n   * Pause the clock. Pausing does not reset the tick counter.\n   * @param time The time when the clock should stop.\n   */\n\n\n  TickSource.prototype.pause = function (time) {\n    var computedTime = this.toSeconds(time);\n\n    if (this._state.getValueAtTime(computedTime) === \"started\") {\n      this._state.setStateAtTime(\"paused\", computedTime);\n    }\n\n    return this;\n  };\n  /**\n   * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n   * @param time When to clear the events after\n   */\n\n\n  TickSource.prototype.cancel = function (time) {\n    time = this.toSeconds(time);\n\n    this._state.cancel(time);\n\n    this._tickOffset.cancel(time);\n\n    return this;\n  };\n  /**\n   * Get the elapsed ticks at the given time\n   * @param  time  When to get the tick value\n   * @return The number of ticks\n   */\n\n\n  TickSource.prototype.getTicksAtTime = function (time) {\n    var _this = this;\n\n    var computedTime = this.toSeconds(time);\n\n    var stopEvent = this._state.getLastState(\"stopped\", computedTime); // this event allows forEachBetween to iterate until the current time\n\n\n    var tmpEvent = {\n      state: \"paused\",\n      time: computedTime\n    };\n\n    this._state.add(tmpEvent); // keep track of the previous offset event\n\n\n    var lastState = stopEvent;\n    var elapsedTicks = 0; // iterate through all the events since the last stop\n\n    this._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, function (e) {\n      var periodStartTime = lastState.time; // if there is an offset event in this period use that\n\n      var offsetEvent = _this._tickOffset.get(e.time);\n\n      if (offsetEvent && offsetEvent.time >= lastState.time) {\n        elapsedTicks = offsetEvent.ticks;\n        periodStartTime = offsetEvent.time;\n      }\n\n      if (lastState.state === \"started\" && e.state !== \"started\") {\n        elapsedTicks += _this.frequency.getTicksAtTime(e.time) - _this.frequency.getTicksAtTime(periodStartTime);\n      }\n\n      lastState = e;\n    }); // remove the temporary event\n\n\n    this._state.remove(tmpEvent); // return the ticks\n\n\n    return elapsedTicks;\n  };\n\n  Object.defineProperty(TickSource.prototype, \"ticks\", {\n    /**\n     * The number of times the callback was invoked. Starts counting at 0\n     * and increments after the callback was invoked. Returns -1 when stopped.\n     */\n    get: function () {\n      return this.getTicksAtTime(this.now());\n    },\n    set: function (t) {\n      this.setTicksAtTime(t, this.now());\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TickSource.prototype, \"seconds\", {\n    /**\n     * The time since ticks=0 that the TickSource has been running. Accounts\n     * for tempo curves\n     */\n    get: function () {\n      return this.getSecondsAtTime(this.now());\n    },\n    set: function (s) {\n      var now = this.now();\n      var ticks = this.frequency.timeToTicks(s, now);\n      this.setTicksAtTime(ticks, now);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Return the elapsed seconds at the given time.\n   * @param  time  When to get the elapsed seconds\n   * @return  The number of elapsed seconds\n   */\n\n  TickSource.prototype.getSecondsAtTime = function (time) {\n    var _this = this;\n\n    time = this.toSeconds(time);\n\n    var stopEvent = this._state.getLastState(\"stopped\", time); // this event allows forEachBetween to iterate until the current time\n\n\n    var tmpEvent = {\n      state: \"paused\",\n      time: time\n    };\n\n    this._state.add(tmpEvent); // keep track of the previous offset event\n\n\n    var lastState = stopEvent;\n    var elapsedSeconds = 0; // iterate through all the events since the last stop\n\n    this._state.forEachBetween(stopEvent.time, time + this.sampleTime, function (e) {\n      var periodStartTime = lastState.time; // if there is an offset event in this period use that\n\n      var offsetEvent = _this._tickOffset.get(e.time);\n\n      if (offsetEvent && offsetEvent.time >= lastState.time) {\n        elapsedSeconds = offsetEvent.seconds;\n        periodStartTime = offsetEvent.time;\n      }\n\n      if (lastState.state === \"started\" && e.state !== \"started\") {\n        elapsedSeconds += e.time - periodStartTime;\n      }\n\n      lastState = e;\n    }); // remove the temporary event\n\n\n    this._state.remove(tmpEvent); // return the ticks\n\n\n    return elapsedSeconds;\n  };\n  /**\n   * Set the clock's ticks at the given time.\n   * @param  ticks The tick value to set\n   * @param  time  When to set the tick value\n   */\n\n\n  TickSource.prototype.setTicksAtTime = function (ticks, time) {\n    time = this.toSeconds(time);\n\n    this._tickOffset.cancel(time);\n\n    this._tickOffset.add({\n      seconds: this.frequency.getDurationOfTicks(ticks, time),\n      ticks: ticks,\n      time: time\n    });\n\n    return this;\n  };\n  /**\n   * Returns the scheduled state at the given time.\n   * @param  time  The time to query.\n   */\n\n\n  TickSource.prototype.getStateAtTime = function (time) {\n    time = this.toSeconds(time);\n    return this._state.getValueAtTime(time);\n  };\n  /**\n   * Get the time of the given tick. The second argument\n   * is when to test before. Since ticks can be set (with setTicksAtTime)\n   * there may be multiple times for a given tick value.\n   * @param  tick The tick number.\n   * @param  before When to measure the tick value from.\n   * @return The time of the tick\n   */\n\n\n  TickSource.prototype.getTimeOfTick = function (tick, before) {\n    if (before === void 0) {\n      before = this.now();\n    }\n\n    var offset = this._tickOffset.get(before);\n\n    var event = this._state.get(before);\n\n    var startTime = Math.max(offset.time, event.time);\n    var absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n    return this.frequency.getTimeOfTick(absoluteTicks);\n  };\n  /**\n   * Invoke the callback event at all scheduled ticks between the\n   * start time and the end time\n   * @param  startTime  The beginning of the search range\n   * @param  endTime    The end of the search range\n   * @param  callback   The callback to invoke with each tick\n   */\n\n\n  TickSource.prototype.forEachTickBetween = function (startTime, endTime, callback) {\n    var _this = this; // only iterate through the sections where it is \"started\"\n\n\n    var lastStateEvent = this._state.get(startTime);\n\n    this._state.forEachBetween(startTime, endTime, function (event) {\n      if (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n        _this.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - _this.sampleTime, callback);\n      }\n\n      lastStateEvent = event;\n    });\n\n    var error = null;\n\n    if (lastStateEvent && lastStateEvent.state === \"started\") {\n      var maxStartTime = Math.max(lastStateEvent.time, startTime); // figure out the difference between the frequency ticks and the\n\n      var startTicks = this.frequency.getTicksAtTime(maxStartTime);\n      var ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n      var diff = startTicks - ticksAtStart;\n      var offset = Math.ceil(diff) - diff;\n      var nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n\n      while (nextTickTime < endTime) {\n        try {\n          callback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n        } catch (e) {\n          error = e;\n          break;\n        }\n\n        nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n      }\n    }\n\n    if (error) {\n      throw error;\n    }\n\n    return this;\n  };\n  /**\n   * Clean up\n   */\n\n\n  TickSource.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._state.dispose();\n\n    this._tickOffset.dispose();\n\n    this.frequency.dispose();\n    return this;\n  };\n\n  return TickSource;\n}(ToneWithContext);\n\nexport { TickSource };","map":{"version":3,"sources":["../../../../Tone/core/clock/TickSource.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\nvar TickSource = /** @class */ (function (_super) {\n    tslib_1.__extends(TickSource, _super);\n    function TickSource() {\n        var _this = _super.call(this, optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"])) || this;\n        _this.name = \"TickSource\";\n        /**\n         * The state timeline\n         */\n        _this._state = new StateTimeline();\n        /**\n         * The offset values of the ticks\n         */\n        _this._tickOffset = new Timeline();\n        var options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n        _this.frequency = new TickSignal({\n            context: _this.context,\n            units: options.units,\n            value: options.frequency,\n        });\n        readOnly(_this, \"frequency\");\n        // set the initial state\n        _this._state.setStateAtTime(\"stopped\", 0);\n        // add the first event\n        _this.setTicksAtTime(0, 0);\n        return _this;\n    }\n    TickSource.getDefaults = function () {\n        return Object.assign({\n            frequency: 1,\n            units: \"hertz\",\n        }, ToneWithContext.getDefaults());\n    };\n    Object.defineProperty(TickSource.prototype, \"state\", {\n        /**\n         * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n         */\n        get: function () {\n            return this.getStateAtTime(this.now());\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Start the clock at the given time. Optionally pass in an offset\n     * of where to start the tick counter from.\n     * @param  time    The time the clock should start\n     * @param offset The number of ticks to start the source at\n     */\n    TickSource.prototype.start = function (time, offset) {\n        var computedTime = this.toSeconds(time);\n        if (this._state.getValueAtTime(computedTime) !== \"started\") {\n            this._state.setStateAtTime(\"started\", computedTime);\n            if (isDefined(offset)) {\n                this.setTicksAtTime(offset, computedTime);\n            }\n        }\n        return this;\n    };\n    /**\n     * Stop the clock. Stopping the clock resets the tick counter to 0.\n     * @param time The time when the clock should stop.\n     */\n    TickSource.prototype.stop = function (time) {\n        var computedTime = this.toSeconds(time);\n        // cancel the previous stop\n        if (this._state.getValueAtTime(computedTime) === \"stopped\") {\n            var event_1 = this._state.get(computedTime);\n            if (event_1 && event_1.time > 0) {\n                this._tickOffset.cancel(event_1.time);\n                this._state.cancel(event_1.time);\n            }\n        }\n        this._state.cancel(computedTime);\n        this._state.setStateAtTime(\"stopped\", computedTime);\n        this.setTicksAtTime(0, computedTime);\n        return this;\n    };\n    /**\n     * Pause the clock. Pausing does not reset the tick counter.\n     * @param time The time when the clock should stop.\n     */\n    TickSource.prototype.pause = function (time) {\n        var computedTime = this.toSeconds(time);\n        if (this._state.getValueAtTime(computedTime) === \"started\") {\n            this._state.setStateAtTime(\"paused\", computedTime);\n        }\n        return this;\n    };\n    /**\n     * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n     * @param time When to clear the events after\n     */\n    TickSource.prototype.cancel = function (time) {\n        time = this.toSeconds(time);\n        this._state.cancel(time);\n        this._tickOffset.cancel(time);\n        return this;\n    };\n    /**\n     * Get the elapsed ticks at the given time\n     * @param  time  When to get the tick value\n     * @return The number of ticks\n     */\n    TickSource.prototype.getTicksAtTime = function (time) {\n        var _this = this;\n        var computedTime = this.toSeconds(time);\n        var stopEvent = this._state.getLastState(\"stopped\", computedTime);\n        // this event allows forEachBetween to iterate until the current time\n        var tmpEvent = { state: \"paused\", time: computedTime };\n        this._state.add(tmpEvent);\n        // keep track of the previous offset event\n        var lastState = stopEvent;\n        var elapsedTicks = 0;\n        // iterate through all the events since the last stop\n        this._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, function (e) {\n            var periodStartTime = lastState.time;\n            // if there is an offset event in this period use that\n            var offsetEvent = _this._tickOffset.get(e.time);\n            if (offsetEvent && offsetEvent.time >= lastState.time) {\n                elapsedTicks = offsetEvent.ticks;\n                periodStartTime = offsetEvent.time;\n            }\n            if (lastState.state === \"started\" && e.state !== \"started\") {\n                elapsedTicks += _this.frequency.getTicksAtTime(e.time) - _this.frequency.getTicksAtTime(periodStartTime);\n            }\n            lastState = e;\n        });\n        // remove the temporary event\n        this._state.remove(tmpEvent);\n        // return the ticks\n        return elapsedTicks;\n    };\n    Object.defineProperty(TickSource.prototype, \"ticks\", {\n        /**\n         * The number of times the callback was invoked. Starts counting at 0\n         * and increments after the callback was invoked. Returns -1 when stopped.\n         */\n        get: function () {\n            return this.getTicksAtTime(this.now());\n        },\n        set: function (t) {\n            this.setTicksAtTime(t, this.now());\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TickSource.prototype, \"seconds\", {\n        /**\n         * The time since ticks=0 that the TickSource has been running. Accounts\n         * for tempo curves\n         */\n        get: function () {\n            return this.getSecondsAtTime(this.now());\n        },\n        set: function (s) {\n            var now = this.now();\n            var ticks = this.frequency.timeToTicks(s, now);\n            this.setTicksAtTime(ticks, now);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Return the elapsed seconds at the given time.\n     * @param  time  When to get the elapsed seconds\n     * @return  The number of elapsed seconds\n     */\n    TickSource.prototype.getSecondsAtTime = function (time) {\n        var _this = this;\n        time = this.toSeconds(time);\n        var stopEvent = this._state.getLastState(\"stopped\", time);\n        // this event allows forEachBetween to iterate until the current time\n        var tmpEvent = { state: \"paused\", time: time };\n        this._state.add(tmpEvent);\n        // keep track of the previous offset event\n        var lastState = stopEvent;\n        var elapsedSeconds = 0;\n        // iterate through all the events since the last stop\n        this._state.forEachBetween(stopEvent.time, time + this.sampleTime, function (e) {\n            var periodStartTime = lastState.time;\n            // if there is an offset event in this period use that\n            var offsetEvent = _this._tickOffset.get(e.time);\n            if (offsetEvent && offsetEvent.time >= lastState.time) {\n                elapsedSeconds = offsetEvent.seconds;\n                periodStartTime = offsetEvent.time;\n            }\n            if (lastState.state === \"started\" && e.state !== \"started\") {\n                elapsedSeconds += e.time - periodStartTime;\n            }\n            lastState = e;\n        });\n        // remove the temporary event\n        this._state.remove(tmpEvent);\n        // return the ticks\n        return elapsedSeconds;\n    };\n    /**\n     * Set the clock's ticks at the given time.\n     * @param  ticks The tick value to set\n     * @param  time  When to set the tick value\n     */\n    TickSource.prototype.setTicksAtTime = function (ticks, time) {\n        time = this.toSeconds(time);\n        this._tickOffset.cancel(time);\n        this._tickOffset.add({\n            seconds: this.frequency.getDurationOfTicks(ticks, time),\n            ticks: ticks,\n            time: time,\n        });\n        return this;\n    };\n    /**\n     * Returns the scheduled state at the given time.\n     * @param  time  The time to query.\n     */\n    TickSource.prototype.getStateAtTime = function (time) {\n        time = this.toSeconds(time);\n        return this._state.getValueAtTime(time);\n    };\n    /**\n     * Get the time of the given tick. The second argument\n     * is when to test before. Since ticks can be set (with setTicksAtTime)\n     * there may be multiple times for a given tick value.\n     * @param  tick The tick number.\n     * @param  before When to measure the tick value from.\n     * @return The time of the tick\n     */\n    TickSource.prototype.getTimeOfTick = function (tick, before) {\n        if (before === void 0) { before = this.now(); }\n        var offset = this._tickOffset.get(before);\n        var event = this._state.get(before);\n        var startTime = Math.max(offset.time, event.time);\n        var absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n        return this.frequency.getTimeOfTick(absoluteTicks);\n    };\n    /**\n     * Invoke the callback event at all scheduled ticks between the\n     * start time and the end time\n     * @param  startTime  The beginning of the search range\n     * @param  endTime    The end of the search range\n     * @param  callback   The callback to invoke with each tick\n     */\n    TickSource.prototype.forEachTickBetween = function (startTime, endTime, callback) {\n        var _this = this;\n        // only iterate through the sections where it is \"started\"\n        var lastStateEvent = this._state.get(startTime);\n        this._state.forEachBetween(startTime, endTime, function (event) {\n            if (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n                _this.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - _this.sampleTime, callback);\n            }\n            lastStateEvent = event;\n        });\n        var error = null;\n        if (lastStateEvent && lastStateEvent.state === \"started\") {\n            var maxStartTime = Math.max(lastStateEvent.time, startTime);\n            // figure out the difference between the frequency ticks and the\n            var startTicks = this.frequency.getTicksAtTime(maxStartTime);\n            var ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n            var diff = startTicks - ticksAtStart;\n            var offset = Math.ceil(diff) - diff;\n            var nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n            while (nextTickTime < endTime) {\n                try {\n                    callback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n                }\n                catch (e) {\n                    error = e;\n                    break;\n                }\n                nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n            }\n        }\n        if (error) {\n            throw error;\n        }\n        return this;\n    };\n    /**\n     * Clean up\n     */\n    TickSource.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this._state.dispose();\n        this._tickOffset.dispose();\n        this.frequency.dispose();\n        return this;\n    };\n    return TickSource;\n}(ToneWithContext));\nexport { TickSource };\n//# sourceMappingURL=TickSource.js.map"]},"metadata":{},"sourceType":"module"}