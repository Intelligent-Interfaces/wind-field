{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { TicksClass } from \"../core/type/Ticks\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isArray, isDefined, isObject, isUndef } from \"../core/util/TypeCheck\";\nimport { ToneEvent } from \"./ToneEvent\";\n/**\n * Part is a collection ToneEvents which can be started/stopped and looped as a single unit.\n *\n * @example\n * import { Part, Synth } from \"tone\";\n * const synth = new Synth().toDestination();\n * const part = new Part(((time, note) => {\n * \t// the notes given as the second element in the array\n * \t// will be passed in as the second argument\n * \tsynth.triggerAttackRelease(note, \"8n\", time);\n * }), [[0, \"C2\"], [\"0:2\", \"C3\"], [\"0:3:2\", \"G2\"]]);\n * @example\n * import { Part, Synth } from \"tone\";\n * const synth = new Synth().toDestination();\n * // use an array of objects as long as the object has a \"time\" attribute\n * const part = new Part(((time, value) => {\n * \t// the value is an object which contains both the note and the velocity\n * \tsynth.triggerAttackRelease(value.note, \"8n\", time, value.velocity);\n * }), [{ time: 0, note: \"C3\", velocity: 0.9 },\n * \t{ time: \"0:2\", note: \"C4\", velocity: 0.5 }\n * ]).start(0);\n * @category Event\n */\n\nvar Part =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Part, _super);\n\n  function Part() {\n    var _this = _super.call(this, optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"])) || this;\n\n    _this.name = \"Part\";\n    /**\n     * Tracks the scheduled events\n     */\n\n    _this._state = new StateTimeline(\"stopped\");\n    /**\n     * The events that belong to this part\n     */\n\n    _this._events = new Set();\n    var options = optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]); // make sure things are assigned in the right order\n\n    _this._state.increasing = true; // add the events\n\n    options.events.forEach(function (event) {\n      if (isArray(event)) {\n        _this.add(event[0], event[1]);\n      } else {\n        _this.add(event);\n      }\n    });\n    return _this;\n  }\n\n  Part.getDefaults = function () {\n    return Object.assign(ToneEvent.getDefaults(), {\n      events: []\n    });\n  };\n  /**\n   * Start the part at the given time.\n   * @param  time    When to start the part.\n   * @param  offset  The offset from the start of the part to begin playing at.\n   */\n\n\n  Part.prototype.start = function (time, offset) {\n    var _this = this;\n\n    var ticks = this.toTicks(time);\n\n    if (this._state.getValueAtTime(ticks) !== \"started\") {\n      offset = defaultArg(offset, this._loop ? this._loopStart : 0);\n\n      if (this._loop) {\n        offset = defaultArg(offset, this._loopStart);\n      } else {\n        offset = defaultArg(offset, 0);\n      }\n\n      var computedOffset_1 = this.toTicks(offset);\n\n      this._state.add({\n        id: -1,\n        offset: computedOffset_1,\n        state: \"started\",\n        time: ticks\n      });\n\n      this._forEach(function (event) {\n        _this._startNote(event, ticks, computedOffset_1);\n      });\n    }\n\n    return this;\n  };\n  /**\n   * Start the event in the given event at the correct time given\n   * the ticks and offset and looping.\n   * @param  event\n   * @param  ticks\n   * @param  offset\n   */\n\n\n  Part.prototype._startNote = function (event, ticks, offset) {\n    ticks -= offset;\n\n    if (this._loop) {\n      if (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {\n        if (event.startOffset < offset) {\n          // start it on the next loop\n          ticks += this._getLoopDuration();\n        }\n\n        event.start(new TicksClass(this.context, ticks));\n      } else if (event.startOffset < this._loopStart && event.startOffset >= offset) {\n        event.loop = false;\n        event.start(new TicksClass(this.context, ticks));\n      }\n    } else if (event.startOffset >= offset) {\n      event.start(new TicksClass(this.context, ticks));\n    }\n  };\n\n  Object.defineProperty(Part.prototype, \"startOffset\", {\n    get: function () {\n      return this._startOffset;\n    },\n    set: function (offset) {\n      var _this = this;\n\n      this._startOffset = offset;\n\n      this._forEach(function (event) {\n        event.startOffset += _this._startOffset;\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Stop the part at the given time.\n   * @param  time  When to stop the part.\n   */\n\n  Part.prototype.stop = function (time) {\n    var ticks = this.toTicks(time);\n\n    this._state.cancel(ticks);\n\n    this._state.setStateAtTime(\"stopped\", ticks);\n\n    this._forEach(function (event) {\n      event.stop(time);\n    });\n\n    return this;\n  };\n  /**\n   * Get/Set an Event's value at the given time.\n   * If a value is passed in and no event exists at\n   * the given time, one will be created with that value.\n   * If two events are at the same time, the first one will\n   * be returned.\n   * @example\n   * import { Part } from \"tone\";\n   * const part = new Part();\n   * part.at(\"1m\"); // returns the part at the first measure\n   * part.at(\"2m\", \"C2\"); // set the value at \"2m\" to C2.\n   * // if an event didn't exist at that time, it will be created.\n   * @param time The time of the event to get or set.\n   * @param value If a value is passed in, the value of the event at the given time will be set to it.\n   */\n\n\n  Part.prototype.at = function (time, value) {\n    var timeInTicks = new TransportTimeClass(this.context, time).toTicks();\n    var tickTime = new TicksClass(this.context, 1).toSeconds();\n\n    var iterator = this._events.values();\n\n    var result = iterator.next();\n\n    while (!result.done) {\n      var event_1 = result.value;\n\n      if (Math.abs(timeInTicks - event_1.startOffset) < tickTime) {\n        if (isDefined(value)) {\n          event_1.value = value;\n        }\n\n        return event_1;\n      }\n\n      result = iterator.next();\n    } // if there was no event at that time, create one\n\n\n    if (isDefined(value)) {\n      this.add(time, value); // return the new event\n\n      return this.at(time);\n    } else {\n      return null;\n    }\n  };\n\n  Part.prototype.add = function (time, value) {\n    // extract the parameters\n    if (time instanceof Object && Reflect.has(time, \"time\")) {\n      value = time;\n      time = value.time;\n    }\n\n    var ticks = this.toTicks(time);\n    var event;\n\n    if (value instanceof ToneEvent) {\n      event = value;\n      event.callback = this._tick.bind(this);\n    } else {\n      event = new ToneEvent({\n        callback: this._tick.bind(this),\n        context: this.context,\n        value: value\n      });\n    } // the start offset\n\n\n    event.startOffset = ticks; // initialize the values\n\n    event.set({\n      humanize: this.humanize,\n      loop: this.loop,\n      loopEnd: this.loopEnd,\n      loopStart: this.loopStart,\n      playbackRate: this.playbackRate,\n      probability: this.probability\n    });\n\n    this._events.add(event); // start the note if it should be played right now\n\n\n    this._restartEvent(event);\n\n    return this;\n  };\n  /**\n   * Restart the given event\n   */\n\n\n  Part.prototype._restartEvent = function (event) {\n    var _this = this;\n\n    this._state.forEach(function (stateEvent) {\n      if (stateEvent.state === \"started\") {\n        _this._startNote(event, stateEvent.time, stateEvent.offset);\n      } else {\n        // stop the note\n        event.stop(new TicksClass(_this.context, stateEvent.time));\n      }\n    });\n  };\n\n  Part.prototype.remove = function (time, value) {\n    var _this = this; // extract the parameters\n\n\n    if (isObject(time) && time.hasOwnProperty(\"time\")) {\n      value = time;\n      time = value.time;\n    }\n\n    time = this.toTicks(time);\n\n    this._events.forEach(function (event) {\n      if (event.startOffset === time) {\n        if (isUndef(value) || isDefined(value) && event.value === value) {\n          _this._events.delete(event);\n\n          event.dispose();\n        }\n      }\n    });\n\n    return this;\n  };\n  /**\n   * Remove all of the notes from the group.\n   */\n\n\n  Part.prototype.clear = function () {\n    this._forEach(function (event) {\n      return event.dispose();\n    });\n\n    this._events.clear();\n\n    return this;\n  };\n  /**\n   * Cancel scheduled state change events: i.e. \"start\" and \"stop\".\n   * @param after The time after which to cancel the scheduled events.\n   */\n\n\n  Part.prototype.cancel = function (after) {\n    this._forEach(function (event) {\n      return event.cancel(after);\n    });\n\n    this._state.cancel(this.toTicks(after));\n\n    return this;\n  };\n  /**\n   * Iterate over all of the events\n   */\n\n\n  Part.prototype._forEach = function (callback) {\n    if (this._events) {\n      this._events.forEach(function (event) {\n        if (event instanceof Part) {\n          event._forEach(callback);\n        } else {\n          callback(event);\n        }\n      });\n    }\n\n    return this;\n  };\n  /**\n   * Set the attribute of all of the events\n   * @param  attr  the attribute to set\n   * @param  value      The value to set it to\n   */\n\n\n  Part.prototype._setAll = function (attr, value) {\n    this._forEach(function (event) {\n      event[attr] = value;\n    });\n  };\n  /**\n   * Internal tick method\n   * @param  time  The time of the event in seconds\n   */\n\n\n  Part.prototype._tick = function (time, value) {\n    if (!this.mute) {\n      this.callback(time, value);\n    }\n  };\n  /**\n   * Determine if the event should be currently looping\n   * given the loop boundries of this Part.\n   * @param  event  The event to test\n   */\n\n\n  Part.prototype._testLoopBoundries = function (event) {\n    if (this._loop && (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd)) {\n      event.cancel(0);\n    } else if (event.state === \"stopped\") {\n      // reschedule it if it's stopped\n      this._restartEvent(event);\n    }\n  };\n\n  Object.defineProperty(Part.prototype, \"probability\", {\n    get: function () {\n      return this._probability;\n    },\n    set: function (prob) {\n      this._probability = prob;\n\n      this._setAll(\"probability\", prob);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Part.prototype, \"humanize\", {\n    get: function () {\n      return this._humanize;\n    },\n    set: function (variation) {\n      this._humanize = variation;\n\n      this._setAll(\"humanize\", variation);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Part.prototype, \"loop\", {\n    /**\n     * If the part should loop or not\n     * between Part.loopStart and\n     * Part.loopEnd. If set to true,\n     * the part will loop indefinitely,\n     * if set to a number greater than 1\n     * it will play a specific number of\n     * times, if set to false, 0 or 1, the\n     * part will only play once.\n     * @example\n     * import { Part } from \"tone\";\n     * const part = new Part();\n     * // loop the part 8 times\n     * part.loop = 8;\n     */\n    get: function () {\n      return this._loop;\n    },\n    set: function (loop) {\n      var _this = this;\n\n      this._loop = loop;\n\n      this._forEach(function (event) {\n        event.loopStart = _this.loopStart;\n        event.loopEnd = _this.loopEnd;\n        event.loop = loop;\n\n        _this._testLoopBoundries(event);\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Part.prototype, \"loopEnd\", {\n    /**\n     * The loopEnd point determines when it will\n     * loop if Part.loop is true.\n     */\n    get: function () {\n      return new TicksClass(this.context, this._loopEnd).toSeconds();\n    },\n    set: function (loopEnd) {\n      var _this = this;\n\n      this._loopEnd = this.toTicks(loopEnd);\n\n      if (this._loop) {\n        this._forEach(function (event) {\n          event.loopEnd = loopEnd;\n\n          _this._testLoopBoundries(event);\n        });\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Part.prototype, \"loopStart\", {\n    /**\n     * The loopStart point determines when it will\n     * loop if Part.loop is true.\n     */\n    get: function () {\n      return new TicksClass(this.context, this._loopStart).toSeconds();\n    },\n    set: function (loopStart) {\n      var _this = this;\n\n      this._loopStart = this.toTicks(loopStart);\n\n      if (this._loop) {\n        this._forEach(function (event) {\n          event.loopStart = _this.loopStart;\n\n          _this._testLoopBoundries(event);\n        });\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Part.prototype, \"playbackRate\", {\n    /**\n     * The playback rate of the part\n     */\n    get: function () {\n      return this._playbackRate;\n    },\n    set: function (rate) {\n      this._playbackRate = rate;\n\n      this._setAll(\"playbackRate\", rate);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Part.prototype, \"length\", {\n    /**\n     * The number of scheduled notes in the part.\n     */\n    get: function () {\n      return this._events.size;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Part.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.clear();\n    return this;\n  };\n\n  return Part;\n}(ToneEvent);\n\nexport { Part };","map":{"version":3,"sources":["../../../Tone/event/Part.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { TicksClass } from \"../core/type/Ticks\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isArray, isDefined, isObject, isUndef } from \"../core/util/TypeCheck\";\nimport { ToneEvent } from \"./ToneEvent\";\n/**\n * Part is a collection ToneEvents which can be started/stopped and looped as a single unit.\n *\n * @example\n * import { Part, Synth } from \"tone\";\n * const synth = new Synth().toDestination();\n * const part = new Part(((time, note) => {\n * \t// the notes given as the second element in the array\n * \t// will be passed in as the second argument\n * \tsynth.triggerAttackRelease(note, \"8n\", time);\n * }), [[0, \"C2\"], [\"0:2\", \"C3\"], [\"0:3:2\", \"G2\"]]);\n * @example\n * import { Part, Synth } from \"tone\";\n * const synth = new Synth().toDestination();\n * // use an array of objects as long as the object has a \"time\" attribute\n * const part = new Part(((time, value) => {\n * \t// the value is an object which contains both the note and the velocity\n * \tsynth.triggerAttackRelease(value.note, \"8n\", time, value.velocity);\n * }), [{ time: 0, note: \"C3\", velocity: 0.9 },\n * \t{ time: \"0:2\", note: \"C4\", velocity: 0.5 }\n * ]).start(0);\n * @category Event\n */\nvar Part = /** @class */ (function (_super) {\n    tslib_1.__extends(Part, _super);\n    function Part() {\n        var _this = _super.call(this, optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"])) || this;\n        _this.name = \"Part\";\n        /**\n         * Tracks the scheduled events\n         */\n        _this._state = new StateTimeline(\"stopped\");\n        /**\n         * The events that belong to this part\n         */\n        _this._events = new Set();\n        var options = optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]);\n        // make sure things are assigned in the right order\n        _this._state.increasing = true;\n        // add the events\n        options.events.forEach(function (event) {\n            if (isArray(event)) {\n                _this.add(event[0], event[1]);\n            }\n            else {\n                _this.add(event);\n            }\n        });\n        return _this;\n    }\n    Part.getDefaults = function () {\n        return Object.assign(ToneEvent.getDefaults(), {\n            events: [],\n        });\n    };\n    /**\n     * Start the part at the given time.\n     * @param  time    When to start the part.\n     * @param  offset  The offset from the start of the part to begin playing at.\n     */\n    Part.prototype.start = function (time, offset) {\n        var _this = this;\n        var ticks = this.toTicks(time);\n        if (this._state.getValueAtTime(ticks) !== \"started\") {\n            offset = defaultArg(offset, this._loop ? this._loopStart : 0);\n            if (this._loop) {\n                offset = defaultArg(offset, this._loopStart);\n            }\n            else {\n                offset = defaultArg(offset, 0);\n            }\n            var computedOffset_1 = this.toTicks(offset);\n            this._state.add({\n                id: -1,\n                offset: computedOffset_1,\n                state: \"started\",\n                time: ticks,\n            });\n            this._forEach(function (event) {\n                _this._startNote(event, ticks, computedOffset_1);\n            });\n        }\n        return this;\n    };\n    /**\n     * Start the event in the given event at the correct time given\n     * the ticks and offset and looping.\n     * @param  event\n     * @param  ticks\n     * @param  offset\n     */\n    Part.prototype._startNote = function (event, ticks, offset) {\n        ticks -= offset;\n        if (this._loop) {\n            if (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {\n                if (event.startOffset < offset) {\n                    // start it on the next loop\n                    ticks += this._getLoopDuration();\n                }\n                event.start(new TicksClass(this.context, ticks));\n            }\n            else if (event.startOffset < this._loopStart && event.startOffset >= offset) {\n                event.loop = false;\n                event.start(new TicksClass(this.context, ticks));\n            }\n        }\n        else if (event.startOffset >= offset) {\n            event.start(new TicksClass(this.context, ticks));\n        }\n    };\n    Object.defineProperty(Part.prototype, \"startOffset\", {\n        get: function () {\n            return this._startOffset;\n        },\n        set: function (offset) {\n            var _this = this;\n            this._startOffset = offset;\n            this._forEach(function (event) {\n                event.startOffset += _this._startOffset;\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Stop the part at the given time.\n     * @param  time  When to stop the part.\n     */\n    Part.prototype.stop = function (time) {\n        var ticks = this.toTicks(time);\n        this._state.cancel(ticks);\n        this._state.setStateAtTime(\"stopped\", ticks);\n        this._forEach(function (event) {\n            event.stop(time);\n        });\n        return this;\n    };\n    /**\n     * Get/Set an Event's value at the given time.\n     * If a value is passed in and no event exists at\n     * the given time, one will be created with that value.\n     * If two events are at the same time, the first one will\n     * be returned.\n     * @example\n     * import { Part } from \"tone\";\n     * const part = new Part();\n     * part.at(\"1m\"); // returns the part at the first measure\n     * part.at(\"2m\", \"C2\"); // set the value at \"2m\" to C2.\n     * // if an event didn't exist at that time, it will be created.\n     * @param time The time of the event to get or set.\n     * @param value If a value is passed in, the value of the event at the given time will be set to it.\n     */\n    Part.prototype.at = function (time, value) {\n        var timeInTicks = new TransportTimeClass(this.context, time).toTicks();\n        var tickTime = new TicksClass(this.context, 1).toSeconds();\n        var iterator = this._events.values();\n        var result = iterator.next();\n        while (!result.done) {\n            var event_1 = result.value;\n            if (Math.abs(timeInTicks - event_1.startOffset) < tickTime) {\n                if (isDefined(value)) {\n                    event_1.value = value;\n                }\n                return event_1;\n            }\n            result = iterator.next();\n        }\n        // if there was no event at that time, create one\n        if (isDefined(value)) {\n            this.add(time, value);\n            // return the new event\n            return this.at(time);\n        }\n        else {\n            return null;\n        }\n    };\n    Part.prototype.add = function (time, value) {\n        // extract the parameters\n        if (time instanceof Object && Reflect.has(time, \"time\")) {\n            value = time;\n            time = value.time;\n        }\n        var ticks = this.toTicks(time);\n        var event;\n        if (value instanceof ToneEvent) {\n            event = value;\n            event.callback = this._tick.bind(this);\n        }\n        else {\n            event = new ToneEvent({\n                callback: this._tick.bind(this),\n                context: this.context,\n                value: value,\n            });\n        }\n        // the start offset\n        event.startOffset = ticks;\n        // initialize the values\n        event.set({\n            humanize: this.humanize,\n            loop: this.loop,\n            loopEnd: this.loopEnd,\n            loopStart: this.loopStart,\n            playbackRate: this.playbackRate,\n            probability: this.probability,\n        });\n        this._events.add(event);\n        // start the note if it should be played right now\n        this._restartEvent(event);\n        return this;\n    };\n    /**\n     * Restart the given event\n     */\n    Part.prototype._restartEvent = function (event) {\n        var _this = this;\n        this._state.forEach(function (stateEvent) {\n            if (stateEvent.state === \"started\") {\n                _this._startNote(event, stateEvent.time, stateEvent.offset);\n            }\n            else {\n                // stop the note\n                event.stop(new TicksClass(_this.context, stateEvent.time));\n            }\n        });\n    };\n    Part.prototype.remove = function (time, value) {\n        var _this = this;\n        // extract the parameters\n        if (isObject(time) && time.hasOwnProperty(\"time\")) {\n            value = time;\n            time = value.time;\n        }\n        time = this.toTicks(time);\n        this._events.forEach(function (event) {\n            if (event.startOffset === time) {\n                if (isUndef(value) || (isDefined(value) && event.value === value)) {\n                    _this._events.delete(event);\n                    event.dispose();\n                }\n            }\n        });\n        return this;\n    };\n    /**\n     * Remove all of the notes from the group.\n     */\n    Part.prototype.clear = function () {\n        this._forEach(function (event) { return event.dispose(); });\n        this._events.clear();\n        return this;\n    };\n    /**\n     * Cancel scheduled state change events: i.e. \"start\" and \"stop\".\n     * @param after The time after which to cancel the scheduled events.\n     */\n    Part.prototype.cancel = function (after) {\n        this._forEach(function (event) { return event.cancel(after); });\n        this._state.cancel(this.toTicks(after));\n        return this;\n    };\n    /**\n     * Iterate over all of the events\n     */\n    Part.prototype._forEach = function (callback) {\n        if (this._events) {\n            this._events.forEach(function (event) {\n                if (event instanceof Part) {\n                    event._forEach(callback);\n                }\n                else {\n                    callback(event);\n                }\n            });\n        }\n        return this;\n    };\n    /**\n     * Set the attribute of all of the events\n     * @param  attr  the attribute to set\n     * @param  value      The value to set it to\n     */\n    Part.prototype._setAll = function (attr, value) {\n        this._forEach(function (event) {\n            event[attr] = value;\n        });\n    };\n    /**\n     * Internal tick method\n     * @param  time  The time of the event in seconds\n     */\n    Part.prototype._tick = function (time, value) {\n        if (!this.mute) {\n            this.callback(time, value);\n        }\n    };\n    /**\n     * Determine if the event should be currently looping\n     * given the loop boundries of this Part.\n     * @param  event  The event to test\n     */\n    Part.prototype._testLoopBoundries = function (event) {\n        if (this._loop && (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd)) {\n            event.cancel(0);\n        }\n        else if (event.state === \"stopped\") {\n            // reschedule it if it's stopped\n            this._restartEvent(event);\n        }\n    };\n    Object.defineProperty(Part.prototype, \"probability\", {\n        get: function () {\n            return this._probability;\n        },\n        set: function (prob) {\n            this._probability = prob;\n            this._setAll(\"probability\", prob);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Part.prototype, \"humanize\", {\n        get: function () {\n            return this._humanize;\n        },\n        set: function (variation) {\n            this._humanize = variation;\n            this._setAll(\"humanize\", variation);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Part.prototype, \"loop\", {\n        /**\n         * If the part should loop or not\n         * between Part.loopStart and\n         * Part.loopEnd. If set to true,\n         * the part will loop indefinitely,\n         * if set to a number greater than 1\n         * it will play a specific number of\n         * times, if set to false, 0 or 1, the\n         * part will only play once.\n         * @example\n         * import { Part } from \"tone\";\n         * const part = new Part();\n         * // loop the part 8 times\n         * part.loop = 8;\n         */\n        get: function () {\n            return this._loop;\n        },\n        set: function (loop) {\n            var _this = this;\n            this._loop = loop;\n            this._forEach(function (event) {\n                event.loopStart = _this.loopStart;\n                event.loopEnd = _this.loopEnd;\n                event.loop = loop;\n                _this._testLoopBoundries(event);\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Part.prototype, \"loopEnd\", {\n        /**\n         * The loopEnd point determines when it will\n         * loop if Part.loop is true.\n         */\n        get: function () {\n            return new TicksClass(this.context, this._loopEnd).toSeconds();\n        },\n        set: function (loopEnd) {\n            var _this = this;\n            this._loopEnd = this.toTicks(loopEnd);\n            if (this._loop) {\n                this._forEach(function (event) {\n                    event.loopEnd = loopEnd;\n                    _this._testLoopBoundries(event);\n                });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Part.prototype, \"loopStart\", {\n        /**\n         * The loopStart point determines when it will\n         * loop if Part.loop is true.\n         */\n        get: function () {\n            return new TicksClass(this.context, this._loopStart).toSeconds();\n        },\n        set: function (loopStart) {\n            var _this = this;\n            this._loopStart = this.toTicks(loopStart);\n            if (this._loop) {\n                this._forEach(function (event) {\n                    event.loopStart = _this.loopStart;\n                    _this._testLoopBoundries(event);\n                });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Part.prototype, \"playbackRate\", {\n        /**\n         * The playback rate of the part\n         */\n        get: function () {\n            return this._playbackRate;\n        },\n        set: function (rate) {\n            this._playbackRate = rate;\n            this._setAll(\"playbackRate\", rate);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Part.prototype, \"length\", {\n        /**\n         * The number of scheduled notes in the part.\n         */\n        get: function () {\n            return this._events.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Part.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this.clear();\n        return this;\n    };\n    return Part;\n}(ToneEvent));\nexport { Part };\n//# sourceMappingURL=Part.js.map"]},"metadata":{},"sourceType":"module"}