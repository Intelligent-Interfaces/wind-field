{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { isAudioBuffer } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck\";\nimport { assert } from \"../util/Debug\";\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n * Aside from load callbacks from individual buffers, ToneAudioBuffer\n * provides events which keep track of the loading progress\n * of _all_ of the buffers. These are ToneAudioBuffer.on(\"load\" / \"progress\" / \"error\")\n * @example\n * import { ToneAudioBuffer } from \"tone\";\n * const buffer = new ToneAudioBuffer(\"https://tonejs.github.io/examples/audio/FWDL.mp3\", () => {\n * \tconsole.log(\"loaded\");\n * });\n * @category Core\n */\n\nvar ToneAudioBuffer =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ToneAudioBuffer, _super);\n\n  function ToneAudioBuffer() {\n    var _this = _super.call(this) || this;\n\n    _this.name = \"ToneAudioBuffer\";\n    /**\n     * Callback when the buffer is loaded.\n     */\n\n    _this.onload = noOp;\n    var options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n    _this.reverse = options.reverse;\n    _this.onload = options.onload;\n\n    if (options.url && isAudioBuffer(options.url) || options.url instanceof ToneAudioBuffer) {\n      _this.set(options.url);\n    } else if (isString(options.url)) {\n      // initiate the download\n      _this.load(options.url).catch(options.onerror);\n    }\n\n    return _this;\n  }\n\n  ToneAudioBuffer.getDefaults = function () {\n    return {\n      onerror: noOp,\n      onload: noOp,\n      reverse: false\n    };\n  };\n\n  Object.defineProperty(ToneAudioBuffer.prototype, \"sampleRate\", {\n    /**\n     * The sample rate of the AudioBuffer\n     */\n    get: function () {\n      if (this._buffer) {\n        return this._buffer.sampleRate;\n      } else {\n        return getContext().sampleRate;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n   */\n\n  ToneAudioBuffer.prototype.set = function (buffer) {\n    var _this = this;\n\n    if (buffer instanceof ToneAudioBuffer) {\n      // if it's loaded, set it\n      if (buffer.loaded) {\n        this._buffer = buffer.get();\n      } else {\n        // otherwise when it's loaded, invoke it's callback\n        buffer.onload = function () {\n          _this.set(buffer);\n\n          _this.onload(_this);\n        };\n      }\n    } else {\n      this._buffer = buffer;\n    } // reverse it initially\n\n\n    if (this._reversed) {\n      this._reverse();\n    }\n\n    return this;\n  };\n  /**\n   * The audio buffer stored in the object.\n   */\n\n\n  ToneAudioBuffer.prototype.get = function () {\n    return this._buffer;\n  };\n  /**\n   * Makes an fetch request for the selected url then decodes the file as an audio buffer.\n   * Invokes the callback once the audio buffer loads.\n   * @param url The url of the buffer to load. filetype support depends on the browser.\n   * @returns A Promise which resolves with this ToneAudioBuffer\n   */\n\n\n  ToneAudioBuffer.prototype.load = function (url) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var promise, audioBuffer, e_1, index;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            promise = ToneAudioBuffer.load(url);\n            ToneAudioBuffer.downloads.push(promise);\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , promise];\n\n          case 2:\n            audioBuffer = _a.sent();\n            this.set(audioBuffer); // invoke the onload method\n\n            this.onload(this);\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            e_1 = _a.sent();\n            index = ToneAudioBuffer.downloads.indexOf(promise);\n            ToneAudioBuffer.downloads.splice(index, 1);\n            throw e_1;\n\n          case 4:\n            return [2\n            /*return*/\n            , this];\n        }\n      });\n    });\n  };\n  /**\n   * clean up\n   */\n\n\n  ToneAudioBuffer.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._buffer = undefined;\n    return this;\n  };\n  /**\n   * Set the audio buffer from the array.\n   * To create a multichannel AudioBuffer, pass in a multidimensional array.\n   * @param array The array to fill the audio buffer\n   */\n\n\n  ToneAudioBuffer.prototype.fromArray = function (array) {\n    var isMultidimensional = isArray(array) && array[0].length > 0;\n    var channels = isMultidimensional ? array.length : 1;\n    var len = isMultidimensional ? array[0].length : array.length;\n    var context = getContext();\n    var buffer = context.createBuffer(channels, len, context.sampleRate);\n    var multiChannelArray = !isMultidimensional && channels === 1 ? [array] : array;\n\n    for (var c = 0; c < channels; c++) {\n      buffer.copyToChannel(multiChannelArray[c], c);\n    }\n\n    this._buffer = buffer;\n    return this;\n  };\n  /**\n   * Sums multiple channels into 1 channel\n   * @param chanNum Optionally only copy a single channel from the array.\n   */\n\n\n  ToneAudioBuffer.prototype.toMono = function (chanNum) {\n    if (isNumber(chanNum)) {\n      this.fromArray(this.toArray(chanNum));\n    } else {\n      var outputArray = new Float32Array(this.length);\n      var numChannels_1 = this.numberOfChannels;\n\n      for (var channel = 0; channel < numChannels_1; channel++) {\n        var channelArray = this.toArray(channel);\n\n        for (var i = 0; i < channelArray.length; i++) {\n          outputArray[i] += channelArray[i];\n        }\n      } // divide by the number of channels\n\n\n      outputArray = outputArray.map(function (sample) {\n        return sample / numChannels_1;\n      });\n      this.fromArray(outputArray);\n    }\n\n    return this;\n  };\n  /**\n   * Get the buffer as an array. Single channel buffers will return a 1-dimensional\n   * Float32Array, and multichannel buffers will return multidimensional arrays.\n   * @param channel Optionally only copy a single channel from the array.\n   */\n\n\n  ToneAudioBuffer.prototype.toArray = function (channel) {\n    if (isNumber(channel)) {\n      return this.getChannelData(channel);\n    } else if (this.numberOfChannels === 1) {\n      return this.toArray(0);\n    } else {\n      var ret = [];\n\n      for (var c = 0; c < this.numberOfChannels; c++) {\n        ret[c] = this.getChannelData(c);\n      }\n\n      return ret;\n    }\n  };\n  /**\n   * Returns the Float32Array representing the PCM audio data for the specific channel.\n   * @param  channel  The channel number to return\n   * @return The audio as a TypedArray\n   */\n\n\n  ToneAudioBuffer.prototype.getChannelData = function (channel) {\n    if (this._buffer) {\n      return this._buffer.getChannelData(channel);\n    } else {\n      return new Float32Array(0);\n    }\n  };\n  /**\n   * Cut a subsection of the array and return a buffer of the\n   * subsection. Does not modify the original buffer\n   * @param start The time to start the slice\n   * @param end The end time to slice. If none is given will default to the end of the buffer\n   */\n\n\n  ToneAudioBuffer.prototype.slice = function (start, end) {\n    if (end === void 0) {\n      end = this.duration;\n    }\n\n    var startSamples = Math.floor(start * this.sampleRate);\n    var endSamples = Math.floor(end * this.sampleRate);\n    assert(startSamples < endSamples, \"The start time must be less than the end time\");\n    var length = endSamples - startSamples;\n    var retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);\n\n    for (var channel = 0; channel < this.numberOfChannels; channel++) {\n      retBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);\n    }\n\n    return new ToneAudioBuffer(retBuffer);\n  };\n  /**\n   * Reverse the buffer.\n   */\n\n\n  ToneAudioBuffer.prototype._reverse = function () {\n    if (this.loaded) {\n      for (var i = 0; i < this.numberOfChannels; i++) {\n        this.getChannelData(i).reverse();\n      }\n    }\n\n    return this;\n  };\n\n  Object.defineProperty(ToneAudioBuffer.prototype, \"loaded\", {\n    /**\n     * If the buffer is loaded or not\n     */\n    get: function () {\n      return this.length > 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ToneAudioBuffer.prototype, \"duration\", {\n    /**\n     * The duration of the buffer in seconds.\n     */\n    get: function () {\n      if (this._buffer) {\n        return this._buffer.duration;\n      } else {\n        return 0;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ToneAudioBuffer.prototype, \"length\", {\n    /**\n     * The length of the buffer in samples\n     */\n    get: function () {\n      if (this._buffer) {\n        return this._buffer.length;\n      } else {\n        return 0;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ToneAudioBuffer.prototype, \"numberOfChannels\", {\n    /**\n     * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n     */\n    get: function () {\n      if (this._buffer) {\n        return this._buffer.numberOfChannels;\n      } else {\n        return 0;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ToneAudioBuffer.prototype, \"reverse\", {\n    /**\n     * Reverse the buffer.\n     */\n    get: function () {\n      return this._reversed;\n    },\n    set: function (rev) {\n      if (this._reversed !== rev) {\n        this._reversed = rev;\n\n        this._reverse();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n   * pass in a multidimensional array.\n   * @param array The array to fill the audio buffer\n   * @return A ToneAudioBuffer created from the array\n   */\n\n  ToneAudioBuffer.fromArray = function (array) {\n    return new ToneAudioBuffer().fromArray(array);\n  };\n  /**\n   * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n   * @param  url The url to load.\n   * @return A promise which resolves to a ToneAudioBuffer\n   */\n\n\n  ToneAudioBuffer.fromUrl = function (url) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var buffer;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            buffer = new ToneAudioBuffer();\n            return [4\n            /*yield*/\n            , buffer.load(url)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  };\n  /**\n   * Loads a url using fetch and returns the AudioBuffer.\n   */\n\n\n  ToneAudioBuffer.load = function (url) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var matches, extensions, extension, extensions_1, extensions_1_1, ext, baseUrl, response, arrayBuffer, audioBuffer;\n\n      var e_2, _a;\n\n      return tslib_1.__generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            matches = url.match(/\\[(.+\\|?)+\\]$/);\n\n            if (matches) {\n              extensions = matches[1].split(\"|\");\n              extension = extensions[0];\n\n              try {\n                for (extensions_1 = tslib_1.__values(extensions), extensions_1_1 = extensions_1.next(); !extensions_1_1.done; extensions_1_1 = extensions_1.next()) {\n                  ext = extensions_1_1.value;\n\n                  if (ToneAudioBuffer.supportsType(ext)) {\n                    extension = ext;\n                    break;\n                  }\n                }\n              } catch (e_2_1) {\n                e_2 = {\n                  error: e_2_1\n                };\n              } finally {\n                try {\n                  if (extensions_1_1 && !extensions_1_1.done && (_a = extensions_1.return)) _a.call(extensions_1);\n                } finally {\n                  if (e_2) throw e_2.error;\n                }\n              }\n\n              url = url.replace(matches[0], extension);\n            }\n\n            baseUrl = ToneAudioBuffer.baseUrl === \"\" || ToneAudioBuffer.baseUrl.endsWith(\"/\") ? ToneAudioBuffer.baseUrl : ToneAudioBuffer.baseUrl + \"/\";\n            return [4\n            /*yield*/\n            , fetch(baseUrl + url)];\n\n          case 1:\n            response = _b.sent();\n\n            if (!response.ok) {\n              throw new Error(\"could not load url: \" + url);\n            }\n\n            return [4\n            /*yield*/\n            , response.arrayBuffer()];\n\n          case 2:\n            arrayBuffer = _b.sent();\n            return [4\n            /*yield*/\n            , getContext().decodeAudioData(arrayBuffer)];\n\n          case 3:\n            audioBuffer = _b.sent();\n            return [2\n            /*return*/\n            , audioBuffer];\n        }\n      });\n    });\n  };\n  /**\n   * Checks a url's extension to see if the current browser can play that file type.\n   * @param url The url/extension to test\n   * @return If the file extension can be played\n   * @static\n   * @example\n   * import { ToneAudioBuffer } from \"tone\";\n   * ToneAudioBuffer.supportsType(\"wav\"); // returns true\n   * ToneAudioBuffer.supportsType(\"path/to/file.wav\"); // returns true\n   */\n\n\n  ToneAudioBuffer.supportsType = function (url) {\n    var extensions = url.split(\".\");\n    var extension = extensions[extensions.length - 1];\n    var response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n    return response !== \"\";\n  };\n  /**\n   * Returns a Promise which resolves when all of the buffers have loaded\n   */\n\n\n  ToneAudioBuffer.loaded = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var _a, _b, promise, e_3_1;\n\n      var e_3, _c;\n\n      return tslib_1.__generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            _d.trys.push([0, 5, 6, 7]);\n\n            _a = tslib_1.__values(ToneAudioBuffer.downloads), _b = _a.next();\n            _d.label = 1;\n\n          case 1:\n            if (!!_b.done) return [3\n            /*break*/\n            , 4];\n            promise = _b.value;\n            return [4\n            /*yield*/\n            , promise];\n\n          case 2:\n            _d.sent();\n\n            _d.label = 3;\n\n          case 3:\n            _b = _a.next();\n            return [3\n            /*break*/\n            , 1];\n\n          case 4:\n            return [3\n            /*break*/\n            , 7];\n\n          case 5:\n            e_3_1 = _d.sent();\n            e_3 = {\n              error: e_3_1\n            };\n            return [3\n            /*break*/\n            , 7];\n\n          case 6:\n            try {\n              if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n            } finally {\n              if (e_3) throw e_3.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 7:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; //-------------------------------------\n  // STATIC METHODS\n  //-------------------------------------\n\n  /**\n   * A path which is prefixed before every url.\n   */\n\n\n  ToneAudioBuffer.baseUrl = \"\";\n  /**\n   * All of the downloads\n   */\n\n  ToneAudioBuffer.downloads = [];\n  return ToneAudioBuffer;\n}(Tone);\n\nexport { ToneAudioBuffer };","map":{"version":3,"sources":["../../../../Tone/core/context/ToneAudioBuffer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { isAudioBuffer } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck\";\nimport { assert } from \"../util/Debug\";\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n * Aside from load callbacks from individual buffers, ToneAudioBuffer\n * provides events which keep track of the loading progress\n * of _all_ of the buffers. These are ToneAudioBuffer.on(\"load\" / \"progress\" / \"error\")\n * @example\n * import { ToneAudioBuffer } from \"tone\";\n * const buffer = new ToneAudioBuffer(\"https://tonejs.github.io/examples/audio/FWDL.mp3\", () => {\n * \tconsole.log(\"loaded\");\n * });\n * @category Core\n */\nvar ToneAudioBuffer = /** @class */ (function (_super) {\n    tslib_1.__extends(ToneAudioBuffer, _super);\n    function ToneAudioBuffer() {\n        var _this = _super.call(this) || this;\n        _this.name = \"ToneAudioBuffer\";\n        /**\n         * Callback when the buffer is loaded.\n         */\n        _this.onload = noOp;\n        var options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n        _this.reverse = options.reverse;\n        _this.onload = options.onload;\n        if (options.url && isAudioBuffer(options.url) || options.url instanceof ToneAudioBuffer) {\n            _this.set(options.url);\n        }\n        else if (isString(options.url)) {\n            // initiate the download\n            _this.load(options.url).catch(options.onerror);\n        }\n        return _this;\n    }\n    ToneAudioBuffer.getDefaults = function () {\n        return {\n            onerror: noOp,\n            onload: noOp,\n            reverse: false,\n        };\n    };\n    Object.defineProperty(ToneAudioBuffer.prototype, \"sampleRate\", {\n        /**\n         * The sample rate of the AudioBuffer\n         */\n        get: function () {\n            if (this._buffer) {\n                return this._buffer.sampleRate;\n            }\n            else {\n                return getContext().sampleRate;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n     */\n    ToneAudioBuffer.prototype.set = function (buffer) {\n        var _this = this;\n        if (buffer instanceof ToneAudioBuffer) {\n            // if it's loaded, set it\n            if (buffer.loaded) {\n                this._buffer = buffer.get();\n            }\n            else {\n                // otherwise when it's loaded, invoke it's callback\n                buffer.onload = function () {\n                    _this.set(buffer);\n                    _this.onload(_this);\n                };\n            }\n        }\n        else {\n            this._buffer = buffer;\n        }\n        // reverse it initially\n        if (this._reversed) {\n            this._reverse();\n        }\n        return this;\n    };\n    /**\n     * The audio buffer stored in the object.\n     */\n    ToneAudioBuffer.prototype.get = function () {\n        return this._buffer;\n    };\n    /**\n     * Makes an fetch request for the selected url then decodes the file as an audio buffer.\n     * Invokes the callback once the audio buffer loads.\n     * @param url The url of the buffer to load. filetype support depends on the browser.\n     * @returns A Promise which resolves with this ToneAudioBuffer\n     */\n    ToneAudioBuffer.prototype.load = function (url) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var promise, audioBuffer, e_1, index;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        promise = ToneAudioBuffer.load(url);\n                        ToneAudioBuffer.downloads.push(promise);\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, promise];\n                    case 2:\n                        audioBuffer = _a.sent();\n                        this.set(audioBuffer);\n                        // invoke the onload method\n                        this.onload(this);\n                        return [3 /*break*/, 4];\n                    case 3:\n                        e_1 = _a.sent();\n                        index = ToneAudioBuffer.downloads.indexOf(promise);\n                        ToneAudioBuffer.downloads.splice(index, 1);\n                        throw e_1;\n                    case 4: return [2 /*return*/, this];\n                }\n            });\n        });\n    };\n    /**\n     * clean up\n     */\n    ToneAudioBuffer.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this._buffer = undefined;\n        return this;\n    };\n    /**\n     * Set the audio buffer from the array.\n     * To create a multichannel AudioBuffer, pass in a multidimensional array.\n     * @param array The array to fill the audio buffer\n     */\n    ToneAudioBuffer.prototype.fromArray = function (array) {\n        var isMultidimensional = isArray(array) && array[0].length > 0;\n        var channels = isMultidimensional ? array.length : 1;\n        var len = isMultidimensional ? array[0].length : array.length;\n        var context = getContext();\n        var buffer = context.createBuffer(channels, len, context.sampleRate);\n        var multiChannelArray = !isMultidimensional && channels === 1 ?\n            [array] : array;\n        for (var c = 0; c < channels; c++) {\n            buffer.copyToChannel(multiChannelArray[c], c);\n        }\n        this._buffer = buffer;\n        return this;\n    };\n    /**\n     * Sums multiple channels into 1 channel\n     * @param chanNum Optionally only copy a single channel from the array.\n     */\n    ToneAudioBuffer.prototype.toMono = function (chanNum) {\n        if (isNumber(chanNum)) {\n            this.fromArray(this.toArray(chanNum));\n        }\n        else {\n            var outputArray = new Float32Array(this.length);\n            var numChannels_1 = this.numberOfChannels;\n            for (var channel = 0; channel < numChannels_1; channel++) {\n                var channelArray = this.toArray(channel);\n                for (var i = 0; i < channelArray.length; i++) {\n                    outputArray[i] += channelArray[i];\n                }\n            }\n            // divide by the number of channels\n            outputArray = outputArray.map(function (sample) { return sample / numChannels_1; });\n            this.fromArray(outputArray);\n        }\n        return this;\n    };\n    /**\n     * Get the buffer as an array. Single channel buffers will return a 1-dimensional\n     * Float32Array, and multichannel buffers will return multidimensional arrays.\n     * @param channel Optionally only copy a single channel from the array.\n     */\n    ToneAudioBuffer.prototype.toArray = function (channel) {\n        if (isNumber(channel)) {\n            return this.getChannelData(channel);\n        }\n        else if (this.numberOfChannels === 1) {\n            return this.toArray(0);\n        }\n        else {\n            var ret = [];\n            for (var c = 0; c < this.numberOfChannels; c++) {\n                ret[c] = this.getChannelData(c);\n            }\n            return ret;\n        }\n    };\n    /**\n     * Returns the Float32Array representing the PCM audio data for the specific channel.\n     * @param  channel  The channel number to return\n     * @return The audio as a TypedArray\n     */\n    ToneAudioBuffer.prototype.getChannelData = function (channel) {\n        if (this._buffer) {\n            return this._buffer.getChannelData(channel);\n        }\n        else {\n            return new Float32Array(0);\n        }\n    };\n    /**\n     * Cut a subsection of the array and return a buffer of the\n     * subsection. Does not modify the original buffer\n     * @param start The time to start the slice\n     * @param end The end time to slice. If none is given will default to the end of the buffer\n     */\n    ToneAudioBuffer.prototype.slice = function (start, end) {\n        if (end === void 0) { end = this.duration; }\n        var startSamples = Math.floor(start * this.sampleRate);\n        var endSamples = Math.floor(end * this.sampleRate);\n        assert(startSamples < endSamples, \"The start time must be less than the end time\");\n        var length = endSamples - startSamples;\n        var retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);\n        for (var channel = 0; channel < this.numberOfChannels; channel++) {\n            retBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);\n        }\n        return new ToneAudioBuffer(retBuffer);\n    };\n    /**\n     * Reverse the buffer.\n     */\n    ToneAudioBuffer.prototype._reverse = function () {\n        if (this.loaded) {\n            for (var i = 0; i < this.numberOfChannels; i++) {\n                this.getChannelData(i).reverse();\n            }\n        }\n        return this;\n    };\n    Object.defineProperty(ToneAudioBuffer.prototype, \"loaded\", {\n        /**\n         * If the buffer is loaded or not\n         */\n        get: function () {\n            return this.length > 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ToneAudioBuffer.prototype, \"duration\", {\n        /**\n         * The duration of the buffer in seconds.\n         */\n        get: function () {\n            if (this._buffer) {\n                return this._buffer.duration;\n            }\n            else {\n                return 0;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ToneAudioBuffer.prototype, \"length\", {\n        /**\n         * The length of the buffer in samples\n         */\n        get: function () {\n            if (this._buffer) {\n                return this._buffer.length;\n            }\n            else {\n                return 0;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ToneAudioBuffer.prototype, \"numberOfChannels\", {\n        /**\n         * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n         */\n        get: function () {\n            if (this._buffer) {\n                return this._buffer.numberOfChannels;\n            }\n            else {\n                return 0;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ToneAudioBuffer.prototype, \"reverse\", {\n        /**\n         * Reverse the buffer.\n         */\n        get: function () {\n            return this._reversed;\n        },\n        set: function (rev) {\n            if (this._reversed !== rev) {\n                this._reversed = rev;\n                this._reverse();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n     * pass in a multidimensional array.\n     * @param array The array to fill the audio buffer\n     * @return A ToneAudioBuffer created from the array\n     */\n    ToneAudioBuffer.fromArray = function (array) {\n        return (new ToneAudioBuffer()).fromArray(array);\n    };\n    /**\n     * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n     * @param  url The url to load.\n     * @return A promise which resolves to a ToneAudioBuffer\n     */\n    ToneAudioBuffer.fromUrl = function (url) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var buffer;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        buffer = new ToneAudioBuffer();\n                        return [4 /*yield*/, buffer.load(url)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    /**\n     * Loads a url using fetch and returns the AudioBuffer.\n     */\n    ToneAudioBuffer.load = function (url) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var matches, extensions, extension, extensions_1, extensions_1_1, ext, baseUrl, response, arrayBuffer, audioBuffer;\n            var e_2, _a;\n            return tslib_1.__generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        matches = url.match(/\\[(.+\\|?)+\\]$/);\n                        if (matches) {\n                            extensions = matches[1].split(\"|\");\n                            extension = extensions[0];\n                            try {\n                                for (extensions_1 = tslib_1.__values(extensions), extensions_1_1 = extensions_1.next(); !extensions_1_1.done; extensions_1_1 = extensions_1.next()) {\n                                    ext = extensions_1_1.value;\n                                    if (ToneAudioBuffer.supportsType(ext)) {\n                                        extension = ext;\n                                        break;\n                                    }\n                                }\n                            }\n                            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                            finally {\n                                try {\n                                    if (extensions_1_1 && !extensions_1_1.done && (_a = extensions_1.return)) _a.call(extensions_1);\n                                }\n                                finally { if (e_2) throw e_2.error; }\n                            }\n                            url = url.replace(matches[0], extension);\n                        }\n                        baseUrl = ToneAudioBuffer.baseUrl === \"\" || ToneAudioBuffer.baseUrl.endsWith(\"/\") ? ToneAudioBuffer.baseUrl : ToneAudioBuffer.baseUrl + \"/\";\n                        return [4 /*yield*/, fetch(baseUrl + url)];\n                    case 1:\n                        response = _b.sent();\n                        if (!response.ok) {\n                            throw new Error(\"could not load url: \" + url);\n                        }\n                        return [4 /*yield*/, response.arrayBuffer()];\n                    case 2:\n                        arrayBuffer = _b.sent();\n                        return [4 /*yield*/, getContext().decodeAudioData(arrayBuffer)];\n                    case 3:\n                        audioBuffer = _b.sent();\n                        return [2 /*return*/, audioBuffer];\n                }\n            });\n        });\n    };\n    /**\n     * Checks a url's extension to see if the current browser can play that file type.\n     * @param url The url/extension to test\n     * @return If the file extension can be played\n     * @static\n     * @example\n     * import { ToneAudioBuffer } from \"tone\";\n     * ToneAudioBuffer.supportsType(\"wav\"); // returns true\n     * ToneAudioBuffer.supportsType(\"path/to/file.wav\"); // returns true\n     */\n    ToneAudioBuffer.supportsType = function (url) {\n        var extensions = url.split(\".\");\n        var extension = extensions[extensions.length - 1];\n        var response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n        return response !== \"\";\n    };\n    /**\n     * Returns a Promise which resolves when all of the buffers have loaded\n     */\n    ToneAudioBuffer.loaded = function () {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var _a, _b, promise, e_3_1;\n            var e_3, _c;\n            return tslib_1.__generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0:\n                        _d.trys.push([0, 5, 6, 7]);\n                        _a = tslib_1.__values(ToneAudioBuffer.downloads), _b = _a.next();\n                        _d.label = 1;\n                    case 1:\n                        if (!!_b.done) return [3 /*break*/, 4];\n                        promise = _b.value;\n                        return [4 /*yield*/, promise];\n                    case 2:\n                        _d.sent();\n                        _d.label = 3;\n                    case 3:\n                        _b = _a.next();\n                        return [3 /*break*/, 1];\n                    case 4: return [3 /*break*/, 7];\n                    case 5:\n                        e_3_1 = _d.sent();\n                        e_3 = { error: e_3_1 };\n                        return [3 /*break*/, 7];\n                    case 6:\n                        try {\n                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n                        }\n                        finally { if (e_3) throw e_3.error; }\n                        return [7 /*endfinally*/];\n                    case 7: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    //-------------------------------------\n    // STATIC METHODS\n    //-------------------------------------\n    /**\n     * A path which is prefixed before every url.\n     */\n    ToneAudioBuffer.baseUrl = \"\";\n    /**\n     * All of the downloads\n     */\n    ToneAudioBuffer.downloads = [];\n    return ToneAudioBuffer;\n}(Tone));\nexport { ToneAudioBuffer };\n//# sourceMappingURL=ToneAudioBuffer.js.map"]},"metadata":{},"sourceType":"module"}