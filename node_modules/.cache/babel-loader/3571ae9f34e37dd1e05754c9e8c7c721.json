{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { Tone } from \"../Tone\";\nimport { optionsFromArguments } from \"./Defaults\";\nimport { assert } from \"./Debug\";\nimport { EQ, GT, GTE, LT } from \"./Math\";\n/**\n * A Timeline class for scheduling and maintaining state\n * along a timeline. All events must have a \"time\" property.\n * Internally, events are stored in time order for fast\n * retrieval.\n */\n\nvar Timeline =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Timeline, _super);\n\n  function Timeline() {\n    var _this = _super.call(this) || this;\n\n    _this.name = \"Timeline\";\n    /**\n     * The array of scheduled timeline events\n     */\n\n    _this._timeline = [];\n    var options = optionsFromArguments(Timeline.getDefaults(), arguments, [\"memory\"]);\n    _this.memory = options.memory;\n    _this.increasing = options.increasing;\n    return _this;\n  }\n\n  Timeline.getDefaults = function () {\n    return {\n      memory: Infinity,\n      increasing: false\n    };\n  };\n\n  Object.defineProperty(Timeline.prototype, \"length\", {\n    /**\n     * The number of items in the timeline.\n     */\n    get: function () {\n      return this._timeline.length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Insert an event object onto the timeline. Events must have a \"time\" attribute.\n   * @param event  The event object to insert into the timeline.\n   */\n\n  Timeline.prototype.add = function (event) {\n    // the event needs to have a time attribute\n    assert(Reflect.has(event, \"time\"), \"Timeline: events must have a time attribute\");\n    event.time = event.time.valueOf();\n\n    if (this.increasing && this.length) {\n      var lastValue = this._timeline[this.length - 1];\n      assert(GTE(event.time, lastValue.time), \"The time must be greater than or equal to the last scheduled time\");\n\n      this._timeline.push(event);\n    } else {\n      var index = this._search(event.time);\n\n      this._timeline.splice(index + 1, 0, event);\n    } // if the length is more than the memory, remove the previous ones\n\n\n    if (this.length > this.memory) {\n      var diff = this.length - this.memory;\n\n      this._timeline.splice(0, diff);\n    }\n\n    return this;\n  };\n  /**\n   * Remove an event from the timeline.\n   * @param  {Object}  event  The event object to remove from the list.\n   * @returns {Timeline} this\n   */\n\n\n  Timeline.prototype.remove = function (event) {\n    var index = this._timeline.indexOf(event);\n\n    if (index !== -1) {\n      this._timeline.splice(index, 1);\n    }\n\n    return this;\n  };\n  /**\n   * Get the nearest event whose time is less than or equal to the given time.\n   * @param  time  The time to query.\n   */\n\n\n  Timeline.prototype.get = function (time, param) {\n    if (param === void 0) {\n      param = \"time\";\n    }\n\n    var index = this._search(time, param);\n\n    if (index !== -1) {\n      return this._timeline[index];\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Return the first event in the timeline without removing it\n   * @returns {Object} The first event object\n   */\n\n\n  Timeline.prototype.peek = function () {\n    return this._timeline[0];\n  };\n  /**\n   * Return the first event in the timeline and remove it\n   */\n\n\n  Timeline.prototype.shift = function () {\n    return this._timeline.shift();\n  };\n  /**\n   * Get the event which is scheduled after the given time.\n   * @param  time  The time to query.\n   */\n\n\n  Timeline.prototype.getAfter = function (time, param) {\n    if (param === void 0) {\n      param = \"time\";\n    }\n\n    var index = this._search(time, param);\n\n    if (index + 1 < this._timeline.length) {\n      return this._timeline[index + 1];\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Get the event before the event at the given time.\n   * @param  time  The time to query.\n   */\n\n\n  Timeline.prototype.getBefore = function (time) {\n    var len = this._timeline.length; // if it's after the last item, return the last item\n\n    if (len > 0 && this._timeline[len - 1].time < time) {\n      return this._timeline[len - 1];\n    }\n\n    var index = this._search(time);\n\n    if (index - 1 >= 0) {\n      return this._timeline[index - 1];\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Cancel events at and after the given time\n   * @param  after  The time to query.\n   */\n\n\n  Timeline.prototype.cancel = function (after) {\n    if (this._timeline.length > 1) {\n      var index = this._search(after);\n\n      if (index >= 0) {\n        if (EQ(this._timeline[index].time, after)) {\n          // get the first item with that time\n          for (var i = index; i >= 0; i--) {\n            if (EQ(this._timeline[i].time, after)) {\n              index = i;\n            } else {\n              break;\n            }\n          }\n\n          this._timeline = this._timeline.slice(0, index);\n        } else {\n          this._timeline = this._timeline.slice(0, index + 1);\n        }\n      } else {\n        this._timeline = [];\n      }\n    } else if (this._timeline.length === 1) {\n      // the first item's time\n      if (GTE(this._timeline[0].time, after)) {\n        this._timeline = [];\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Cancel events before or equal to the given time.\n   * @param  time  The time to cancel before.\n   */\n\n\n  Timeline.prototype.cancelBefore = function (time) {\n    var index = this._search(time);\n\n    if (index >= 0) {\n      this._timeline = this._timeline.slice(index + 1);\n    }\n\n    return this;\n  };\n  /**\n   * Returns the previous event if there is one. null otherwise\n   * @param  event The event to find the previous one of\n   * @return The event right before the given event\n   */\n\n\n  Timeline.prototype.previousEvent = function (event) {\n    var index = this._timeline.indexOf(event);\n\n    if (index > 0) {\n      return this._timeline[index - 1];\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Does a binary search on the timeline array and returns the\n   * nearest event index whose time is after or equal to the given time.\n   * If a time is searched before the first index in the timeline, -1 is returned.\n   * If the time is after the end, the index of the last item is returned.\n   * @param  time\n   */\n\n\n  Timeline.prototype._search = function (time, param) {\n    if (param === void 0) {\n      param = \"time\";\n    }\n\n    if (this._timeline.length === 0) {\n      return -1;\n    }\n\n    var beginning = 0;\n    var len = this._timeline.length;\n    var end = len;\n\n    if (len > 0 && this._timeline[len - 1][param] <= time) {\n      return len - 1;\n    }\n\n    while (beginning < end) {\n      // calculate the midpoint for roughly equal partition\n      var midPoint = Math.floor(beginning + (end - beginning) / 2);\n      var event_1 = this._timeline[midPoint];\n      var nextEvent = this._timeline[midPoint + 1];\n\n      if (EQ(event_1[param], time)) {\n        // choose the last one that has the same time\n        for (var i = midPoint; i < this._timeline.length; i++) {\n          var testEvent = this._timeline[i];\n\n          if (EQ(testEvent[param], time)) {\n            midPoint = i;\n          }\n        }\n\n        return midPoint;\n      } else if (LT(event_1[param], time) && GT(nextEvent[param], time)) {\n        return midPoint;\n      } else if (GT(event_1[param], time)) {\n        // search lower\n        end = midPoint;\n      } else {\n        // search upper\n        beginning = midPoint + 1;\n      }\n    }\n\n    return -1;\n  };\n  /**\n   * Internal iterator. Applies extra safety checks for\n   * removing items from the array.\n   */\n\n\n  Timeline.prototype._iterate = function (callback, lowerBound, upperBound) {\n    if (lowerBound === void 0) {\n      lowerBound = 0;\n    }\n\n    if (upperBound === void 0) {\n      upperBound = this._timeline.length - 1;\n    }\n\n    this._timeline.slice(lowerBound, upperBound + 1).forEach(callback);\n  };\n  /**\n   * Iterate over everything in the array\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  Timeline.prototype.forEach = function (callback) {\n    this._iterate(callback);\n\n    return this;\n  };\n  /**\n   * Iterate over everything in the array at or before the given time.\n   * @param  time The time to check if items are before\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  Timeline.prototype.forEachBefore = function (time, callback) {\n    // iterate over the items in reverse so that removing an item doesn't break things\n    var upperBound = this._search(time);\n\n    if (upperBound !== -1) {\n      this._iterate(callback, 0, upperBound);\n    }\n\n    return this;\n  };\n  /**\n   * Iterate over everything in the array after the given time.\n   * @param  time The time to check if items are before\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  Timeline.prototype.forEachAfter = function (time, callback) {\n    // iterate over the items in reverse so that removing an item doesn't break things\n    var lowerBound = this._search(time);\n\n    this._iterate(callback, lowerBound + 1);\n\n    return this;\n  };\n  /**\n   * Iterate over everything in the array between the startTime and endTime.\n   * The timerange is inclusive of the startTime, but exclusive of the endTime.\n   * range = [startTime, endTime).\n   * @param  startTime The time to check if items are before\n   * @param  endTime The end of the test interval.\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  Timeline.prototype.forEachBetween = function (startTime, endTime, callback) {\n    var lowerBound = this._search(startTime);\n\n    var upperBound = this._search(endTime);\n\n    if (lowerBound !== -1 && upperBound !== -1) {\n      if (this._timeline[lowerBound].time !== startTime) {\n        lowerBound += 1;\n      } // exclusive of the end time\n\n\n      if (this._timeline[upperBound].time === endTime) {\n        upperBound -= 1;\n      }\n\n      this._iterate(callback, lowerBound, upperBound);\n    } else if (lowerBound === -1) {\n      this._iterate(callback, 0, upperBound);\n    }\n\n    return this;\n  };\n  /**\n   * Iterate over everything in the array at or after the given time. Similar to\n   * forEachAfter, but includes the item(s) at the given time.\n   * @param  time The time to check if items are before\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  Timeline.prototype.forEachFrom = function (time, callback) {\n    // iterate over the items in reverse so that removing an item doesn't break things\n    var lowerBound = this._search(time); // work backwards until the event time is less than time\n\n\n    while (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {\n      lowerBound--;\n    }\n\n    this._iterate(callback, lowerBound + 1);\n\n    return this;\n  };\n  /**\n   * Iterate over everything in the array at the given time\n   * @param  time The time to check if items are before\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  Timeline.prototype.forEachAtTime = function (time, callback) {\n    // iterate over the items in reverse so that removing an item doesn't break things\n    var upperBound = this._search(time);\n\n    if (upperBound !== -1) {\n      this._iterate(function (event) {\n        if (event.time === time) {\n          callback(event);\n        }\n      }, 0, upperBound);\n    }\n\n    return this;\n  };\n  /**\n   * Clean up.\n   */\n\n\n  Timeline.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._timeline = [];\n    return this;\n  };\n\n  return Timeline;\n}(Tone);\n\nexport { Timeline };","map":{"version":3,"sources":["../../../../Tone/core/util/Timeline.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { Tone } from \"../Tone\";\nimport { optionsFromArguments } from \"./Defaults\";\nimport { assert } from \"./Debug\";\nimport { EQ, GT, GTE, LT } from \"./Math\";\n/**\n * A Timeline class for scheduling and maintaining state\n * along a timeline. All events must have a \"time\" property.\n * Internally, events are stored in time order for fast\n * retrieval.\n */\nvar Timeline = /** @class */ (function (_super) {\n    tslib_1.__extends(Timeline, _super);\n    function Timeline() {\n        var _this = _super.call(this) || this;\n        _this.name = \"Timeline\";\n        /**\n         * The array of scheduled timeline events\n         */\n        _this._timeline = [];\n        var options = optionsFromArguments(Timeline.getDefaults(), arguments, [\"memory\"]);\n        _this.memory = options.memory;\n        _this.increasing = options.increasing;\n        return _this;\n    }\n    Timeline.getDefaults = function () {\n        return {\n            memory: Infinity,\n            increasing: false,\n        };\n    };\n    Object.defineProperty(Timeline.prototype, \"length\", {\n        /**\n         * The number of items in the timeline.\n         */\n        get: function () {\n            return this._timeline.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Insert an event object onto the timeline. Events must have a \"time\" attribute.\n     * @param event  The event object to insert into the timeline.\n     */\n    Timeline.prototype.add = function (event) {\n        // the event needs to have a time attribute\n        assert(Reflect.has(event, \"time\"), \"Timeline: events must have a time attribute\");\n        event.time = event.time.valueOf();\n        if (this.increasing && this.length) {\n            var lastValue = this._timeline[this.length - 1];\n            assert(GTE(event.time, lastValue.time), \"The time must be greater than or equal to the last scheduled time\");\n            this._timeline.push(event);\n        }\n        else {\n            var index = this._search(event.time);\n            this._timeline.splice(index + 1, 0, event);\n        }\n        // if the length is more than the memory, remove the previous ones\n        if (this.length > this.memory) {\n            var diff = this.length - this.memory;\n            this._timeline.splice(0, diff);\n        }\n        return this;\n    };\n    /**\n     * Remove an event from the timeline.\n     * @param  {Object}  event  The event object to remove from the list.\n     * @returns {Timeline} this\n     */\n    Timeline.prototype.remove = function (event) {\n        var index = this._timeline.indexOf(event);\n        if (index !== -1) {\n            this._timeline.splice(index, 1);\n        }\n        return this;\n    };\n    /**\n     * Get the nearest event whose time is less than or equal to the given time.\n     * @param  time  The time to query.\n     */\n    Timeline.prototype.get = function (time, param) {\n        if (param === void 0) { param = \"time\"; }\n        var index = this._search(time, param);\n        if (index !== -1) {\n            return this._timeline[index];\n        }\n        else {\n            return null;\n        }\n    };\n    /**\n     * Return the first event in the timeline without removing it\n     * @returns {Object} The first event object\n     */\n    Timeline.prototype.peek = function () {\n        return this._timeline[0];\n    };\n    /**\n     * Return the first event in the timeline and remove it\n     */\n    Timeline.prototype.shift = function () {\n        return this._timeline.shift();\n    };\n    /**\n     * Get the event which is scheduled after the given time.\n     * @param  time  The time to query.\n     */\n    Timeline.prototype.getAfter = function (time, param) {\n        if (param === void 0) { param = \"time\"; }\n        var index = this._search(time, param);\n        if (index + 1 < this._timeline.length) {\n            return this._timeline[index + 1];\n        }\n        else {\n            return null;\n        }\n    };\n    /**\n     * Get the event before the event at the given time.\n     * @param  time  The time to query.\n     */\n    Timeline.prototype.getBefore = function (time) {\n        var len = this._timeline.length;\n        // if it's after the last item, return the last item\n        if (len > 0 && this._timeline[len - 1].time < time) {\n            return this._timeline[len - 1];\n        }\n        var index = this._search(time);\n        if (index - 1 >= 0) {\n            return this._timeline[index - 1];\n        }\n        else {\n            return null;\n        }\n    };\n    /**\n     * Cancel events at and after the given time\n     * @param  after  The time to query.\n     */\n    Timeline.prototype.cancel = function (after) {\n        if (this._timeline.length > 1) {\n            var index = this._search(after);\n            if (index >= 0) {\n                if (EQ(this._timeline[index].time, after)) {\n                    // get the first item with that time\n                    for (var i = index; i >= 0; i--) {\n                        if (EQ(this._timeline[i].time, after)) {\n                            index = i;\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                    this._timeline = this._timeline.slice(0, index);\n                }\n                else {\n                    this._timeline = this._timeline.slice(0, index + 1);\n                }\n            }\n            else {\n                this._timeline = [];\n            }\n        }\n        else if (this._timeline.length === 1) {\n            // the first item's time\n            if (GTE(this._timeline[0].time, after)) {\n                this._timeline = [];\n            }\n        }\n        return this;\n    };\n    /**\n     * Cancel events before or equal to the given time.\n     * @param  time  The time to cancel before.\n     */\n    Timeline.prototype.cancelBefore = function (time) {\n        var index = this._search(time);\n        if (index >= 0) {\n            this._timeline = this._timeline.slice(index + 1);\n        }\n        return this;\n    };\n    /**\n     * Returns the previous event if there is one. null otherwise\n     * @param  event The event to find the previous one of\n     * @return The event right before the given event\n     */\n    Timeline.prototype.previousEvent = function (event) {\n        var index = this._timeline.indexOf(event);\n        if (index > 0) {\n            return this._timeline[index - 1];\n        }\n        else {\n            return null;\n        }\n    };\n    /**\n     * Does a binary search on the timeline array and returns the\n     * nearest event index whose time is after or equal to the given time.\n     * If a time is searched before the first index in the timeline, -1 is returned.\n     * If the time is after the end, the index of the last item is returned.\n     * @param  time\n     */\n    Timeline.prototype._search = function (time, param) {\n        if (param === void 0) { param = \"time\"; }\n        if (this._timeline.length === 0) {\n            return -1;\n        }\n        var beginning = 0;\n        var len = this._timeline.length;\n        var end = len;\n        if (len > 0 && this._timeline[len - 1][param] <= time) {\n            return len - 1;\n        }\n        while (beginning < end) {\n            // calculate the midpoint for roughly equal partition\n            var midPoint = Math.floor(beginning + (end - beginning) / 2);\n            var event_1 = this._timeline[midPoint];\n            var nextEvent = this._timeline[midPoint + 1];\n            if (EQ(event_1[param], time)) {\n                // choose the last one that has the same time\n                for (var i = midPoint; i < this._timeline.length; i++) {\n                    var testEvent = this._timeline[i];\n                    if (EQ(testEvent[param], time)) {\n                        midPoint = i;\n                    }\n                }\n                return midPoint;\n            }\n            else if (LT(event_1[param], time) && GT(nextEvent[param], time)) {\n                return midPoint;\n            }\n            else if (GT(event_1[param], time)) {\n                // search lower\n                end = midPoint;\n            }\n            else {\n                // search upper\n                beginning = midPoint + 1;\n            }\n        }\n        return -1;\n    };\n    /**\n     * Internal iterator. Applies extra safety checks for\n     * removing items from the array.\n     */\n    Timeline.prototype._iterate = function (callback, lowerBound, upperBound) {\n        if (lowerBound === void 0) { lowerBound = 0; }\n        if (upperBound === void 0) { upperBound = this._timeline.length - 1; }\n        this._timeline.slice(lowerBound, upperBound + 1).forEach(callback);\n    };\n    /**\n     * Iterate over everything in the array\n     * @param  callback The callback to invoke with every item\n     */\n    Timeline.prototype.forEach = function (callback) {\n        this._iterate(callback);\n        return this;\n    };\n    /**\n     * Iterate over everything in the array at or before the given time.\n     * @param  time The time to check if items are before\n     * @param  callback The callback to invoke with every item\n     */\n    Timeline.prototype.forEachBefore = function (time, callback) {\n        // iterate over the items in reverse so that removing an item doesn't break things\n        var upperBound = this._search(time);\n        if (upperBound !== -1) {\n            this._iterate(callback, 0, upperBound);\n        }\n        return this;\n    };\n    /**\n     * Iterate over everything in the array after the given time.\n     * @param  time The time to check if items are before\n     * @param  callback The callback to invoke with every item\n     */\n    Timeline.prototype.forEachAfter = function (time, callback) {\n        // iterate over the items in reverse so that removing an item doesn't break things\n        var lowerBound = this._search(time);\n        this._iterate(callback, lowerBound + 1);\n        return this;\n    };\n    /**\n     * Iterate over everything in the array between the startTime and endTime.\n     * The timerange is inclusive of the startTime, but exclusive of the endTime.\n     * range = [startTime, endTime).\n     * @param  startTime The time to check if items are before\n     * @param  endTime The end of the test interval.\n     * @param  callback The callback to invoke with every item\n     */\n    Timeline.prototype.forEachBetween = function (startTime, endTime, callback) {\n        var lowerBound = this._search(startTime);\n        var upperBound = this._search(endTime);\n        if (lowerBound !== -1 && upperBound !== -1) {\n            if (this._timeline[lowerBound].time !== startTime) {\n                lowerBound += 1;\n            }\n            // exclusive of the end time\n            if (this._timeline[upperBound].time === endTime) {\n                upperBound -= 1;\n            }\n            this._iterate(callback, lowerBound, upperBound);\n        }\n        else if (lowerBound === -1) {\n            this._iterate(callback, 0, upperBound);\n        }\n        return this;\n    };\n    /**\n     * Iterate over everything in the array at or after the given time. Similar to\n     * forEachAfter, but includes the item(s) at the given time.\n     * @param  time The time to check if items are before\n     * @param  callback The callback to invoke with every item\n     */\n    Timeline.prototype.forEachFrom = function (time, callback) {\n        // iterate over the items in reverse so that removing an item doesn't break things\n        var lowerBound = this._search(time);\n        // work backwards until the event time is less than time\n        while (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {\n            lowerBound--;\n        }\n        this._iterate(callback, lowerBound + 1);\n        return this;\n    };\n    /**\n     * Iterate over everything in the array at the given time\n     * @param  time The time to check if items are before\n     * @param  callback The callback to invoke with every item\n     */\n    Timeline.prototype.forEachAtTime = function (time, callback) {\n        // iterate over the items in reverse so that removing an item doesn't break things\n        var upperBound = this._search(time);\n        if (upperBound !== -1) {\n            this._iterate(function (event) {\n                if (event.time === time) {\n                    callback(event);\n                }\n            }, 0, upperBound);\n        }\n        return this;\n    };\n    /**\n     * Clean up.\n     */\n    Timeline.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this._timeline = [];\n        return this;\n    };\n    return Timeline;\n}(Tone));\nexport { Timeline };\n//# sourceMappingURL=Timeline.js.map"]},"metadata":{},"sourceType":"module"}