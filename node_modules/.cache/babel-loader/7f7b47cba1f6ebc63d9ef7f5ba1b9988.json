{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { Instrument } from \"../instrument/Instrument\";\nimport { timeRange } from \"../core/util/Decorator\";\n/**\n * Abstract base class for other monophonic instruments to extend.\n */\n\nvar Monophonic =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Monophonic, _super);\n\n  function Monophonic() {\n    var _this = _super.call(this, optionsFromArguments(Monophonic.getDefaults(), arguments)) || this;\n\n    var options = optionsFromArguments(Monophonic.getDefaults(), arguments);\n    _this.portamento = options.portamento;\n    _this.onsilence = options.onsilence;\n    return _this;\n  }\n\n  Monophonic.getDefaults = function () {\n    return Object.assign(Instrument.getDefaults(), {\n      detune: 0,\n      onsilence: noOp,\n      portamento: 0\n    });\n  };\n  /**\n   * Trigger the attack of the note optionally with a given velocity.\n   * @param  note The note to trigger.\n   * @param  time When the note should start.\n   * @param  velocity The velocity scaler determines how \"loud\" the note will be triggered.\n   * @example\n   * import { Synth } from \"tone\";\n   * const synth = new Synth().toDestination();\n   * // trigger the note a half second from now at half velocity\n   * synth.triggerAttack(\"C4\", \"+0.5\", 0.5);\n   */\n\n\n  Monophonic.prototype.triggerAttack = function (note, time, velocity) {\n    if (velocity === void 0) {\n      velocity = 1;\n    }\n\n    this.log(\"triggerAttack\", note, time, velocity);\n    var seconds = this.toSeconds(time);\n\n    this._triggerEnvelopeAttack(seconds, velocity);\n\n    this.setNote(note, seconds);\n    return this;\n  };\n  /**\n   * Trigger the release portion of the envelope\n   * @param  time If no time is given, the release happens immediatly\n   * @example\n   * import { Synth } from \"tone\";\n   * const synth = new Synth().toDestination();\n   * synth.triggerAttack(\"C4\");\n   * // trigger the release a second from now\n   * synth.triggerRelease(\"+1\");\n   */\n\n\n  Monophonic.prototype.triggerRelease = function (time) {\n    this.log(\"triggerRelease\", time);\n    var seconds = this.toSeconds(time);\n\n    this._triggerEnvelopeRelease(seconds);\n\n    return this;\n  };\n  /**\n   * Set the note at the given time. If no time is given, the note\n   * will set immediately.\n   * @param note The note to change to.\n   * @param  time The time when the note should be set.\n   * @example\n   * import { Synth } from \"tone\";\n   * const synth = new Synth().toDestination();\n   * synth.triggerAttack(\"C4\");\n   * // change to F#6 in one quarter note from now.\n   * synth.setNote(\"F#6\", \"+4n\");\n   */\n\n\n  Monophonic.prototype.setNote = function (note, time) {\n    var computedTime = this.toSeconds(time);\n    var computedFrequency = note instanceof FrequencyClass ? note.toFrequency() : note;\n\n    if (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {\n      var portTime = this.toSeconds(this.portamento);\n      this.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);\n    } else {\n      this.frequency.setValueAtTime(computedFrequency, computedTime);\n    }\n\n    return this;\n  };\n\n  tslib_1.__decorate([timeRange(0)], Monophonic.prototype, \"portamento\", void 0);\n\n  return Monophonic;\n}(Instrument);\n\nexport { Monophonic };","map":{"version":3,"sources":["../../../Tone/instrument/Monophonic.ts"],"names":[],"mappings":";AAAA,SAAS,cAAT,QAA+B,wBAA/B;AAEA,SAAS,oBAAT,QAAqC,uBAArC;AACA,SAAS,IAAT,QAAqB,wBAArB;AACA,SAAS,UAAT,QAA8C,0BAA9C;AAEA,SAAS,SAAT,QAA0B,wBAA1B;AAUA;;;;AAGA,IAAA,UAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAA4E,EAAA,OAAA,CAAA,SAAA,CAAA,UAAA,EAAA,MAAA;;AAwB3E,WAAA,UAAA,GAAA;AAAA,QAAA,KAAA,GAEC,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,oBAAoB,CAAC,UAAU,CAAC,WAAX,EAAD,EAA2B,SAA3B,CAA1B,KAAgE,IAFjE;;AAGC,QAAM,OAAO,GAAG,oBAAoB,CAAC,UAAU,CAAC,WAAX,EAAD,EAA2B,SAA3B,CAApC;AAEA,IAAA,KAAI,CAAC,UAAL,GAAkB,OAAO,CAAC,UAA1B;AACA,IAAA,KAAI,CAAC,SAAL,GAAiB,OAAO,CAAC,SAAzB;;AACA;;AAEM,EAAA,UAAA,CAAA,WAAA,GAAP,YAAA;AACC,WAAO,MAAM,CAAC,MAAP,CAAc,UAAU,CAAC,WAAX,EAAd,EAAwC;AAC9C,MAAA,MAAM,EAAE,CADsC;AAE9C,MAAA,SAAS,EAAE,IAFmC;AAG9C,MAAA,UAAU,EAAE;AAHkC,KAAxC,CAAP;AAKA,GANM;AAQP;;;;;;;;;;;;;AAWA,EAAA,UAAA,CAAA,SAAA,CAAA,aAAA,GAAA,UAAc,IAAd,EAAgD,IAAhD,EAA6D,QAA7D,EAAsF;AAAzB,QAAA,QAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,QAAA,GAAA,CAAA;AAAyB;;AACrF,SAAK,GAAL,CAAS,eAAT,EAA0B,IAA1B,EAAgC,IAAhC,EAAsC,QAAtC;AACA,QAAM,OAAO,GAAG,KAAK,SAAL,CAAe,IAAf,CAAhB;;AACA,SAAK,sBAAL,CAA4B,OAA5B,EAAqC,QAArC;;AACA,SAAK,OAAL,CAAa,IAAb,EAAmB,OAAnB;AACA,WAAO,IAAP;AACA,GAND;AAQA;;;;;;;;;;;;AAUA,EAAA,UAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,IAAf,EAA0B;AACzB,SAAK,GAAL,CAAS,gBAAT,EAA2B,IAA3B;AACA,QAAM,OAAO,GAAG,KAAK,SAAL,CAAe,IAAf,CAAhB;;AACA,SAAK,uBAAL,CAA6B,OAA7B;;AACA,WAAO,IAAP;AACA,GALD;AAyBA;;;;;;;;;;;;;;AAYA,EAAA,UAAA,CAAA,SAAA,CAAA,OAAA,GAAA,UAAQ,IAAR,EAA0C,IAA1C,EAAqD;AACpD,QAAM,YAAY,GAAG,KAAK,SAAL,CAAe,IAAf,CAArB;AACA,QAAM,iBAAiB,GAAG,IAAI,YAAY,cAAhB,GAAiC,IAAI,CAAC,WAAL,EAAjC,GAAsD,IAAhF;;AACA,QAAI,KAAK,UAAL,GAAkB,CAAlB,IAAuB,KAAK,cAAL,CAAoB,YAApB,IAAoC,IAA/D,EAAqE;AACpE,UAAM,QAAQ,GAAG,KAAK,SAAL,CAAe,KAAK,UAApB,CAAjB;AACA,WAAK,SAAL,CAAe,iBAAf,CAAiC,iBAAjC,EAAoD,QAApD,EAA8D,YAA9D;AACA,KAHD,MAGO;AACN,WAAK,SAAL,CAAe,cAAf,CAA8B,iBAA9B,EAAiD,YAAjD;AACA;;AACD,WAAO,IAAP;AACA,GAVD;;AArGA,EAAA,OAAA,CAAA,UAAA,CAAA,CADC,SAAS,CAAC,CAAD,CACV,CAAA,E,oBAAA,E,YAAA,E,KAAoB,CAApB;;AAgHD,SAAA,UAAA;AAAC,CAtHD,CAA4E,UAA5E,CAAA;;SAAsB,U","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { Instrument } from \"../instrument/Instrument\";\nimport { timeRange } from \"../core/util/Decorator\";\n/**\n * Abstract base class for other monophonic instruments to extend.\n */\nvar Monophonic = /** @class */ (function (_super) {\n    tslib_1.__extends(Monophonic, _super);\n    function Monophonic() {\n        var _this = _super.call(this, optionsFromArguments(Monophonic.getDefaults(), arguments)) || this;\n        var options = optionsFromArguments(Monophonic.getDefaults(), arguments);\n        _this.portamento = options.portamento;\n        _this.onsilence = options.onsilence;\n        return _this;\n    }\n    Monophonic.getDefaults = function () {\n        return Object.assign(Instrument.getDefaults(), {\n            detune: 0,\n            onsilence: noOp,\n            portamento: 0,\n        });\n    };\n    /**\n     * Trigger the attack of the note optionally with a given velocity.\n     * @param  note The note to trigger.\n     * @param  time When the note should start.\n     * @param  velocity The velocity scaler determines how \"loud\" the note will be triggered.\n     * @example\n     * import { Synth } from \"tone\";\n     * const synth = new Synth().toDestination();\n     * // trigger the note a half second from now at half velocity\n     * synth.triggerAttack(\"C4\", \"+0.5\", 0.5);\n     */\n    Monophonic.prototype.triggerAttack = function (note, time, velocity) {\n        if (velocity === void 0) { velocity = 1; }\n        this.log(\"triggerAttack\", note, time, velocity);\n        var seconds = this.toSeconds(time);\n        this._triggerEnvelopeAttack(seconds, velocity);\n        this.setNote(note, seconds);\n        return this;\n    };\n    /**\n     * Trigger the release portion of the envelope\n     * @param  time If no time is given, the release happens immediatly\n     * @example\n     * import { Synth } from \"tone\";\n     * const synth = new Synth().toDestination();\n     * synth.triggerAttack(\"C4\");\n     * // trigger the release a second from now\n     * synth.triggerRelease(\"+1\");\n     */\n    Monophonic.prototype.triggerRelease = function (time) {\n        this.log(\"triggerRelease\", time);\n        var seconds = this.toSeconds(time);\n        this._triggerEnvelopeRelease(seconds);\n        return this;\n    };\n    /**\n     * Set the note at the given time. If no time is given, the note\n     * will set immediately.\n     * @param note The note to change to.\n     * @param  time The time when the note should be set.\n     * @example\n     * import { Synth } from \"tone\";\n     * const synth = new Synth().toDestination();\n     * synth.triggerAttack(\"C4\");\n     * // change to F#6 in one quarter note from now.\n     * synth.setNote(\"F#6\", \"+4n\");\n     */\n    Monophonic.prototype.setNote = function (note, time) {\n        var computedTime = this.toSeconds(time);\n        var computedFrequency = note instanceof FrequencyClass ? note.toFrequency() : note;\n        if (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {\n            var portTime = this.toSeconds(this.portamento);\n            this.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);\n        }\n        else {\n            this.frequency.setValueAtTime(computedFrequency, computedTime);\n        }\n        return this;\n    };\n    tslib_1.__decorate([\n        timeRange(0)\n    ], Monophonic.prototype, \"portamento\", void 0);\n    return Monophonic;\n}(Instrument));\nexport { Monophonic };\n//# sourceMappingURL=Monophonic.js.map"]},"metadata":{},"sourceType":"module"}