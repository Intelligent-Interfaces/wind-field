{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { dbToGain } from \"../../core/type/Conversions\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MeterBase } from \"./MeterBase\";\n/**\n * Get the current frequency data of the connected audio source using a fast Fourier transform.\n * @category Component\n */\n\nvar FFT =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(FFT, _super);\n\n  function FFT() {\n    var _this = _super.call(this, optionsFromArguments(FFT.getDefaults(), arguments, [\"size\"])) || this;\n\n    _this.name = \"FFT\";\n    var options = optionsFromArguments(FFT.getDefaults(), arguments, [\"size\"]);\n    _this.normalRange = options.normalRange;\n    _this._analyser.type = \"fft\";\n    _this.size = options.size;\n    return _this;\n  }\n\n  FFT.getDefaults = function () {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      normalRange: false,\n      size: 1024,\n      smoothing: 0.8\n    });\n  };\n  /**\n   * Gets the current frequency data from the connected audio source.\n   * Returns the frequency data of length [[size]] as a Float32Array of decibel values.\n   */\n\n\n  FFT.prototype.getValue = function () {\n    var _this = this;\n\n    var values = this._analyser.getValue();\n\n    return values.map(function (v) {\n      return _this.normalRange ? dbToGain(v) : v;\n    });\n  };\n\n  Object.defineProperty(FFT.prototype, \"size\", {\n    /**\n     * The size of analysis. This must be a power of two in the range 16 to 16384.\n     * Determines the size of the array returned by [[getValue]] (i.e. the number of\n     * frequency bins). Large FFT sizes may be costly to compute.\n     */\n    get: function () {\n      return this._analyser.size;\n    },\n    set: function (size) {\n      this._analyser.size = size;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FFT.prototype, \"smoothing\", {\n    /**\n     * 0 represents no time averaging with the last analysis frame.\n     */\n    get: function () {\n      return this._analyser.smoothing;\n    },\n    set: function (val) {\n      this._analyser.smoothing = val;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return FFT;\n}(MeterBase);\n\nexport { FFT };","map":{"version":3,"sources":["../../../../Tone/component/analysis/FFT.ts"],"names":[],"mappings":";AAAA,SAAS,aAAT,QAA8B,kCAA9B;AACA,SAAS,QAAT,QAAyB,6BAAzB;AAEA,SAAS,oBAAT,QAAqC,0BAArC;AACA,SAAS,SAAT,QAA4C,aAA5C;AAQA;;;;;AAIA,IAAA,GAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAyB,EAAA,OAAA,CAAA,SAAA,CAAA,GAAA,EAAA,MAAA;;AAgBxB,WAAA,GAAA,GAAA;AAAA,QAAA,KAAA,GACC,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,oBAAoB,CAAC,GAAG,CAAC,WAAJ,EAAD,EAAoB,SAApB,EAA+B,CAAC,MAAD,CAA/B,CAA1B,KAAmE,IADpE;;AAdS,IAAA,KAAA,CAAA,IAAA,GAAe,KAAf;AAgBR,QAAM,OAAO,GAAG,oBAAoB,CAAC,GAAG,CAAC,WAAJ,EAAD,EAAoB,SAApB,EAA+B,CAAC,MAAD,CAA/B,CAApC;AAEA,IAAA,KAAI,CAAC,WAAL,GAAmB,OAAO,CAAC,WAA3B;AACA,IAAA,KAAI,CAAC,SAAL,CAAe,IAAf,GAAsB,KAAtB;AACA,IAAA,KAAI,CAAC,IAAL,GAAY,OAAO,CAAC,IAApB;;AACA;;AAEM,EAAA,GAAA,CAAA,WAAA,GAAP,YAAA;AACC,WAAO,MAAM,CAAC,MAAP,CAAc,aAAa,CAAC,WAAd,EAAd,EAA2C;AACjD,MAAA,WAAW,EAAE,KADoC;AAEjD,MAAA,IAAI,EAAE,IAF2C;AAGjD,MAAA,SAAS,EAAE;AAHsC,KAA3C,CAAP;AAKA,GANM;AAQP;;;;;;AAIA,EAAA,GAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA;AAAA,QAAA,KAAA,GAAA,IAAA;;AACC,QAAM,MAAM,GAAG,KAAK,SAAL,CAAe,QAAf,EAAf;;AACA,WAAO,MAAM,CAAC,GAAP,CAAW,UAAA,CAAA,EAAC;AAAI,aAAA,KAAI,CAAC,WAAL,GAAmB,QAAQ,CAAC,CAAD,CAA3B,GAAA,CAAA;AAAkC,KAAlD,CAAP;AACA,GAHD;;AAUA,EAAA,MAAA,CAAA,cAAA,CAAI,GAAA,CAAA,SAAJ,EAAI,MAAJ,EAAQ;AALR;;;;;SAKA,YAAA;AACC,aAAO,KAAK,SAAL,CAAe,IAAtB;AACA,KAFO;SAGR,UAAS,IAAT,EAAa;AACZ,WAAK,SAAL,CAAe,IAAf,GAAsB,IAAtB;AACA,KALO;oBAAA;;AAAA,GAAR;AAUA,EAAA,MAAA,CAAA,cAAA,CAAI,GAAA,CAAA,SAAJ,EAAI,WAAJ,EAAa;AAHb;;;SAGA,YAAA;AACC,aAAO,KAAK,SAAL,CAAe,SAAtB;AACA,KAFY;SAGb,UAAc,GAAd,EAAiB;AAChB,WAAK,SAAL,CAAe,SAAf,GAA2B,GAA3B;AACA,KALY;oBAAA;;AAAA,GAAb;AAMD,SAAA,GAAA;AAAC,CA/DD,CAAyB,SAAzB,CAAA","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { dbToGain } from \"../../core/type/Conversions\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MeterBase } from \"./MeterBase\";\n/**\n * Get the current frequency data of the connected audio source using a fast Fourier transform.\n * @category Component\n */\nvar FFT = /** @class */ (function (_super) {\n    tslib_1.__extends(FFT, _super);\n    function FFT() {\n        var _this = _super.call(this, optionsFromArguments(FFT.getDefaults(), arguments, [\"size\"])) || this;\n        _this.name = \"FFT\";\n        var options = optionsFromArguments(FFT.getDefaults(), arguments, [\"size\"]);\n        _this.normalRange = options.normalRange;\n        _this._analyser.type = \"fft\";\n        _this.size = options.size;\n        return _this;\n    }\n    FFT.getDefaults = function () {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            normalRange: false,\n            size: 1024,\n            smoothing: 0.8,\n        });\n    };\n    /**\n     * Gets the current frequency data from the connected audio source.\n     * Returns the frequency data of length [[size]] as a Float32Array of decibel values.\n     */\n    FFT.prototype.getValue = function () {\n        var _this = this;\n        var values = this._analyser.getValue();\n        return values.map(function (v) { return _this.normalRange ? dbToGain(v) : v; });\n    };\n    Object.defineProperty(FFT.prototype, \"size\", {\n        /**\n         * The size of analysis. This must be a power of two in the range 16 to 16384.\n         * Determines the size of the array returned by [[getValue]] (i.e. the number of\n         * frequency bins). Large FFT sizes may be costly to compute.\n         */\n        get: function () {\n            return this._analyser.size;\n        },\n        set: function (size) {\n            this._analyser.size = size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FFT.prototype, \"smoothing\", {\n        /**\n         * 0 represents no time averaging with the last analysis frame.\n         */\n        get: function () {\n            return this._analyser.smoothing;\n        },\n        set: function (val) {\n            this._analyser.smoothing = val;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return FFT;\n}(MeterBase));\nexport { FFT };\n//# sourceMappingURL=FFT.js.map"]},"metadata":{},"sourceType":"module"}