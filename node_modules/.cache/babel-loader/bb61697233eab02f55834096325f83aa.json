{"ast":null,"code":"import _slicedToArray from \"/Users/erickoduniyi/Desktop/Work/multi_media_signal_processing/skeuomorphic-synth-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/*! Source code licensed under Apache License 2.0. Copyright © 2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { Pt, Group, Bound } from \"./Pt\";\nimport { Polygon, Circle } from \"./Op\";\nexport class World {\n  constructor(bound, friction = 1, gravity = 0) {\n    this._lastTime = null;\n    this._gravity = new Pt();\n    this._friction = 1;\n    this._damping = 0.75;\n    this._particles = [];\n    this._bodies = [];\n    this._pnames = [];\n    this._bnames = [];\n    this._bound = Bound.fromGroup(bound);\n    this._friction = friction;\n    this._gravity = typeof gravity === \"number\" ? new Pt(0, gravity) : new Pt(gravity);\n    return this;\n  }\n\n  get bound() {\n    return this._bound;\n  }\n\n  set bound(bound) {\n    this._bound = bound;\n  }\n\n  get gravity() {\n    return this._gravity;\n  }\n\n  set gravity(g) {\n    this._gravity = g;\n  }\n\n  get friction() {\n    return this._friction;\n  }\n\n  set friction(f) {\n    this._friction = f;\n  }\n\n  get damping() {\n    return this._damping;\n  }\n\n  set damping(f) {\n    this._damping = f;\n  }\n\n  get bodyCount() {\n    return this._bodies.length;\n  }\n\n  get particleCount() {\n    return this._particles.length;\n  }\n\n  body(id) {\n    let idx = id;\n\n    if (typeof id === \"string\" && id.length > 0) {\n      idx = this._bnames.indexOf(id);\n    }\n\n    if (!(idx >= 0)) return undefined;\n    return this._bodies[idx];\n  }\n\n  particle(id) {\n    let idx = id;\n\n    if (typeof id === \"string\" && id.length > 0) {\n      idx = this._pnames.indexOf(id);\n    }\n\n    if (!(idx >= 0)) return undefined;\n    return this._particles[idx];\n  }\n\n  bodyIndex(name) {\n    return this._bnames.indexOf(name);\n  }\n\n  particleIndex(name) {\n    return this._pnames.indexOf(name);\n  }\n\n  update(ms) {\n    let dt = ms / 1000;\n\n    this._updateParticles(dt);\n\n    this._updateBodies(dt);\n  }\n\n  drawParticles(fn) {\n    this._drawParticles = fn;\n  }\n\n  drawBodies(fn) {\n    this._drawBodies = fn;\n  }\n\n  add(p, name = '') {\n    if (p instanceof Body) {\n      this._bodies.push(p);\n\n      this._bnames.push(name);\n    } else {\n      this._particles.push(p);\n\n      this._pnames.push(name);\n    }\n\n    return this;\n  }\n\n  _index(fn, id) {\n    let index = 0;\n\n    if (typeof id === \"string\") {\n      index = fn(id);\n      if (index < 0) throw new Error(`Cannot find index of ${id}. You can use particleIndex() or bodyIndex() function to check existence by name.`);\n    } else {\n      index = id;\n    }\n\n    return index;\n  }\n\n  removeBody(from, count = 1) {\n    const index = this._index(this.bodyIndex.bind(this), from);\n\n    const param = index < 0 ? [index * -1 - 1, count] : [index, count];\n\n    this._bodies.splice(param[0], param[1]);\n\n    this._bnames.splice(param[0], param[1]);\n\n    return this;\n  }\n\n  removeParticle(from, count = 1) {\n    const index = this._index(this.particleIndex.bind(this), from);\n\n    const param = index < 0 ? [index * -1 - 1, count] : [index, count];\n\n    this._particles.splice(param[0], param[1]);\n\n    this._pnames.splice(param[0], param[1]);\n\n    return this;\n  }\n\n  static edgeConstraint(p1, p2, dist, stiff = 1, precise = false) {\n    const m1 = 1 / (p1.mass || 1);\n    const m2 = 1 / (p2.mass || 1);\n    const mm = m1 + m2;\n    let delta = p2.$subtract(p1);\n    let distSq = dist * dist;\n    let d = precise ? dist / delta.magnitude() - 1 : distSq / (delta.dot(delta) + distSq) - 0.5;\n    let f = delta.$multiply(d * stiff);\n    p1.subtract(f.$multiply(m1 / mm));\n    p2.add(f.$multiply(m2 / mm));\n    return p1;\n  }\n\n  static boundConstraint(p, rect, damping = 0.75) {\n    let bound = rect.boundingBox();\n    let np = p.$min(bound[1].subtract(p.radius)).$max(bound[0].add(p.radius));\n\n    if (np[0] === bound[0][0] || np[0] === bound[1][0]) {\n      let c = p.changed.$multiply(damping);\n      p.previous = np.$subtract(new Pt(-c[0], c[1]));\n    } else if (np[1] === bound[0][1] || np[1] === bound[1][1]) {\n      let c = p.changed.$multiply(damping);\n      p.previous = np.$subtract(new Pt(c[0], -c[1]));\n    }\n\n    p.to(np);\n  }\n\n  integrate(p, dt, prevDt) {\n    p.addForce(this._gravity);\n    p.verlet(dt, this._friction, prevDt);\n    return p;\n  }\n\n  _updateParticles(dt) {\n    for (let i = 0, len = this._particles.length; i < len; i++) {\n      let p = this._particles[i];\n      this.integrate(p, dt, this._lastTime);\n      World.boundConstraint(p, this._bound, this._damping);\n\n      for (let k = i + 1; k < len; k++) {\n        if (i !== k) {\n          let p2 = this._particles[k];\n          p.collide(p2, this._damping);\n        }\n      }\n\n      if (this._drawParticles) this._drawParticles(p, i);\n    }\n\n    this._lastTime = dt;\n  }\n\n  _updateBodies(dt) {\n    for (let i = 0, len = this._bodies.length; i < len; i++) {\n      let bds = this._bodies[i];\n\n      if (bds) {\n        for (let k = 0, klen = bds.length; k < klen; k++) {\n          let bk = bds[k];\n          World.boundConstraint(bk, this._bound, this._damping);\n          this.integrate(bk, dt, this._lastTime);\n        }\n\n        for (let k = i + 1; k < len; k++) {\n          bds.processBody(this._bodies[k]);\n        }\n\n        for (let m = 0, mlen = this._particles.length; m < mlen; m++) {\n          bds.processParticle(this._particles[m]);\n        }\n\n        bds.processEdges();\n        if (this._drawBodies) this._drawBodies(bds, i);\n      }\n    }\n  }\n\n}\nexport class Particle extends Pt {\n  constructor(...args) {\n    super(...args);\n    this._mass = 1;\n    this._radius = 0;\n    this._force = new Pt();\n    this._prev = new Pt();\n    this._lock = false;\n    this._prev = this.clone();\n  }\n\n  get mass() {\n    return this._mass;\n  }\n\n  set mass(m) {\n    this._mass = m;\n  }\n\n  get radius() {\n    return this._radius;\n  }\n\n  set radius(f) {\n    this._radius = f;\n  }\n\n  get previous() {\n    return this._prev;\n  }\n\n  set previous(p) {\n    this._prev = p;\n  }\n\n  get force() {\n    return this._force;\n  }\n\n  set force(g) {\n    this._force = g;\n  }\n\n  get body() {\n    return this._body;\n  }\n\n  set body(b) {\n    this._body = b;\n  }\n\n  get lock() {\n    return this._lock;\n  }\n\n  set lock(b) {\n    this._lock = b;\n    this._lockPt = new Pt(this);\n  }\n\n  get changed() {\n    return this.$subtract(this._prev);\n  }\n\n  set position(p) {\n    this.previous.to(this);\n    if (this._lock) this._lockPt = p;\n    this.to(p);\n  }\n\n  size(r) {\n    this._mass = r;\n    this._radius = r;\n    return this;\n  }\n\n  addForce(...args) {\n    this._force.add(...args);\n\n    return this._force;\n  }\n\n  verlet(dt, friction, lastDt) {\n    if (this._lock) {\n      this.to(this._lockPt);\n    } else {\n      let lt = lastDt ? lastDt : dt;\n\n      let a = this._force.multiply(dt * (dt + lt) / 2);\n\n      let v = this.changed.multiply(friction * dt / lt).add(a);\n      this._prev = this.clone();\n      this.add(v);\n      this._force = new Pt();\n    }\n\n    return this;\n  }\n\n  hit(...args) {\n    this._prev.subtract(new Pt(...args).$divide(Math.sqrt(this._mass)));\n\n    return this;\n  }\n\n  collide(p2, damp = 1) {\n    let p1 = this;\n    let dp = p1.$subtract(p2);\n    let distSq = dp.magnitudeSq();\n    let dr = p1.radius + p2.radius;\n\n    if (distSq < dr * dr) {\n      let c1 = p1.changed;\n      let c2 = p2.changed;\n      let dist = Math.sqrt(distSq);\n      let d = dp.$multiply((dist - dr) / dist / 2);\n      let np1 = p1.$subtract(d);\n      let np2 = p2.$add(d);\n      p1.to(np1);\n      p2.to(np2);\n      let f1 = damp * dp.dot(c1) / distSq;\n      let f2 = damp * dp.dot(c2) / distSq;\n      let dm1 = p1.mass / (p1.mass + p2.mass);\n      let dm2 = p2.mass / (p1.mass + p2.mass);\n      c1.add(new Pt(f2 * dp[0] - f1 * dp[0], f2 * dp[1] - f1 * dp[1]).$multiply(dm2));\n      c2.add(new Pt(f1 * dp[0] - f2 * dp[0], f1 * dp[1] - f2 * dp[1]).$multiply(dm1));\n      p1.previous = p1.$subtract(c1);\n      p2.previous = p2.$subtract(c2);\n    }\n  }\n\n  toString() {\n    return `Particle: ${this[0]} ${this[1]} | previous ${this._prev[0]} ${this._prev[1]} | mass ${this._mass}`;\n  }\n\n}\nexport class Body extends Group {\n  constructor() {\n    super();\n    this._cs = [];\n    this._stiff = 1;\n    this._locks = {};\n    this._mass = 1;\n  }\n\n  static fromGroup(list, stiff = 1, autoLink = true, autoMass = true) {\n    let b = new Body().init(list);\n    if (autoLink) b.linkAll(stiff);\n    if (autoMass) b.autoMass();\n    return b;\n  }\n\n  init(list, stiff = 1) {\n    let c = new Pt();\n\n    for (let i = 0, len = list.length; i < len; i++) {\n      let p = new Particle(list[i]);\n      p.body = this;\n      c.add(list[i]);\n      this.push(p);\n    }\n\n    this._stiff = stiff;\n    return this;\n  }\n\n  get mass() {\n    return this._mass;\n  }\n\n  set mass(m) {\n    this._mass = m;\n\n    for (let i = 0, len = this.length; i < len; i++) {\n      this[i].mass = this._mass;\n    }\n  }\n\n  autoMass() {\n    this.mass = Math.sqrt(Polygon.area(this)) / 10;\n    return this;\n  }\n\n  link(index1, index2, stiff) {\n    if (index1 < 0 || index1 >= this.length) throw new Error(\"index1 is not in the Group's indices\");\n    if (index2 < 0 || index2 >= this.length) throw new Error(\"index1 is not in the Group's indices\");\n    let d = this[index1].$subtract(this[index2]).magnitude();\n\n    this._cs.push([index1, index2, d, stiff || this._stiff]);\n\n    return this;\n  }\n\n  linkAll(stiff) {\n    let half = this.length / 2;\n\n    for (let i = 0, len = this.length; i < len; i++) {\n      let n = i >= len - 1 ? 0 : i + 1;\n      this.link(i, n, stiff);\n\n      if (len > 4) {\n        let nd = Math.floor(half / 2) + 1;\n        let n2 = i >= len - nd ? i % len : i + nd;\n        this.link(i, n2, stiff);\n      }\n\n      if (i <= half - 1) {\n        this.link(i, Math.min(this.length - 1, i + Math.floor(half)));\n      }\n    }\n  }\n\n  linksToLines() {\n    let gs = [];\n\n    for (let i = 0, len = this._cs.length; i < len; i++) {\n      let ln = this._cs[i];\n      gs.push(new Group(this[ln[0]], this[ln[1]]));\n    }\n\n    return gs;\n  }\n\n  processEdges() {\n    for (let i = 0, len = this._cs.length; i < len; i++) {\n      let _this$_cs$i = _slicedToArray(this._cs[i], 4),\n          m = _this$_cs$i[0],\n          n = _this$_cs$i[1],\n          d = _this$_cs$i[2],\n          s = _this$_cs$i[3];\n\n      World.edgeConstraint(this[m], this[n], d, s);\n    }\n  }\n\n  processBody(b) {\n    let b1 = this;\n    let b2 = b;\n    let hit = Polygon.hasIntersectPolygon(b1, b2);\n\n    if (hit) {\n      let cv = hit.normal.$multiply(hit.dist);\n      let t;\n      let eg = hit.edge;\n\n      if (Math.abs(eg[0][0] - eg[1][0]) > Math.abs(eg[0][1] - eg[1][1])) {\n        t = (hit.vertex[0] - cv[0] - eg[0][0]) / (eg[1][0] - eg[0][0]);\n      } else {\n        t = (hit.vertex[1] - cv[1] - eg[0][1]) / (eg[1][1] - eg[0][1]);\n      }\n\n      let lambda = 1 / (t * t + (1 - t) * (1 - t));\n      let m0 = hit.vertex.body.mass || 1;\n      let m1 = hit.edge[0].body.mass || 1;\n      let mr0 = m0 / (m0 + m1);\n      let mr1 = m1 / (m0 + m1);\n      eg[0].subtract(cv.$multiply(mr0 * (1 - t) * lambda / 2));\n      eg[1].subtract(cv.$multiply(mr0 * t * lambda / 2));\n      hit.vertex.add(cv.$multiply(mr1));\n    }\n  }\n\n  processParticle(b) {\n    let b1 = this;\n    let b2 = b;\n    let hit = Polygon.hasIntersectCircle(b1, Circle.fromCenter(b, b.radius));\n\n    if (hit) {\n      let cv = hit.normal.$multiply(hit.dist);\n      let t;\n      let eg = hit.edge;\n\n      if (Math.abs(eg[0][0] - eg[1][0]) > Math.abs(eg[0][1] - eg[1][1])) {\n        t = (hit.vertex[0] - cv[0] - eg[0][0]) / (eg[1][0] - eg[0][0]);\n      } else {\n        t = (hit.vertex[1] - cv[1] - eg[0][1]) / (eg[1][1] - eg[0][1]);\n      }\n\n      let lambda = 1 / (t * t + (1 - t) * (1 - t));\n      let m0 = hit.vertex.mass || b2.mass || 1;\n      let m1 = hit.edge[0].body.mass || 1;\n      let mr0 = m0 / (m0 + m1);\n      let mr1 = m1 / (m0 + m1);\n      eg[0].subtract(cv.$multiply(mr0 * (1 - t) * lambda / 2));\n      eg[1].subtract(cv.$multiply(mr0 * t * lambda / 2));\n      let c1 = b.changed.add(cv.$multiply(mr1));\n      b.previous = b.$subtract(c1);\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/erickoduniyi/Desktop/Work/multi_media_signal_processing/skeuomorphic-synth-master/node_modules/pts/dist/es2015/Physics.js"],"names":["Pt","Group","Bound","Polygon","Circle","World","constructor","bound","friction","gravity","_lastTime","_gravity","_friction","_damping","_particles","_bodies","_pnames","_bnames","_bound","fromGroup","g","f","damping","bodyCount","length","particleCount","body","id","idx","indexOf","undefined","particle","bodyIndex","name","particleIndex","update","ms","dt","_updateParticles","_updateBodies","drawParticles","fn","_drawParticles","drawBodies","_drawBodies","add","p","Body","push","_index","index","Error","removeBody","from","count","bind","param","splice","removeParticle","edgeConstraint","p1","p2","dist","stiff","precise","m1","mass","m2","mm","delta","$subtract","distSq","d","magnitude","dot","$multiply","subtract","boundConstraint","rect","boundingBox","np","$min","radius","$max","c","changed","previous","to","integrate","prevDt","addForce","verlet","i","len","k","collide","bds","klen","bk","processBody","m","mlen","processParticle","processEdges","Particle","args","_mass","_radius","_force","_prev","_lock","clone","force","_body","b","lock","_lockPt","position","size","r","lastDt","lt","a","multiply","v","hit","$divide","Math","sqrt","damp","dp","magnitudeSq","dr","c1","c2","np1","np2","$add","f1","f2","dm1","dm2","toString","_cs","_stiff","_locks","list","autoLink","autoMass","init","linkAll","area","link","index1","index2","half","n","nd","floor","n2","min","linksToLines","gs","ln","s","b1","b2","hasIntersectPolygon","cv","normal","t","eg","edge","abs","vertex","lambda","m0","mr0","mr1","hasIntersectCircle","fromCenter"],"mappings":"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","sourcesContent":["/*! Source code licensed under Apache License 2.0. Copyright © 2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { Pt, Group, Bound } from \"./Pt\";\nimport { Polygon, Circle } from \"./Op\";\nexport class World {\n    constructor(bound, friction = 1, gravity = 0) {\n        this._lastTime = null;\n        this._gravity = new Pt();\n        this._friction = 1;\n        this._damping = 0.75;\n        this._particles = [];\n        this._bodies = [];\n        this._pnames = [];\n        this._bnames = [];\n        this._bound = Bound.fromGroup(bound);\n        this._friction = friction;\n        this._gravity = (typeof gravity === \"number\") ? new Pt(0, gravity) : new Pt(gravity);\n        return this;\n    }\n    get bound() { return this._bound; }\n    set bound(bound) { this._bound = bound; }\n    get gravity() { return this._gravity; }\n    set gravity(g) { this._gravity = g; }\n    get friction() { return this._friction; }\n    set friction(f) { this._friction = f; }\n    get damping() { return this._damping; }\n    set damping(f) { this._damping = f; }\n    get bodyCount() { return this._bodies.length; }\n    get particleCount() { return this._particles.length; }\n    body(id) {\n        let idx = id;\n        if (typeof id === \"string\" && id.length > 0) {\n            idx = this._bnames.indexOf(id);\n        }\n        if (!(idx >= 0))\n            return undefined;\n        return this._bodies[idx];\n    }\n    particle(id) {\n        let idx = id;\n        if (typeof id === \"string\" && id.length > 0) {\n            idx = this._pnames.indexOf(id);\n        }\n        if (!(idx >= 0))\n            return undefined;\n        return this._particles[idx];\n    }\n    bodyIndex(name) {\n        return this._bnames.indexOf(name);\n    }\n    particleIndex(name) {\n        return this._pnames.indexOf(name);\n    }\n    update(ms) {\n        let dt = ms / 1000;\n        this._updateParticles(dt);\n        this._updateBodies(dt);\n    }\n    drawParticles(fn) {\n        this._drawParticles = fn;\n    }\n    drawBodies(fn) {\n        this._drawBodies = fn;\n    }\n    add(p, name = '') {\n        if (p instanceof Body) {\n            this._bodies.push(p);\n            this._bnames.push(name);\n        }\n        else {\n            this._particles.push(p);\n            this._pnames.push(name);\n        }\n        return this;\n    }\n    _index(fn, id) {\n        let index = 0;\n        if (typeof id === \"string\") {\n            index = fn(id);\n            if (index < 0)\n                throw new Error(`Cannot find index of ${id}. You can use particleIndex() or bodyIndex() function to check existence by name.`);\n        }\n        else {\n            index = id;\n        }\n        return index;\n    }\n    removeBody(from, count = 1) {\n        const index = this._index(this.bodyIndex.bind(this), from);\n        const param = (index < 0) ? [index * -1 - 1, count] : [index, count];\n        this._bodies.splice(param[0], param[1]);\n        this._bnames.splice(param[0], param[1]);\n        return this;\n    }\n    removeParticle(from, count = 1) {\n        const index = this._index(this.particleIndex.bind(this), from);\n        const param = (index < 0) ? [index * -1 - 1, count] : [index, count];\n        this._particles.splice(param[0], param[1]);\n        this._pnames.splice(param[0], param[1]);\n        return this;\n    }\n    static edgeConstraint(p1, p2, dist, stiff = 1, precise = false) {\n        const m1 = 1 / (p1.mass || 1);\n        const m2 = 1 / (p2.mass || 1);\n        const mm = m1 + m2;\n        let delta = p2.$subtract(p1);\n        let distSq = dist * dist;\n        let d = (precise) ? (dist / delta.magnitude() - 1) : (distSq / (delta.dot(delta) + distSq) - 0.5);\n        let f = delta.$multiply(d * stiff);\n        p1.subtract(f.$multiply(m1 / mm));\n        p2.add(f.$multiply(m2 / mm));\n        return p1;\n    }\n    static boundConstraint(p, rect, damping = 0.75) {\n        let bound = rect.boundingBox();\n        let np = p.$min(bound[1].subtract(p.radius)).$max(bound[0].add(p.radius));\n        if (np[0] === bound[0][0] || np[0] === bound[1][0]) {\n            let c = p.changed.$multiply(damping);\n            p.previous = np.$subtract(new Pt(-c[0], c[1]));\n        }\n        else if (np[1] === bound[0][1] || np[1] === bound[1][1]) {\n            let c = p.changed.$multiply(damping);\n            p.previous = np.$subtract(new Pt(c[0], -c[1]));\n        }\n        p.to(np);\n    }\n    integrate(p, dt, prevDt) {\n        p.addForce(this._gravity);\n        p.verlet(dt, this._friction, prevDt);\n        return p;\n    }\n    _updateParticles(dt) {\n        for (let i = 0, len = this._particles.length; i < len; i++) {\n            let p = this._particles[i];\n            this.integrate(p, dt, this._lastTime);\n            World.boundConstraint(p, this._bound, this._damping);\n            for (let k = i + 1; k < len; k++) {\n                if (i !== k) {\n                    let p2 = this._particles[k];\n                    p.collide(p2, this._damping);\n                }\n            }\n            if (this._drawParticles)\n                this._drawParticles(p, i);\n        }\n        this._lastTime = dt;\n    }\n    _updateBodies(dt) {\n        for (let i = 0, len = this._bodies.length; i < len; i++) {\n            let bds = this._bodies[i];\n            if (bds) {\n                for (let k = 0, klen = bds.length; k < klen; k++) {\n                    let bk = bds[k];\n                    World.boundConstraint(bk, this._bound, this._damping);\n                    this.integrate(bk, dt, this._lastTime);\n                }\n                for (let k = i + 1; k < len; k++) {\n                    bds.processBody(this._bodies[k]);\n                }\n                for (let m = 0, mlen = this._particles.length; m < mlen; m++) {\n                    bds.processParticle(this._particles[m]);\n                }\n                bds.processEdges();\n                if (this._drawBodies)\n                    this._drawBodies(bds, i);\n            }\n        }\n    }\n}\nexport class Particle extends Pt {\n    constructor(...args) {\n        super(...args);\n        this._mass = 1;\n        this._radius = 0;\n        this._force = new Pt();\n        this._prev = new Pt();\n        this._lock = false;\n        this._prev = this.clone();\n    }\n    get mass() { return this._mass; }\n    set mass(m) { this._mass = m; }\n    get radius() { return this._radius; }\n    set radius(f) { this._radius = f; }\n    get previous() { return this._prev; }\n    set previous(p) { this._prev = p; }\n    get force() { return this._force; }\n    set force(g) { this._force = g; }\n    get body() { return this._body; }\n    set body(b) { this._body = b; }\n    get lock() { return this._lock; }\n    set lock(b) {\n        this._lock = b;\n        this._lockPt = new Pt(this);\n    }\n    get changed() { return this.$subtract(this._prev); }\n    set position(p) {\n        this.previous.to(this);\n        if (this._lock)\n            this._lockPt = p;\n        this.to(p);\n    }\n    size(r) {\n        this._mass = r;\n        this._radius = r;\n        return this;\n    }\n    addForce(...args) {\n        this._force.add(...args);\n        return this._force;\n    }\n    verlet(dt, friction, lastDt) {\n        if (this._lock) {\n            this.to(this._lockPt);\n        }\n        else {\n            let lt = (lastDt) ? lastDt : dt;\n            let a = this._force.multiply(dt * (dt + lt) / 2);\n            let v = this.changed.multiply(friction * dt / lt).add(a);\n            this._prev = this.clone();\n            this.add(v);\n            this._force = new Pt();\n        }\n        return this;\n    }\n    hit(...args) {\n        this._prev.subtract(new Pt(...args).$divide(Math.sqrt(this._mass)));\n        return this;\n    }\n    collide(p2, damp = 1) {\n        let p1 = this;\n        let dp = p1.$subtract(p2);\n        let distSq = dp.magnitudeSq();\n        let dr = p1.radius + p2.radius;\n        if (distSq < dr * dr) {\n            let c1 = p1.changed;\n            let c2 = p2.changed;\n            let dist = Math.sqrt(distSq);\n            let d = dp.$multiply(((dist - dr) / dist) / 2);\n            let np1 = p1.$subtract(d);\n            let np2 = p2.$add(d);\n            p1.to(np1);\n            p2.to(np2);\n            let f1 = damp * dp.dot(c1) / distSq;\n            let f2 = damp * dp.dot(c2) / distSq;\n            let dm1 = p1.mass / (p1.mass + p2.mass);\n            let dm2 = p2.mass / (p1.mass + p2.mass);\n            c1.add(new Pt(f2 * dp[0] - f1 * dp[0], f2 * dp[1] - f1 * dp[1]).$multiply(dm2));\n            c2.add(new Pt(f1 * dp[0] - f2 * dp[0], f1 * dp[1] - f2 * dp[1]).$multiply(dm1));\n            p1.previous = p1.$subtract(c1);\n            p2.previous = p2.$subtract(c2);\n        }\n    }\n    toString() {\n        return `Particle: ${this[0]} ${this[1]} | previous ${this._prev[0]} ${this._prev[1]} | mass ${this._mass}`;\n    }\n}\nexport class Body extends Group {\n    constructor() {\n        super();\n        this._cs = [];\n        this._stiff = 1;\n        this._locks = {};\n        this._mass = 1;\n    }\n    static fromGroup(list, stiff = 1, autoLink = true, autoMass = true) {\n        let b = new Body().init(list);\n        if (autoLink)\n            b.linkAll(stiff);\n        if (autoMass)\n            b.autoMass();\n        return b;\n    }\n    init(list, stiff = 1) {\n        let c = new Pt();\n        for (let i = 0, len = list.length; i < len; i++) {\n            let p = new Particle(list[i]);\n            p.body = this;\n            c.add(list[i]);\n            this.push(p);\n        }\n        this._stiff = stiff;\n        return this;\n    }\n    get mass() { return this._mass; }\n    set mass(m) {\n        this._mass = m;\n        for (let i = 0, len = this.length; i < len; i++) {\n            this[i].mass = this._mass;\n        }\n    }\n    autoMass() {\n        this.mass = Math.sqrt(Polygon.area(this)) / 10;\n        return this;\n    }\n    link(index1, index2, stiff) {\n        if (index1 < 0 || index1 >= this.length)\n            throw new Error(\"index1 is not in the Group's indices\");\n        if (index2 < 0 || index2 >= this.length)\n            throw new Error(\"index1 is not in the Group's indices\");\n        let d = this[index1].$subtract(this[index2]).magnitude();\n        this._cs.push([index1, index2, d, stiff || this._stiff]);\n        return this;\n    }\n    linkAll(stiff) {\n        let half = this.length / 2;\n        for (let i = 0, len = this.length; i < len; i++) {\n            let n = (i >= len - 1) ? 0 : i + 1;\n            this.link(i, n, stiff);\n            if (len > 4) {\n                let nd = (Math.floor(half / 2)) + 1;\n                let n2 = (i >= len - nd) ? i % len : i + nd;\n                this.link(i, n2, stiff);\n            }\n            if (i <= half - 1) {\n                this.link(i, Math.min(this.length - 1, i + Math.floor(half)));\n            }\n        }\n    }\n    linksToLines() {\n        let gs = [];\n        for (let i = 0, len = this._cs.length; i < len; i++) {\n            let ln = this._cs[i];\n            gs.push(new Group(this[ln[0]], this[ln[1]]));\n        }\n        return gs;\n    }\n    processEdges() {\n        for (let i = 0, len = this._cs.length; i < len; i++) {\n            let [m, n, d, s] = this._cs[i];\n            World.edgeConstraint(this[m], this[n], d, s);\n        }\n    }\n    processBody(b) {\n        let b1 = this;\n        let b2 = b;\n        let hit = Polygon.hasIntersectPolygon(b1, b2);\n        if (hit) {\n            let cv = hit.normal.$multiply(hit.dist);\n            let t;\n            let eg = hit.edge;\n            if (Math.abs(eg[0][0] - eg[1][0]) > Math.abs(eg[0][1] - eg[1][1])) {\n                t = (hit.vertex[0] - cv[0] - eg[0][0]) / (eg[1][0] - eg[0][0]);\n            }\n            else {\n                t = (hit.vertex[1] - cv[1] - eg[0][1]) / (eg[1][1] - eg[0][1]);\n            }\n            let lambda = 1 / (t * t + (1 - t) * (1 - t));\n            let m0 = hit.vertex.body.mass || 1;\n            let m1 = hit.edge[0].body.mass || 1;\n            let mr0 = m0 / (m0 + m1);\n            let mr1 = m1 / (m0 + m1);\n            eg[0].subtract(cv.$multiply(mr0 * (1 - t) * lambda / 2));\n            eg[1].subtract(cv.$multiply(mr0 * t * lambda / 2));\n            hit.vertex.add(cv.$multiply(mr1));\n        }\n    }\n    processParticle(b) {\n        let b1 = this;\n        let b2 = b;\n        let hit = Polygon.hasIntersectCircle(b1, Circle.fromCenter(b, b.radius));\n        if (hit) {\n            let cv = hit.normal.$multiply(hit.dist);\n            let t;\n            let eg = hit.edge;\n            if (Math.abs(eg[0][0] - eg[1][0]) > Math.abs(eg[0][1] - eg[1][1])) {\n                t = (hit.vertex[0] - cv[0] - eg[0][0]) / (eg[1][0] - eg[0][0]);\n            }\n            else {\n                t = (hit.vertex[1] - cv[1] - eg[0][1]) / (eg[1][1] - eg[0][1]);\n            }\n            let lambda = 1 / (t * t + (1 - t) * (1 - t));\n            let m0 = hit.vertex.mass || b2.mass || 1;\n            let m1 = hit.edge[0].body.mass || 1;\n            let mr0 = m0 / (m0 + m1);\n            let mr1 = m1 / (m0 + m1);\n            eg[0].subtract(cv.$multiply(mr0 * (1 - t) * lambda / 2));\n            eg[1].subtract(cv.$multiply(mr0 * t * lambda / 2));\n            let c1 = b.changed.add(cv.$multiply(mr1));\n            b.previous = b.$subtract(c1);\n        }\n    }\n}\n//# sourceMappingURL=Physics.js.map"]},"metadata":{},"sourceType":"module"}