{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { Merge } from \"../component/channel/Merge\";\nimport { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Noise } from \"../source/Noise\";\nimport { Effect } from \"./Effect\";\nimport { OfflineContext } from \"../core/context/OfflineContext\";\nimport { noOp } from \"../core/util/Interface\";\nimport { assertRange } from \"../core/util/Debug\";\n/**\n * Simple convolution created with decaying noise.\n * Generates an Impulse Response Buffer\n * with Tone.Offline then feeds the IR into ConvolverNode.\n * The impulse response generation is async, so you have\n * to wait until [[ready]] resolves before it will make a sound.\n *\n * Inspiration from [ReverbGen](https://github.com/adelespinasse/reverbGen).\n * Copyright (c) 2014 Alan deLespinasse Apache 2.0 License.\n *\n * @category Effect\n */\n\nvar Reverb =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Reverb, _super);\n\n  function Reverb() {\n    var _this = _super.call(this, optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"])) || this;\n\n    _this.name = \"Reverb\";\n    /**\n     * Convolver node\n     */\n\n    _this._convolver = _this.context.createConvolver();\n    /**\n     * Resolves when the reverb buffer is generated. Whenever either [[decay]]\n     * or [[preDelay]] are set, you have to wait until [[ready]] resolves\n     * before the IR is generated with the latest values.\n     */\n\n    _this.ready = Promise.resolve();\n    var options = optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]);\n    _this._decay = options.decay;\n    _this._preDelay = options.preDelay;\n\n    _this.generate();\n\n    _this.connectEffect(_this._convolver);\n\n    return _this;\n  }\n\n  Reverb.getDefaults = function () {\n    return Object.assign(Effect.getDefaults(), {\n      decay: 1.5,\n      preDelay: 0.01\n    });\n  };\n\n  Object.defineProperty(Reverb.prototype, \"decay\", {\n    /**\n     * The duration of the reverb.\n     */\n    get: function () {\n      return this._decay;\n    },\n    set: function (time) {\n      time = this.toSeconds(time);\n      assertRange(time, 0.001);\n      this._decay = time;\n      this.generate();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Reverb.prototype, \"preDelay\", {\n    /**\n     * The amount of time before the reverb is fully ramped in.\n     */\n    get: function () {\n      return this._preDelay;\n    },\n    set: function (time) {\n      time = this.toSeconds(time);\n      assertRange(time, 0);\n      this._preDelay = time;\n      this.generate();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Generate the Impulse Response. Returns a promise while the IR is being generated.\n   * @return Promise which returns this object.\n   */\n\n  Reverb.prototype.generate = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var previousReady, context, noiseL, noiseR, merge, gainNode, renderPromise, _a;\n\n      return tslib_1.__generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            previousReady = this.ready;\n            context = new OfflineContext(2, this._decay + this._preDelay, this.context.sampleRate);\n            noiseL = new Noise({\n              context: context\n            });\n            noiseR = new Noise({\n              context: context\n            });\n            merge = new Merge({\n              context: context\n            });\n            noiseL.connect(merge, 0, 0);\n            noiseR.connect(merge, 0, 1);\n            gainNode = new Gain({\n              context: context\n            }).toDestination();\n            merge.connect(gainNode);\n            noiseL.start(0);\n            noiseR.start(0); // predelay\n\n            gainNode.gain.setValueAtTime(0, 0);\n            gainNode.gain.setValueAtTime(1, this._preDelay); // decay\n\n            gainNode.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay);\n            renderPromise = context.render();\n            this.ready = renderPromise.then(noOp); // wait for the previous `ready` to resolve\n\n            return [4\n            /*yield*/\n            , previousReady];\n\n          case 1:\n            // wait for the previous `ready` to resolve\n            _b.sent(); // set the buffer\n\n\n            _a = this._convolver;\n            return [4\n            /*yield*/\n            , renderPromise];\n\n          case 2:\n            // set the buffer\n            _a.buffer = _b.sent().get();\n            return [2\n            /*return*/\n            , this];\n        }\n      });\n    });\n  };\n\n  Reverb.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._convolver.disconnect();\n\n    return this;\n  };\n\n  return Reverb;\n}(Effect);\n\nexport { Reverb };","map":{"version":3,"sources":["../../../Tone/effect/Reverb.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { Merge } from \"../component/channel/Merge\";\nimport { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Noise } from \"../source/Noise\";\nimport { Effect } from \"./Effect\";\nimport { OfflineContext } from \"../core/context/OfflineContext\";\nimport { noOp } from \"../core/util/Interface\";\nimport { assertRange } from \"../core/util/Debug\";\n/**\n * Simple convolution created with decaying noise.\n * Generates an Impulse Response Buffer\n * with Tone.Offline then feeds the IR into ConvolverNode.\n * The impulse response generation is async, so you have\n * to wait until [[ready]] resolves before it will make a sound.\n *\n * Inspiration from [ReverbGen](https://github.com/adelespinasse/reverbGen).\n * Copyright (c) 2014 Alan deLespinasse Apache 2.0 License.\n *\n * @category Effect\n */\nvar Reverb = /** @class */ (function (_super) {\n    tslib_1.__extends(Reverb, _super);\n    function Reverb() {\n        var _this = _super.call(this, optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"])) || this;\n        _this.name = \"Reverb\";\n        /**\n         * Convolver node\n         */\n        _this._convolver = _this.context.createConvolver();\n        /**\n         * Resolves when the reverb buffer is generated. Whenever either [[decay]]\n         * or [[preDelay]] are set, you have to wait until [[ready]] resolves\n         * before the IR is generated with the latest values.\n         */\n        _this.ready = Promise.resolve();\n        var options = optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]);\n        _this._decay = options.decay;\n        _this._preDelay = options.preDelay;\n        _this.generate();\n        _this.connectEffect(_this._convolver);\n        return _this;\n    }\n    Reverb.getDefaults = function () {\n        return Object.assign(Effect.getDefaults(), {\n            decay: 1.5,\n            preDelay: 0.01,\n        });\n    };\n    Object.defineProperty(Reverb.prototype, \"decay\", {\n        /**\n         * The duration of the reverb.\n         */\n        get: function () {\n            return this._decay;\n        },\n        set: function (time) {\n            time = this.toSeconds(time);\n            assertRange(time, 0.001);\n            this._decay = time;\n            this.generate();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Reverb.prototype, \"preDelay\", {\n        /**\n         * The amount of time before the reverb is fully ramped in.\n         */\n        get: function () {\n            return this._preDelay;\n        },\n        set: function (time) {\n            time = this.toSeconds(time);\n            assertRange(time, 0);\n            this._preDelay = time;\n            this.generate();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Generate the Impulse Response. Returns a promise while the IR is being generated.\n     * @return Promise which returns this object.\n     */\n    Reverb.prototype.generate = function () {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var previousReady, context, noiseL, noiseR, merge, gainNode, renderPromise, _a;\n            return tslib_1.__generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        previousReady = this.ready;\n                        context = new OfflineContext(2, this._decay + this._preDelay, this.context.sampleRate);\n                        noiseL = new Noise({ context: context });\n                        noiseR = new Noise({ context: context });\n                        merge = new Merge({ context: context });\n                        noiseL.connect(merge, 0, 0);\n                        noiseR.connect(merge, 0, 1);\n                        gainNode = new Gain({ context: context }).toDestination();\n                        merge.connect(gainNode);\n                        noiseL.start(0);\n                        noiseR.start(0);\n                        // predelay\n                        gainNode.gain.setValueAtTime(0, 0);\n                        gainNode.gain.setValueAtTime(1, this._preDelay);\n                        // decay\n                        gainNode.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay);\n                        renderPromise = context.render();\n                        this.ready = renderPromise.then(noOp);\n                        // wait for the previous `ready` to resolve\n                        return [4 /*yield*/, previousReady];\n                    case 1:\n                        // wait for the previous `ready` to resolve\n                        _b.sent();\n                        // set the buffer\n                        _a = this._convolver;\n                        return [4 /*yield*/, renderPromise];\n                    case 2:\n                        // set the buffer\n                        _a.buffer = (_b.sent()).get();\n                        return [2 /*return*/, this];\n                }\n            });\n        });\n    };\n    Reverb.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this._convolver.disconnect();\n        return this;\n    };\n    return Reverb;\n}(Effect));\nexport { Reverb };\n//# sourceMappingURL=Reverb.js.map"]},"metadata":{},"sourceType":"module"}