{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { CrossFade } from \"../component/channel/CrossFade\";\nimport { Gain } from \"../core/context/Gain\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { readOnly } from \"../core/util/Interface\";\n/**\n * Effect is the base class for effects. Connect the effect between\n * the effectSend and effectReturn GainNodes, then control the amount of\n * effect which goes to the output using the wet control.\n */\n\nvar Effect =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Effect, _super);\n\n  function Effect(options) {\n    var _this = _super.call(this, options) || this;\n\n    _this.name = \"Effect\";\n    /**\n     * the drywet knob to control the amount of effect\n     */\n\n    _this._dryWet = new CrossFade({\n      context: _this.context\n    });\n    /**\n     * The wet control is how much of the effected\n     * will pass through to the output. 1 = 100% effected\n     * signal, 0 = 100% dry signal.\n     */\n\n    _this.wet = _this._dryWet.fade;\n    /**\n     * connect the effectSend to the input of hte effect\n     */\n\n    _this.effectSend = new Gain({\n      context: _this.context\n    });\n    /**\n     * connect the output of the effect to the effectReturn\n     */\n\n    _this.effectReturn = new Gain({\n      context: _this.context\n    });\n    /**\n     * The effect input node\n     */\n\n    _this.input = new Gain({\n      context: _this.context\n    });\n    /**\n     * The effect output\n     */\n\n    _this.output = _this._dryWet; // connections\n\n    _this.input.fan(_this._dryWet.a, _this.effectSend);\n\n    _this.effectReturn.connect(_this._dryWet.b);\n\n    _this.wet.setValueAtTime(options.wet, 0);\n\n    _this._internalChannels = [_this.effectReturn, _this.effectSend];\n    readOnly(_this, \"wet\");\n    return _this;\n  }\n\n  Effect.getDefaults = function () {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      wet: 1\n    });\n  };\n  /**\n   * chains the effect in between the effectSend and effectReturn\n   */\n\n\n  Effect.prototype.connectEffect = function (effect) {\n    // add it to the internal channels\n    this._internalChannels.push(effect);\n\n    this.effectSend.chain(effect, this.effectReturn);\n    return this;\n  };\n\n  Effect.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._dryWet.dispose();\n\n    this.effectSend.dispose();\n    this.effectReturn.dispose();\n    this.wet.dispose();\n    return this;\n  };\n\n  return Effect;\n}(ToneAudioNode);\n\nexport { Effect };","map":{"version":3,"sources":["../../../Tone/effect/Effect.ts"],"names":[],"mappings":";AAAA,SAAS,SAAT,QAA0B,gCAA1B;AACA,SAAS,IAAT,QAAqB,sBAArB;AACA,SAAS,aAAT,QAAoD,+BAApD;AAEA,SAAS,QAAT,QAAyB,wBAAzB;AAMA;;;;;;AAKA,IAAA,MAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AACS,EAAA,OAAA,CAAA,SAAA,CAAA,MAAA,EAAA,MAAA;;AAoCR,WAAA,MAAA,CAAY,OAAZ,EAAkC;AAAlC,QAAA,KAAA,GACC,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,OAAN,KAAc,IADf;;AAlCS,IAAA,KAAA,CAAA,IAAA,GAAe,QAAf;AAET;;;;AAGQ,IAAA,KAAA,CAAA,OAAA,GAAqB,IAAI,SAAJ,CAAc;AAAE,MAAA,OAAO,EAAE,KAAI,CAAC;AAAhB,KAAd,CAArB;AAER;;;;;;AAKA,IAAA,KAAA,CAAA,GAAA,GAA6B,KAAI,CAAC,OAAL,CAAa,IAA1C;AAEA;;;;AAGU,IAAA,KAAA,CAAA,UAAA,GAAmB,IAAI,IAAJ,CAAS;AAAE,MAAA,OAAO,EAAE,KAAI,CAAC;AAAhB,KAAT,CAAnB;AAEV;;;;AAGU,IAAA,KAAA,CAAA,YAAA,GAAqB,IAAI,IAAJ,CAAS;AAAE,MAAA,OAAO,EAAE,KAAI,CAAC;AAAhB,KAAT,CAArB;AAEV;;;;AAGA,IAAA,KAAA,CAAA,KAAA,GAAc,IAAI,IAAJ,CAAS;AAAE,MAAA,OAAO,EAAE,KAAI,CAAC;AAAhB,KAAT,CAAd;AAEA;;;;AAGA,IAAA,KAAA,CAAA,MAAA,GAAS,KAAI,CAAC,OAAd,CAEkC,CAGjC;;AACA,IAAA,KAAI,CAAC,KAAL,CAAW,GAAX,CAAe,KAAI,CAAC,OAAL,CAAa,CAA5B,EAA+B,KAAI,CAAC,UAApC;;AACA,IAAA,KAAI,CAAC,YAAL,CAAkB,OAAlB,CAA0B,KAAI,CAAC,OAAL,CAAa,CAAvC;;AACA,IAAA,KAAI,CAAC,GAAL,CAAS,cAAT,CAAwB,OAAO,CAAC,GAAhC,EAAqC,CAArC;;AACA,IAAA,KAAI,CAAC,iBAAL,GAAyB,CAAC,KAAI,CAAC,YAAN,EAAoB,KAAI,CAAC,UAAzB,CAAzB;AACA,IAAA,QAAQ,CAAC,KAAD,EAAO,KAAP,CAAR;;AACA;;AAEM,EAAA,MAAA,CAAA,WAAA,GAAP,YAAA;AACC,WAAO,MAAM,CAAC,MAAP,CAAc,aAAa,CAAC,WAAd,EAAd,EAA2C;AACjD,MAAA,GAAG,EAAE;AAD4C,KAA3C,CAAP;AAGA,GAJM;AAMP;;;;;AAGU,EAAA,MAAA,CAAA,SAAA,CAAA,aAAA,GAAV,UAAwB,MAAxB,EAAyD;AACxD;AACA,SAAK,iBAAL,CAAuB,IAAvB,CAA4B,MAA5B;;AACA,SAAK,UAAL,CAAgB,KAAhB,CAAsB,MAAtB,EAA8B,KAAK,YAAnC;AACA,WAAO,IAAP;AACA,GALS;;AAOV,EAAA,MAAA,CAAA,SAAA,CAAA,OAAA,GAAA,YAAA;AACC,IAAA,MAAA,CAAA,SAAA,CAAM,OAAN,CAAa,IAAb,CAAa,IAAb;;AACA,SAAK,OAAL,CAAa,OAAb;;AACA,SAAK,UAAL,CAAgB,OAAhB;AACA,SAAK,YAAL,CAAkB,OAAlB;AACA,SAAK,GAAL,CAAS,OAAT;AACA,WAAO,IAAP;AACA,GAPD;;AAQD,SAAA,MAAA;AAAC,CAxED,CACS,aADT,CAAA","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { CrossFade } from \"../component/channel/CrossFade\";\nimport { Gain } from \"../core/context/Gain\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { readOnly } from \"../core/util/Interface\";\n/**\n * Effect is the base class for effects. Connect the effect between\n * the effectSend and effectReturn GainNodes, then control the amount of\n * effect which goes to the output using the wet control.\n */\nvar Effect = /** @class */ (function (_super) {\n    tslib_1.__extends(Effect, _super);\n    function Effect(options) {\n        var _this = _super.call(this, options) || this;\n        _this.name = \"Effect\";\n        /**\n         * the drywet knob to control the amount of effect\n         */\n        _this._dryWet = new CrossFade({ context: _this.context });\n        /**\n         * The wet control is how much of the effected\n         * will pass through to the output. 1 = 100% effected\n         * signal, 0 = 100% dry signal.\n         */\n        _this.wet = _this._dryWet.fade;\n        /**\n         * connect the effectSend to the input of hte effect\n         */\n        _this.effectSend = new Gain({ context: _this.context });\n        /**\n         * connect the output of the effect to the effectReturn\n         */\n        _this.effectReturn = new Gain({ context: _this.context });\n        /**\n         * The effect input node\n         */\n        _this.input = new Gain({ context: _this.context });\n        /**\n         * The effect output\n         */\n        _this.output = _this._dryWet;\n        // connections\n        _this.input.fan(_this._dryWet.a, _this.effectSend);\n        _this.effectReturn.connect(_this._dryWet.b);\n        _this.wet.setValueAtTime(options.wet, 0);\n        _this._internalChannels = [_this.effectReturn, _this.effectSend];\n        readOnly(_this, \"wet\");\n        return _this;\n    }\n    Effect.getDefaults = function () {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            wet: 1,\n        });\n    };\n    /**\n     * chains the effect in between the effectSend and effectReturn\n     */\n    Effect.prototype.connectEffect = function (effect) {\n        // add it to the internal channels\n        this._internalChannels.push(effect);\n        this.effectSend.chain(effect, this.effectReturn);\n        return this;\n    };\n    Effect.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this._dryWet.dispose();\n        this.effectSend.dispose();\n        this.effectReturn.dispose();\n        this.wet.dispose();\n        return this;\n    };\n    return Effect;\n}(ToneAudioNode));\nexport { Effect };\n//# sourceMappingURL=Effect.js.map"]},"metadata":{},"sourceType":"module"}