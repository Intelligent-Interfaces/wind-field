{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { Ticker } from \"../clock/Ticker\";\nimport { isAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined, isString } from \"../util/TypeCheck\";\nimport { createAudioContext, createAudioWorkletNode } from \"./AudioContext\";\nimport { closeContext, initializeContext } from \"./ContextInitialization\";\nimport { BaseContext } from \"./BaseContext\";\nimport { assert } from \"../util/Debug\";\n/**\n * Wrapper around the native AudioContext.\n * @category Core\n */\n\nvar Context =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Context, _super);\n\n  function Context() {\n    var _this = _super.call(this) || this;\n\n    _this.name = \"Context\";\n    /**\n     * An object containing all of the constants AudioBufferSourceNodes\n     */\n\n    _this._constants = new Map();\n    /**\n     * All of the setTimeout events.\n     */\n\n    _this._timeouts = new Timeline();\n    /**\n     * The timeout id counter\n     */\n\n    _this._timeoutIds = 0;\n    /**\n     * Private indicator if the context has been initialized\n     */\n\n    _this._initialized = false;\n    /**\n     * Indicates if the context is an OfflineAudioContext or an AudioContext\n     */\n\n    _this.isOffline = false; //--------------------------------------------\n    // AUDIO WORKLET\n    //--------------------------------------------\n\n    /**\n     * Maps a module name to promise of the addModule method\n     */\n\n    _this._workletModules = new Map();\n    var options = optionsFromArguments(Context.getDefaults(), arguments, [\"context\"]);\n\n    if (options.context) {\n      _this._context = options.context;\n    } else {\n      _this._context = createAudioContext();\n    }\n\n    _this._latencyHint = options.latencyHint;\n    _this.lookAhead = options.lookAhead;\n    _this._ticker = new Ticker(_this.emit.bind(_this, \"tick\"), options.clockSource, options.updateInterval);\n\n    _this.on(\"tick\", _this._timeoutLoop.bind(_this)); // fwd events from the context\n\n\n    _this._context.onstatechange = function () {\n      _this.emit(\"statechange\", _this.state);\n    };\n\n    return _this;\n  }\n\n  Context.getDefaults = function () {\n    return {\n      clockSource: \"worker\",\n      latencyHint: \"interactive\",\n      lookAhead: 0.1,\n      updateInterval: 0.05\n    };\n  };\n  /**\n   * Finish setting up the context. **You usually do not need to do this manually.**\n   */\n\n\n  Context.prototype.initialize = function () {\n    if (!this._initialized) {\n      // add any additional modules\n      initializeContext(this);\n      this._initialized = true;\n    }\n\n    return this;\n  }; //---------------------------\n  // BASE AUDIO CONTEXT METHODS\n  //---------------------------\n\n\n  Context.prototype.createAnalyser = function () {\n    return this._context.createAnalyser();\n  };\n\n  Context.prototype.createOscillator = function () {\n    return this._context.createOscillator();\n  };\n\n  Context.prototype.createBufferSource = function () {\n    return this._context.createBufferSource();\n  };\n\n  Context.prototype.createBiquadFilter = function () {\n    return this._context.createBiquadFilter();\n  };\n\n  Context.prototype.createBuffer = function (numberOfChannels, length, sampleRate) {\n    return this._context.createBuffer(numberOfChannels, length, sampleRate);\n  };\n\n  Context.prototype.createChannelMerger = function (numberOfInputs) {\n    return this._context.createChannelMerger(numberOfInputs);\n  };\n\n  Context.prototype.createChannelSplitter = function (numberOfOutputs) {\n    return this._context.createChannelSplitter(numberOfOutputs);\n  };\n\n  Context.prototype.createConstantSource = function () {\n    return this._context.createConstantSource();\n  };\n\n  Context.prototype.createConvolver = function () {\n    return this._context.createConvolver();\n  };\n\n  Context.prototype.createDelay = function (maxDelayTime) {\n    return this._context.createDelay(maxDelayTime);\n  };\n\n  Context.prototype.createDynamicsCompressor = function () {\n    return this._context.createDynamicsCompressor();\n  };\n\n  Context.prototype.createGain = function () {\n    return this._context.createGain();\n  };\n\n  Context.prototype.createIIRFilter = function (feedForward, feedback) {\n    // @ts-ignore\n    return this._context.createIIRFilter(feedForward, feedback);\n  };\n\n  Context.prototype.createPanner = function () {\n    return this._context.createPanner();\n  };\n\n  Context.prototype.createPeriodicWave = function (real, imag, constraints) {\n    return this._context.createPeriodicWave(real, imag, constraints);\n  };\n\n  Context.prototype.createStereoPanner = function () {\n    return this._context.createStereoPanner();\n  };\n\n  Context.prototype.createWaveShaper = function () {\n    return this._context.createWaveShaper();\n  };\n\n  Context.prototype.createMediaStreamSource = function (stream) {\n    if (isAudioContext(this._context)) {\n      return this._context.createMediaStreamSource(stream);\n    } else {\n      throw new Error(\"Only available on online audio context\");\n    }\n  };\n\n  Context.prototype.decodeAudioData = function (audioData) {\n    return this._context.decodeAudioData(audioData);\n  };\n\n  Object.defineProperty(Context.prototype, \"currentTime\", {\n    /**\n     * The current time in seconds of the AudioContext.\n     */\n    get: function () {\n      return this._context.currentTime;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"state\", {\n    /**\n     * The current time in seconds of the AudioContext.\n     */\n    get: function () {\n      return this._context.state;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"sampleRate\", {\n    /**\n     * The current time in seconds of the AudioContext.\n     */\n    get: function () {\n      return this._context.sampleRate;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"listener\", {\n    /**\n     * The listener\n     */\n    get: function () {\n      this.initialize();\n      return this._listener;\n    },\n    set: function (l) {\n      assert(!this._initialized, \"The listener cannot be set after initialization.\");\n      this._listener = l;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"transport\", {\n    /**\n     * There is only one Transport per Context. It is created on initialization.\n     */\n    get: function () {\n      this.initialize();\n      return this._transport;\n    },\n    set: function (t) {\n      assert(!this._initialized, \"The transport cannot be set after initialization.\");\n      this._transport = t;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"draw\", {\n    /**\n     * This is the Draw object for the context which is useful for synchronizing the draw frame with the Tone.js clock.\n     */\n    get: function () {\n      this.initialize();\n      return this._draw;\n    },\n    set: function (d) {\n      assert(!this._initialized, \"Draw cannot be set after initialization.\");\n      this._draw = d;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"destination\", {\n    /**\n     * A reference to the Context's destination node.\n     */\n    get: function () {\n      this.initialize();\n      return this._destination;\n    },\n    set: function (d) {\n      assert(!this._initialized, \"The destination cannot be set after initialization.\");\n      this._destination = d;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Create an audio worklet node from a name and options. The module\n   * must first be loaded using [[addAudioWorkletModule]].\n   */\n\n  Context.prototype.createAudioWorkletNode = function (name, options) {\n    return createAudioWorkletNode(this.rawContext, name, options);\n  };\n  /**\n   * Add an AudioWorkletProcessor module\n   * @param url The url of the module\n   * @param name The name of the module\n   */\n\n\n  Context.prototype.addAudioWorkletModule = function (url, name) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert(isDefined(this.rawContext.audioWorklet), \"AudioWorkletNode is only available in a secure context (https or localhost)\");\n\n            if (!this._workletModules.has(name)) {\n              this._workletModules.set(name, this.rawContext.audioWorklet.addModule(url));\n            }\n\n            return [4\n            /*yield*/\n            , this._workletModules.get(name)];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Returns a promise which resolves when all of the worklets have been loaded on this context\n   */\n\n\n  Context.prototype.workletsAreReady = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var promises;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            promises = [];\n\n            this._workletModules.forEach(function (promise) {\n              return promises.push(promise);\n            });\n\n            return [4\n            /*yield*/\n            , Promise.all(promises)];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Object.defineProperty(Context.prototype, \"updateInterval\", {\n    //---------------------------\n    // TICKER\n    //---------------------------\n\n    /**\n     * How often the interval callback is invoked.\n     * This number corresponds to how responsive the scheduling\n     * can be. context.updateInterval + context.lookAhead gives you the\n     * total latency between scheduling an event and hearing it.\n     */\n    get: function () {\n      return this._ticker.updateInterval;\n    },\n    set: function (interval) {\n      this._ticker.updateInterval = interval;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"clockSource\", {\n    /**\n     * What the source of the clock is, either \"worker\" (default),\n     * \"timeout\", or \"offline\" (none).\n     */\n    get: function () {\n      return this._ticker.type;\n    },\n    set: function (type) {\n      this._ticker.type = type;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"latencyHint\", {\n    /**\n     * The type of playback, which affects tradeoffs between audio\n     * output latency and responsiveness.\n     * In addition to setting the value in seconds, the latencyHint also\n     * accepts the strings \"interactive\" (prioritizes low latency),\n     * \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n     * latency and performance), and \"fastest\" (lowest latency, might glitch more often).\n     * @example\n     * import * as Tone from \"tone\";\n     * // set the latencyHint to prioritize smooth playback at the expensive of latency\n     * Tone.context.latencyHint = \"playback\";\n     */\n    get: function () {\n      return this._latencyHint;\n    },\n    set: function (hint) {\n      var lookAheadValue = 0;\n      this._latencyHint = hint;\n\n      if (isString(hint)) {\n        switch (hint) {\n          case \"interactive\":\n            lookAheadValue = 0.1;\n            break;\n\n          case \"playback\":\n            lookAheadValue = 0.8;\n            break;\n\n          case \"balanced\":\n            lookAheadValue = 0.25;\n            break;\n\n          case \"fastest\":\n            lookAheadValue = 0.01;\n            break;\n        }\n      }\n\n      this.lookAhead = lookAheadValue;\n      this.updateInterval = lookAheadValue / 2;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"rawContext\", {\n    /**\n     * The unwrapped AudioContext.\n     */\n    get: function () {\n      return this._context;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * The current audio context time plus a short [[lookAhead]].\n   */\n\n  Context.prototype.now = function () {\n    return this._context.currentTime + this.lookAhead;\n  };\n  /**\n   * The current audio context time without the [[lookAhead]].\n   * In most cases it is better to use [[now]] instead of [[immediate]] since\n   * with [[now]] the [[lookAhead]] is applied equally to _all_ components including internal components,\n   * to making sure that everything is scheduled in sync. Mixing [[now]] and [[immediate]]\n   * can cause some timing issues. If no lookAhead is desired, you can set the [[lookAhead]] to `0`.\n   */\n\n\n  Context.prototype.immediate = function () {\n    return this._context.currentTime;\n  };\n  /**\n   * Starts the audio context from a suspended state. This is required\n   * to initially start the AudioContext.\n   */\n\n\n  Context.prototype.resume = function () {\n    if (this._context.state === \"suspended\" && isAudioContext(this._context)) {\n      return this._context.resume();\n    } else {\n      return Promise.resolve();\n    }\n  };\n  /**\n   * Promise which is invoked when the context is running.\n   * Tries to resume the context if it's not started.\n   */\n\n\n  Context.prototype.close = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!isAudioContext(this._context)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this._context.close()];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            if (this._initialized) {\n              closeContext(this);\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Generate a looped buffer at some constant value.\n   */\n\n\n  Context.prototype.getConstant = function (val) {\n    if (this._constants.has(val)) {\n      return this._constants.get(val);\n    } else {\n      var buffer = this._context.createBuffer(1, 128, this._context.sampleRate);\n\n      var arr = buffer.getChannelData(0);\n\n      for (var i = 0; i < arr.length; i++) {\n        arr[i] = val;\n      }\n\n      var constant = this._context.createBufferSource();\n\n      constant.channelCount = 1;\n      constant.channelCountMode = \"explicit\";\n      constant.buffer = buffer;\n      constant.loop = true;\n      constant.start(0);\n\n      this._constants.set(val, constant);\n\n      return constant;\n    }\n  };\n  /**\n   * Clean up. Also closes the audio context.\n   */\n\n\n  Context.prototype.dispose = function () {\n    var _this = this;\n\n    _super.prototype.dispose.call(this);\n\n    this._ticker.dispose();\n\n    this._timeouts.dispose();\n\n    Object.keys(this._constants).map(function (val) {\n      return _this._constants[val].disconnect();\n    });\n    return this;\n  }; //---------------------------\n  // TIMEOUTS\n  //---------------------------\n\n  /**\n   * The private loop which keeps track of the context scheduled timeouts\n   * Is invoked from the clock source\n   */\n\n\n  Context.prototype._timeoutLoop = function () {\n    var now = this.now();\n\n    var firstEvent = this._timeouts.peek();\n\n    while (this._timeouts.length && firstEvent && firstEvent.time <= now) {\n      // invoke the callback\n      firstEvent.callback(); // shift the first event off\n\n      this._timeouts.shift(); // get the next one\n\n\n      firstEvent = this._timeouts.peek();\n    }\n  };\n  /**\n   * A setTimeout which is guaranteed by the clock source.\n   * Also runs in the offline context.\n   * @param  fn       The callback to invoke\n   * @param  timeout  The timeout in seconds\n   * @returns ID to use when invoking Context.clearTimeout\n   */\n\n\n  Context.prototype.setTimeout = function (fn, timeout) {\n    this._timeoutIds++;\n    var now = this.now();\n\n    this._timeouts.add({\n      callback: fn,\n      id: this._timeoutIds,\n      time: now + timeout\n    });\n\n    return this._timeoutIds;\n  };\n  /**\n   * Clears a previously scheduled timeout with Tone.context.setTimeout\n   * @param  id  The ID returned from setTimeout\n   */\n\n\n  Context.prototype.clearTimeout = function (id) {\n    var _this = this;\n\n    this._timeouts.forEach(function (event) {\n      if (event.id === id) {\n        _this._timeouts.remove(event);\n      }\n    });\n\n    return this;\n  };\n  /**\n   * Clear the function scheduled by [[setInterval]]\n   */\n\n\n  Context.prototype.clearInterval = function (id) {\n    return this.clearTimeout(id);\n  };\n  /**\n   * Adds a repeating event to the context's callback clock\n   */\n\n\n  Context.prototype.setInterval = function (fn, interval) {\n    var _this = this;\n\n    var id = ++this._timeoutIds;\n\n    var intervalFn = function () {\n      var now = _this.now();\n\n      _this._timeouts.add({\n        callback: function () {\n          // invoke the callback\n          fn(); // invoke the event to repeat it\n\n          intervalFn();\n        },\n        id: id,\n        time: now + interval\n      });\n    }; // kick it off\n\n\n    intervalFn();\n    return id;\n  };\n\n  return Context;\n}(BaseContext);\n\nexport { Context };","map":{"version":3,"sources":["../../../../Tone/core/context/Context.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { Ticker } from \"../clock/Ticker\";\nimport { isAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined, isString } from \"../util/TypeCheck\";\nimport { createAudioContext, createAudioWorkletNode } from \"./AudioContext\";\nimport { closeContext, initializeContext } from \"./ContextInitialization\";\nimport { BaseContext } from \"./BaseContext\";\nimport { assert } from \"../util/Debug\";\n/**\n * Wrapper around the native AudioContext.\n * @category Core\n */\nvar Context = /** @class */ (function (_super) {\n    tslib_1.__extends(Context, _super);\n    function Context() {\n        var _this = _super.call(this) || this;\n        _this.name = \"Context\";\n        /**\n         * An object containing all of the constants AudioBufferSourceNodes\n         */\n        _this._constants = new Map();\n        /**\n         * All of the setTimeout events.\n         */\n        _this._timeouts = new Timeline();\n        /**\n         * The timeout id counter\n         */\n        _this._timeoutIds = 0;\n        /**\n         * Private indicator if the context has been initialized\n         */\n        _this._initialized = false;\n        /**\n         * Indicates if the context is an OfflineAudioContext or an AudioContext\n         */\n        _this.isOffline = false;\n        //--------------------------------------------\n        // AUDIO WORKLET\n        //--------------------------------------------\n        /**\n         * Maps a module name to promise of the addModule method\n         */\n        _this._workletModules = new Map();\n        var options = optionsFromArguments(Context.getDefaults(), arguments, [\"context\"]);\n        if (options.context) {\n            _this._context = options.context;\n        }\n        else {\n            _this._context = createAudioContext();\n        }\n        _this._latencyHint = options.latencyHint;\n        _this.lookAhead = options.lookAhead;\n        _this._ticker = new Ticker(_this.emit.bind(_this, \"tick\"), options.clockSource, options.updateInterval);\n        _this.on(\"tick\", _this._timeoutLoop.bind(_this));\n        // fwd events from the context\n        _this._context.onstatechange = function () {\n            _this.emit(\"statechange\", _this.state);\n        };\n        return _this;\n    }\n    Context.getDefaults = function () {\n        return {\n            clockSource: \"worker\",\n            latencyHint: \"interactive\",\n            lookAhead: 0.1,\n            updateInterval: 0.05,\n        };\n    };\n    /**\n     * Finish setting up the context. **You usually do not need to do this manually.**\n     */\n    Context.prototype.initialize = function () {\n        if (!this._initialized) {\n            // add any additional modules\n            initializeContext(this);\n            this._initialized = true;\n        }\n        return this;\n    };\n    //---------------------------\n    // BASE AUDIO CONTEXT METHODS\n    //---------------------------\n    Context.prototype.createAnalyser = function () {\n        return this._context.createAnalyser();\n    };\n    Context.prototype.createOscillator = function () {\n        return this._context.createOscillator();\n    };\n    Context.prototype.createBufferSource = function () {\n        return this._context.createBufferSource();\n    };\n    Context.prototype.createBiquadFilter = function () {\n        return this._context.createBiquadFilter();\n    };\n    Context.prototype.createBuffer = function (numberOfChannels, length, sampleRate) {\n        return this._context.createBuffer(numberOfChannels, length, sampleRate);\n    };\n    Context.prototype.createChannelMerger = function (numberOfInputs) {\n        return this._context.createChannelMerger(numberOfInputs);\n    };\n    Context.prototype.createChannelSplitter = function (numberOfOutputs) {\n        return this._context.createChannelSplitter(numberOfOutputs);\n    };\n    Context.prototype.createConstantSource = function () {\n        return this._context.createConstantSource();\n    };\n    Context.prototype.createConvolver = function () {\n        return this._context.createConvolver();\n    };\n    Context.prototype.createDelay = function (maxDelayTime) {\n        return this._context.createDelay(maxDelayTime);\n    };\n    Context.prototype.createDynamicsCompressor = function () {\n        return this._context.createDynamicsCompressor();\n    };\n    Context.prototype.createGain = function () {\n        return this._context.createGain();\n    };\n    Context.prototype.createIIRFilter = function (feedForward, feedback) {\n        // @ts-ignore\n        return this._context.createIIRFilter(feedForward, feedback);\n    };\n    Context.prototype.createPanner = function () {\n        return this._context.createPanner();\n    };\n    Context.prototype.createPeriodicWave = function (real, imag, constraints) {\n        return this._context.createPeriodicWave(real, imag, constraints);\n    };\n    Context.prototype.createStereoPanner = function () {\n        return this._context.createStereoPanner();\n    };\n    Context.prototype.createWaveShaper = function () {\n        return this._context.createWaveShaper();\n    };\n    Context.prototype.createMediaStreamSource = function (stream) {\n        if (isAudioContext(this._context)) {\n            return this._context.createMediaStreamSource(stream);\n        }\n        else {\n            throw new Error(\"Only available on online audio context\");\n        }\n    };\n    Context.prototype.decodeAudioData = function (audioData) {\n        return this._context.decodeAudioData(audioData);\n    };\n    Object.defineProperty(Context.prototype, \"currentTime\", {\n        /**\n         * The current time in seconds of the AudioContext.\n         */\n        get: function () {\n            return this._context.currentTime;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Context.prototype, \"state\", {\n        /**\n         * The current time in seconds of the AudioContext.\n         */\n        get: function () {\n            return this._context.state;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Context.prototype, \"sampleRate\", {\n        /**\n         * The current time in seconds of the AudioContext.\n         */\n        get: function () {\n            return this._context.sampleRate;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Context.prototype, \"listener\", {\n        /**\n         * The listener\n         */\n        get: function () {\n            this.initialize();\n            return this._listener;\n        },\n        set: function (l) {\n            assert(!this._initialized, \"The listener cannot be set after initialization.\");\n            this._listener = l;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Context.prototype, \"transport\", {\n        /**\n         * There is only one Transport per Context. It is created on initialization.\n         */\n        get: function () {\n            this.initialize();\n            return this._transport;\n        },\n        set: function (t) {\n            assert(!this._initialized, \"The transport cannot be set after initialization.\");\n            this._transport = t;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Context.prototype, \"draw\", {\n        /**\n         * This is the Draw object for the context which is useful for synchronizing the draw frame with the Tone.js clock.\n         */\n        get: function () {\n            this.initialize();\n            return this._draw;\n        },\n        set: function (d) {\n            assert(!this._initialized, \"Draw cannot be set after initialization.\");\n            this._draw = d;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Context.prototype, \"destination\", {\n        /**\n         * A reference to the Context's destination node.\n         */\n        get: function () {\n            this.initialize();\n            return this._destination;\n        },\n        set: function (d) {\n            assert(!this._initialized, \"The destination cannot be set after initialization.\");\n            this._destination = d;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Create an audio worklet node from a name and options. The module\n     * must first be loaded using [[addAudioWorkletModule]].\n     */\n    Context.prototype.createAudioWorkletNode = function (name, options) {\n        return createAudioWorkletNode(this.rawContext, name, options);\n    };\n    /**\n     * Add an AudioWorkletProcessor module\n     * @param url The url of the module\n     * @param name The name of the module\n     */\n    Context.prototype.addAudioWorkletModule = function (url, name) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert(isDefined(this.rawContext.audioWorklet), \"AudioWorkletNode is only available in a secure context (https or localhost)\");\n                        if (!this._workletModules.has(name)) {\n                            this._workletModules.set(name, this.rawContext.audioWorklet.addModule(url));\n                        }\n                        return [4 /*yield*/, this._workletModules.get(name)];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns a promise which resolves when all of the worklets have been loaded on this context\n     */\n    Context.prototype.workletsAreReady = function () {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var promises;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        promises = [];\n                        this._workletModules.forEach(function (promise) { return promises.push(promise); });\n                        return [4 /*yield*/, Promise.all(promises)];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Object.defineProperty(Context.prototype, \"updateInterval\", {\n        //---------------------------\n        // TICKER\n        //---------------------------\n        /**\n         * How often the interval callback is invoked.\n         * This number corresponds to how responsive the scheduling\n         * can be. context.updateInterval + context.lookAhead gives you the\n         * total latency between scheduling an event and hearing it.\n         */\n        get: function () {\n            return this._ticker.updateInterval;\n        },\n        set: function (interval) {\n            this._ticker.updateInterval = interval;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Context.prototype, \"clockSource\", {\n        /**\n         * What the source of the clock is, either \"worker\" (default),\n         * \"timeout\", or \"offline\" (none).\n         */\n        get: function () {\n            return this._ticker.type;\n        },\n        set: function (type) {\n            this._ticker.type = type;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Context.prototype, \"latencyHint\", {\n        /**\n         * The type of playback, which affects tradeoffs between audio\n         * output latency and responsiveness.\n         * In addition to setting the value in seconds, the latencyHint also\n         * accepts the strings \"interactive\" (prioritizes low latency),\n         * \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n         * latency and performance), and \"fastest\" (lowest latency, might glitch more often).\n         * @example\n         * import * as Tone from \"tone\";\n         * // set the latencyHint to prioritize smooth playback at the expensive of latency\n         * Tone.context.latencyHint = \"playback\";\n         */\n        get: function () {\n            return this._latencyHint;\n        },\n        set: function (hint) {\n            var lookAheadValue = 0;\n            this._latencyHint = hint;\n            if (isString(hint)) {\n                switch (hint) {\n                    case \"interactive\":\n                        lookAheadValue = 0.1;\n                        break;\n                    case \"playback\":\n                        lookAheadValue = 0.8;\n                        break;\n                    case \"balanced\":\n                        lookAheadValue = 0.25;\n                        break;\n                    case \"fastest\":\n                        lookAheadValue = 0.01;\n                        break;\n                }\n            }\n            this.lookAhead = lookAheadValue;\n            this.updateInterval = lookAheadValue / 2;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Context.prototype, \"rawContext\", {\n        /**\n         * The unwrapped AudioContext.\n         */\n        get: function () {\n            return this._context;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * The current audio context time plus a short [[lookAhead]].\n     */\n    Context.prototype.now = function () {\n        return this._context.currentTime + this.lookAhead;\n    };\n    /**\n     * The current audio context time without the [[lookAhead]].\n     * In most cases it is better to use [[now]] instead of [[immediate]] since\n     * with [[now]] the [[lookAhead]] is applied equally to _all_ components including internal components,\n     * to making sure that everything is scheduled in sync. Mixing [[now]] and [[immediate]]\n     * can cause some timing issues. If no lookAhead is desired, you can set the [[lookAhead]] to `0`.\n     */\n    Context.prototype.immediate = function () {\n        return this._context.currentTime;\n    };\n    /**\n     * Starts the audio context from a suspended state. This is required\n     * to initially start the AudioContext.\n     */\n    Context.prototype.resume = function () {\n        if (this._context.state === \"suspended\" && isAudioContext(this._context)) {\n            return this._context.resume();\n        }\n        else {\n            return Promise.resolve();\n        }\n    };\n    /**\n     * Promise which is invoked when the context is running.\n     * Tries to resume the context if it's not started.\n     */\n    Context.prototype.close = function () {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!isAudioContext(this._context)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this._context.close()];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        if (this._initialized) {\n                            closeContext(this);\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Generate a looped buffer at some constant value.\n     */\n    Context.prototype.getConstant = function (val) {\n        if (this._constants.has(val)) {\n            return this._constants.get(val);\n        }\n        else {\n            var buffer = this._context.createBuffer(1, 128, this._context.sampleRate);\n            var arr = buffer.getChannelData(0);\n            for (var i = 0; i < arr.length; i++) {\n                arr[i] = val;\n            }\n            var constant = this._context.createBufferSource();\n            constant.channelCount = 1;\n            constant.channelCountMode = \"explicit\";\n            constant.buffer = buffer;\n            constant.loop = true;\n            constant.start(0);\n            this._constants.set(val, constant);\n            return constant;\n        }\n    };\n    /**\n     * Clean up. Also closes the audio context.\n     */\n    Context.prototype.dispose = function () {\n        var _this = this;\n        _super.prototype.dispose.call(this);\n        this._ticker.dispose();\n        this._timeouts.dispose();\n        Object.keys(this._constants).map(function (val) { return _this._constants[val].disconnect(); });\n        return this;\n    };\n    //---------------------------\n    // TIMEOUTS\n    //---------------------------\n    /**\n     * The private loop which keeps track of the context scheduled timeouts\n     * Is invoked from the clock source\n     */\n    Context.prototype._timeoutLoop = function () {\n        var now = this.now();\n        var firstEvent = this._timeouts.peek();\n        while (this._timeouts.length && firstEvent && firstEvent.time <= now) {\n            // invoke the callback\n            firstEvent.callback();\n            // shift the first event off\n            this._timeouts.shift();\n            // get the next one\n            firstEvent = this._timeouts.peek();\n        }\n    };\n    /**\n     * A setTimeout which is guaranteed by the clock source.\n     * Also runs in the offline context.\n     * @param  fn       The callback to invoke\n     * @param  timeout  The timeout in seconds\n     * @returns ID to use when invoking Context.clearTimeout\n     */\n    Context.prototype.setTimeout = function (fn, timeout) {\n        this._timeoutIds++;\n        var now = this.now();\n        this._timeouts.add({\n            callback: fn,\n            id: this._timeoutIds,\n            time: now + timeout,\n        });\n        return this._timeoutIds;\n    };\n    /**\n     * Clears a previously scheduled timeout with Tone.context.setTimeout\n     * @param  id  The ID returned from setTimeout\n     */\n    Context.prototype.clearTimeout = function (id) {\n        var _this = this;\n        this._timeouts.forEach(function (event) {\n            if (event.id === id) {\n                _this._timeouts.remove(event);\n            }\n        });\n        return this;\n    };\n    /**\n     * Clear the function scheduled by [[setInterval]]\n     */\n    Context.prototype.clearInterval = function (id) {\n        return this.clearTimeout(id);\n    };\n    /**\n     * Adds a repeating event to the context's callback clock\n     */\n    Context.prototype.setInterval = function (fn, interval) {\n        var _this = this;\n        var id = ++this._timeoutIds;\n        var intervalFn = function () {\n            var now = _this.now();\n            _this._timeouts.add({\n                callback: function () {\n                    // invoke the callback\n                    fn();\n                    // invoke the event to repeat it\n                    intervalFn();\n                },\n                id: id,\n                time: now + interval,\n            });\n        };\n        // kick it off\n        intervalFn();\n        return id;\n    };\n    return Context;\n}(BaseContext));\nexport { Context };\n//# sourceMappingURL=Context.js.map"]},"metadata":{},"sourceType":"module"}