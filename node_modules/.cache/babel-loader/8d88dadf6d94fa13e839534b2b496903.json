{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { TimeClass } from \"../../core/type/Time\";\nimport { TimelineValue } from \"../../core/util/TimelineValue\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\nimport { Gain } from \"../context/Gain\";\nimport { ToneWithContext } from \"../context/ToneWithContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { readOnly, writable } from \"../util/Interface\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isArray, isDefined } from \"../util/TypeCheck\";\nimport { Clock } from \"./Clock\";\nimport { TransportEvent } from \"./TransportEvent\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent\";\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * import { Oscillator, Transport } from \"tone\";\n * const osc = new Oscillator().toDestination();\n * // repeated event every 8th note\n * Transport.scheduleRepeat((time) => {\n * \t// use the callback time to schedule events\n * \tosc.start(time).stop(time + 0.1);\n * }, \"8n\");\n * // transport must be started before it starts invoking events\n * Transport.start();\n * @category Core\n */\n\nvar Transport =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Transport, _super);\n\n  function Transport() {\n    var _this = _super.call(this, optionsFromArguments(Transport.getDefaults(), arguments)) || this;\n\n    _this.name = \"Transport\"; //-------------------------------------\n    // \tLOOPING\n    //-------------------------------------\n\n    /**\n     * If the transport loops or not.\n     */\n\n    _this._loop = new TimelineValue(false);\n    /**\n     * The loop start position in ticks\n     */\n\n    _this._loopStart = 0;\n    /**\n     * The loop end position in ticks\n     */\n\n    _this._loopEnd = 0; //-------------------------------------\n    // \tTIMELINE EVENTS\n    //-------------------------------------\n\n    /**\n     * All the events in an object to keep track by ID\n     */\n\n    _this._scheduledEvents = {};\n    /**\n     * The scheduled events.\n     */\n\n    _this._timeline = new Timeline();\n    /**\n     * Repeated events\n     */\n\n    _this._repeatedEvents = new IntervalTimeline();\n    /**\n     * All of the synced Signals\n     */\n\n    _this._syncedSignals = [];\n    /**\n     * The swing amount\n     */\n\n    _this._swingAmount = 0;\n    var options = optionsFromArguments(Transport.getDefaults(), arguments); // CLOCK/TEMPO\n\n    _this._ppq = options.ppq;\n    _this._clock = new Clock({\n      callback: _this._processTick.bind(_this),\n      context: _this.context,\n      frequency: 0,\n      units: \"bpm\"\n    });\n\n    _this._bindClockEvents();\n\n    _this.bpm = _this._clock.frequency;\n    _this._clock.frequency.multiplier = options.ppq;\n\n    _this.bpm.setValueAtTime(options.bpm, 0);\n\n    readOnly(_this, \"bpm\");\n    _this._timeSignature = options.timeSignature; // SWING\n\n    _this._swingTicks = options.ppq / 2; // 8n\n\n    return _this;\n  }\n\n  Transport.getDefaults = function () {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      bpm: 120,\n      loopEnd: \"4m\",\n      loopStart: 0,\n      ppq: 192,\n      swing: 0,\n      swingSubdivision: \"8n\",\n      timeSignature: 4\n    });\n  }; //-------------------------------------\n  // \tTICKS\n  //-------------------------------------\n\n  /**\n   * called on every tick\n   * @param  tickTime clock relative tick time\n   */\n\n\n  Transport.prototype._processTick = function (tickTime, ticks) {\n    // handle swing\n    if (this._swingAmount > 0 && ticks % this._ppq !== 0 && // not on a downbeat\n    ticks % (this._swingTicks * 2) !== 0) {\n      // add some swing\n      var progress = ticks % (this._swingTicks * 2) / (this._swingTicks * 2);\n\n      var amount = Math.sin(progress * Math.PI) * this._swingAmount;\n\n      tickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;\n    } // do the loop test\n\n\n    if (this._loop.get(tickTime)) {\n      if (ticks >= this._loopEnd) {\n        this.emit(\"loopEnd\", tickTime);\n\n        this._clock.setTicksAtTime(this._loopStart, tickTime);\n\n        ticks = this._loopStart;\n        this.emit(\"loopStart\", tickTime, this._clock.getSecondsAtTime(tickTime));\n        this.emit(\"loop\", tickTime);\n      }\n    } // invoke the timeline events scheduled on this tick\n\n\n    this._timeline.forEachAtTime(ticks, function (event) {\n      return event.invoke(tickTime);\n    });\n  }; //-------------------------------------\n  // \tSCHEDULABLE EVENTS\n  //-------------------------------------\n\n  /**\n   * Schedule an event along the timeline.\n   * @param callback The callback to be invoked at the time.\n   * @param time The time to invoke the callback at.\n   * @return The id of the event which can be used for canceling the event.\n   * @example\n   * import { Transport } from \"tone\";\n   * // schedule an event on the 16th measure\n   * Transport.schedule((time) => {\n   * \t// invoked on measure 16\n   * \tconsole.log(\"measure 16!\");\n   * }, \"16:0:0\");\n   */\n\n\n  Transport.prototype.schedule = function (callback, time) {\n    var event = new TransportEvent(this, {\n      callback: callback,\n      time: new TransportTimeClass(this.context, time).toTicks()\n    });\n    return this._addEvent(event, this._timeline);\n  };\n  /**\n   * Schedule a repeated event along the timeline. The event will fire\n   * at the `interval` starting at the `startTime` and for the specified\n   * `duration`.\n   * @param  callback   The callback to invoke.\n   * @param  interval   The duration between successive callbacks. Must be a positive number.\n   * @param  startTime  When along the timeline the events should start being invoked.\n   * @param  duration How long the event should repeat.\n   * @return  The ID of the scheduled event. Use this to cancel the event.\n   * @example\n   * import { Oscillator, Transport } from \"tone\";\n   * const osc = new Oscillator().toDestination().start();\n   * // a callback invoked every eighth note after the first measure\n   * Transport.scheduleRepeat((time) => {\n   * \tosc.start(time).stop(time + 0.1);\n   * }, \"8n\", \"1m\");\n   */\n\n\n  Transport.prototype.scheduleRepeat = function (callback, interval, startTime, duration) {\n    if (duration === void 0) {\n      duration = Infinity;\n    }\n\n    var event = new TransportRepeatEvent(this, {\n      callback: callback,\n      duration: new TimeClass(this.context, duration).toTicks(),\n      interval: new TimeClass(this.context, interval).toTicks(),\n      time: new TransportTimeClass(this.context, startTime).toTicks()\n    }); // kick it off if the Transport is started\n    // @ts-ignore\n\n    return this._addEvent(event, this._repeatedEvents);\n  };\n  /**\n   * Schedule an event that will be removed after it is invoked.\n   * @param callback The callback to invoke once.\n   * @param time The time the callback should be invoked.\n   * @returns The ID of the scheduled event.\n   */\n\n\n  Transport.prototype.scheduleOnce = function (callback, time) {\n    var event = new TransportEvent(this, {\n      callback: callback,\n      once: true,\n      time: new TransportTimeClass(this.context, time).toTicks()\n    });\n    return this._addEvent(event, this._timeline);\n  };\n  /**\n   * Clear the passed in event id from the timeline\n   * @param eventId The id of the event.\n   */\n\n\n  Transport.prototype.clear = function (eventId) {\n    if (this._scheduledEvents.hasOwnProperty(eventId)) {\n      var item = this._scheduledEvents[eventId.toString()];\n\n      item.timeline.remove(item.event);\n      item.event.dispose();\n      delete this._scheduledEvents[eventId.toString()];\n    }\n\n    return this;\n  };\n  /**\n   * Add an event to the correct timeline. Keep track of the\n   * timeline it was added to.\n   * @returns the event id which was just added\n   */\n\n\n  Transport.prototype._addEvent = function (event, timeline) {\n    this._scheduledEvents[event.id.toString()] = {\n      event: event,\n      timeline: timeline\n    };\n    timeline.add(event);\n    return event.id;\n  };\n  /**\n   * Remove scheduled events from the timeline after\n   * the given time. Repeated events will be removed\n   * if their startTime is after the given time\n   * @param after Clear all events after this time.\n   */\n\n\n  Transport.prototype.cancel = function (after) {\n    var _this = this;\n\n    if (after === void 0) {\n      after = 0;\n    }\n\n    var computedAfter = this.toTicks(after);\n\n    this._timeline.forEachFrom(computedAfter, function (event) {\n      return _this.clear(event.id);\n    });\n\n    this._repeatedEvents.forEachFrom(computedAfter, function (event) {\n      return _this.clear(event.id);\n    });\n\n    return this;\n  }; //-------------------------------------\n  // \tSTART/STOP/PAUSE\n  //-------------------------------------\n\n  /**\n   * Bind start/stop/pause events from the clock and emit them.\n   */\n\n\n  Transport.prototype._bindClockEvents = function () {\n    var _this = this;\n\n    this._clock.on(\"start\", function (time, offset) {\n      offset = new TicksClass(_this.context, offset).toSeconds();\n\n      _this.emit(\"start\", time, offset);\n    });\n\n    this._clock.on(\"stop\", function (time) {\n      _this.emit(\"stop\", time);\n    });\n\n    this._clock.on(\"pause\", function (time) {\n      _this.emit(\"pause\", time);\n    });\n  };\n\n  Object.defineProperty(Transport.prototype, \"state\", {\n    /**\n     * Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n     */\n    get: function () {\n      return this._clock.getStateAtTime(this.now());\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Start the transport and all sources synced to the transport.\n   * @param  time The time when the transport should start.\n   * @param  offset The timeline offset to start the transport.\n   * @example\n   * import { Transport } from \"tone\";\n   * // start the transport in one second starting at beginning of the 5th measure.\n   * Transport.start(\"+1\", \"4:0:0\");\n   */\n\n  Transport.prototype.start = function (time, offset) {\n    var offsetTicks;\n\n    if (isDefined(offset)) {\n      offsetTicks = this.toTicks(offset);\n    } // start the clock\n\n\n    this._clock.start(time, offsetTicks);\n\n    return this;\n  };\n  /**\n   * Stop the transport and all sources synced to the transport.\n   * @param time The time when the transport should stop.\n   * @example\n   * import { Transport } from \"tone\";\n   * Transport.stop();\n   */\n\n\n  Transport.prototype.stop = function (time) {\n    this._clock.stop(time);\n\n    return this;\n  };\n  /**\n   * Pause the transport and all sources synced to the transport.\n   */\n\n\n  Transport.prototype.pause = function (time) {\n    this._clock.pause(time);\n\n    return this;\n  };\n  /**\n   * Toggle the current state of the transport. If it is\n   * started, it will stop it, otherwise it will start the Transport.\n   * @param  time The time of the event\n   */\n\n\n  Transport.prototype.toggle = function (time) {\n    time = this.toSeconds(time);\n\n    if (this._clock.getStateAtTime(time) !== \"started\") {\n      this.start(time);\n    } else {\n      this.stop(time);\n    }\n\n    return this;\n  };\n\n  Object.defineProperty(Transport.prototype, \"timeSignature\", {\n    //-------------------------------------\n    // \tSETTERS/GETTERS\n    //-------------------------------------\n\n    /**\n     * The time signature as just the numerator over 4.\n     * For example 4/4 would be just 4 and 6/8 would be 3.\n     * @example\n     * import { Transport } from \"tone\";\n     * // common time\n     * Transport.timeSignature = 4;\n     * // 7/8\n     * Transport.timeSignature = [7, 8];\n     * // this will be reduced to a single number\n     * Transport.timeSignature; // returns 3.5\n     */\n    get: function () {\n      return this._timeSignature;\n    },\n    set: function (timeSig) {\n      if (isArray(timeSig)) {\n        timeSig = timeSig[0] / timeSig[1] * 4;\n      }\n\n      this._timeSignature = timeSig;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Transport.prototype, \"loopStart\", {\n    /**\n     * When the Transport.loop = true, this is the starting position of the loop.\n     */\n    get: function () {\n      return new TimeClass(this.context, this._loopStart, \"i\").toSeconds();\n    },\n    set: function (startPosition) {\n      this._loopStart = this.toTicks(startPosition);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Transport.prototype, \"loopEnd\", {\n    /**\n     * When the Transport.loop = true, this is the ending position of the loop.\n     */\n    get: function () {\n      return new TimeClass(this.context, this._loopEnd, \"i\").toSeconds();\n    },\n    set: function (endPosition) {\n      this._loopEnd = this.toTicks(endPosition);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Transport.prototype, \"loop\", {\n    /**\n     * If the transport loops or not.\n     */\n    get: function () {\n      return this._loop.get(this.now());\n    },\n    set: function (loop) {\n      this._loop.set(loop, this.now());\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Set the loop start and stop at the same time.\n   * @example\n   * import { Transport } from \"tone\";\n   * // loop over the first measure\n   * Transport.setLoopPoints(0, \"1m\");\n   * Transport.loop = true;\n   */\n\n  Transport.prototype.setLoopPoints = function (startPosition, endPosition) {\n    this.loopStart = startPosition;\n    this.loopEnd = endPosition;\n    return this;\n  };\n\n  Object.defineProperty(Transport.prototype, \"swing\", {\n    /**\n     * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n     */\n    get: function () {\n      return this._swingAmount;\n    },\n    set: function (amount) {\n      // scale the values to a normal range\n      this._swingAmount = amount;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Transport.prototype, \"swingSubdivision\", {\n    /**\n     * Set the subdivision which the swing will be applied to.\n     * The default value is an 8th note. Value must be less\n     * than a quarter note.\n     */\n    get: function () {\n      return new TicksClass(this.context, this._swingTicks).toNotation();\n    },\n    set: function (subdivision) {\n      this._swingTicks = this.toTicks(subdivision);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Transport.prototype, \"position\", {\n    /**\n     * The Transport's position in Bars:Beats:Sixteenths.\n     * Setting the value will jump to that position right away.\n     */\n    get: function () {\n      var now = this.now();\n\n      var ticks = this._clock.getTicksAtTime(now);\n\n      return new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n    },\n    set: function (progress) {\n      var ticks = this.toTicks(progress);\n      this.ticks = ticks;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Transport.prototype, \"seconds\", {\n    /**\n     * The Transport's position in seconds\n     * Setting the value will jump to that position right away.\n     */\n    get: function () {\n      return this._clock.seconds;\n    },\n    set: function (s) {\n      var now = this.now();\n\n      var ticks = this._clock.frequency.timeToTicks(s, now);\n\n      this.ticks = ticks;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Transport.prototype, \"progress\", {\n    /**\n     * The Transport's loop position as a normalized value. Always\n     * returns 0 if the transport if loop is not true.\n     */\n    get: function () {\n      if (this.loop) {\n        var now = this.now();\n\n        var ticks = this._clock.getTicksAtTime(now);\n\n        return (ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n      } else {\n        return 0;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Transport.prototype, \"ticks\", {\n    /**\n     * The transports current tick position.\n     */\n    get: function () {\n      return this._clock.ticks;\n    },\n    set: function (t) {\n      if (this._clock.ticks !== t) {\n        var now = this.now(); // stop everything synced to the transport\n\n        if (this.state === \"started\") {\n          var ticks = this._clock.getTicksAtTime(now); // schedule to start on the next tick, #573\n\n\n          var time = this._clock.getTimeOfTick(Math.ceil(ticks));\n\n          this.emit(\"stop\", time);\n\n          this._clock.setTicksAtTime(t, time); // restart it with the new time\n\n\n          this.emit(\"start\", time, this._clock.getSecondsAtTime(time));\n        } else {\n          this._clock.setTicksAtTime(t, now);\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Get the clock's ticks at the given time.\n   * @param  time  When to get the tick value\n   * @return The tick value at the given time.\n   */\n\n  Transport.prototype.getTicksAtTime = function (time) {\n    return Math.round(this._clock.getTicksAtTime(time));\n  };\n  /**\n   * Return the elapsed seconds at the given time.\n   * @param  time  When to get the elapsed seconds\n   * @return  The number of elapsed seconds\n   */\n\n\n  Transport.prototype.getSecondsAtTime = function (time) {\n    return this._clock.getSecondsAtTime(time);\n  };\n\n  Object.defineProperty(Transport.prototype, \"PPQ\", {\n    /**\n     * Pulses Per Quarter note. This is the smallest resolution\n     * the Transport timing supports. This should be set once\n     * on initialization and not set again. Changing this value\n     * after other objects have been created can cause problems.\n     */\n    get: function () {\n      return this._clock.frequency.multiplier;\n    },\n    set: function (ppq) {\n      this._clock.frequency.multiplier = ppq;\n    },\n    enumerable: true,\n    configurable: true\n  }); //-------------------------------------\n  // \tSYNCING\n  //-------------------------------------\n\n  /**\n   * Returns the time aligned to the next subdivision\n   * of the Transport. If the Transport is not started,\n   * it will return 0.\n   * Note: this will not work precisely during tempo ramps.\n   * @param  subdivision  The subdivision to quantize to\n   * @return  The context time of the next subdivision.\n   * @example\n   * import { Transport } from \"tone\";\n   * // the transport must be started, otherwise returns 0\n   * Transport.start();\n   * Transport.nextSubdivision(\"4n\");\n   */\n\n  Transport.prototype.nextSubdivision = function (subdivision) {\n    subdivision = this.toTicks(subdivision);\n\n    if (this.state !== \"started\") {\n      // if the transport's not started, return 0\n      return 0;\n    } else {\n      var now = this.now(); // the remainder of the current ticks and the subdivision\n\n      var transportPos = this.getTicksAtTime(now);\n      var remainingTicks = subdivision - transportPos % subdivision;\n      return this._clock.nextTickTime(remainingTicks, now);\n    }\n  };\n  /**\n   * Attaches the signal to the tempo control signal so that\n   * any changes in the tempo will change the signal in the same\n   * ratio.\n   *\n   * @param signal\n   * @param ratio Optionally pass in the ratio between the two signals.\n   * \t\t\tOtherwise it will be computed based on their current values.\n   */\n\n\n  Transport.prototype.syncSignal = function (signal, ratio) {\n    if (!ratio) {\n      // get the sync ratio\n      var now = this.now();\n\n      if (signal.getValueAtTime(now) !== 0) {\n        var bpm = this.bpm.getValueAtTime(now);\n        var computedFreq = 1 / (60 / bpm / this.PPQ);\n        ratio = signal.getValueAtTime(now) / computedFreq;\n      } else {\n        ratio = 0;\n      }\n    }\n\n    var ratioSignal = new Gain(ratio); // @ts-ignore\n\n    this.bpm.connect(ratioSignal); // @ts-ignore\n\n    ratioSignal.connect(signal._param);\n\n    this._syncedSignals.push({\n      initial: signal.value,\n      ratio: ratioSignal,\n      signal: signal\n    });\n\n    signal.value = 0;\n    return this;\n  };\n  /**\n   * Unsyncs a previously synced signal from the transport's control.\n   * See Transport.syncSignal.\n   */\n\n\n  Transport.prototype.unsyncSignal = function (signal) {\n    for (var i = this._syncedSignals.length - 1; i >= 0; i--) {\n      var syncedSignal = this._syncedSignals[i];\n\n      if (syncedSignal.signal === signal) {\n        syncedSignal.ratio.dispose();\n        syncedSignal.signal.value = syncedSignal.initial;\n\n        this._syncedSignals.splice(i, 1);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Clean up.\n   */\n\n\n  Transport.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._clock.dispose();\n\n    writable(this, \"bpm\");\n\n    this._timeline.dispose();\n\n    this._repeatedEvents.dispose();\n\n    return this;\n  };\n\n  return Transport;\n}(ToneWithContext);\n\nexport { Transport };\nEmitter.mixin(Transport); //-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(function (context) {\n  context.transport = new Transport({\n    context: context\n  });\n});\nonContextClose(function (context) {\n  context.transport.dispose();\n});","map":{"version":3,"sources":["../../../../Tone/core/clock/Transport.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { TimeClass } from \"../../core/type/Time\";\nimport { TimelineValue } from \"../../core/util/TimelineValue\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\nimport { Gain } from \"../context/Gain\";\nimport { ToneWithContext } from \"../context/ToneWithContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { readOnly, writable } from \"../util/Interface\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isArray, isDefined } from \"../util/TypeCheck\";\nimport { Clock } from \"./Clock\";\nimport { TransportEvent } from \"./TransportEvent\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent\";\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * import { Oscillator, Transport } from \"tone\";\n * const osc = new Oscillator().toDestination();\n * // repeated event every 8th note\n * Transport.scheduleRepeat((time) => {\n * \t// use the callback time to schedule events\n * \tosc.start(time).stop(time + 0.1);\n * }, \"8n\");\n * // transport must be started before it starts invoking events\n * Transport.start();\n * @category Core\n */\nvar Transport = /** @class */ (function (_super) {\n    tslib_1.__extends(Transport, _super);\n    function Transport() {\n        var _this = _super.call(this, optionsFromArguments(Transport.getDefaults(), arguments)) || this;\n        _this.name = \"Transport\";\n        //-------------------------------------\n        // \tLOOPING\n        //-------------------------------------\n        /**\n         * If the transport loops or not.\n         */\n        _this._loop = new TimelineValue(false);\n        /**\n         * The loop start position in ticks\n         */\n        _this._loopStart = 0;\n        /**\n         * The loop end position in ticks\n         */\n        _this._loopEnd = 0;\n        //-------------------------------------\n        // \tTIMELINE EVENTS\n        //-------------------------------------\n        /**\n         * All the events in an object to keep track by ID\n         */\n        _this._scheduledEvents = {};\n        /**\n         * The scheduled events.\n         */\n        _this._timeline = new Timeline();\n        /**\n         * Repeated events\n         */\n        _this._repeatedEvents = new IntervalTimeline();\n        /**\n         * All of the synced Signals\n         */\n        _this._syncedSignals = [];\n        /**\n         * The swing amount\n         */\n        _this._swingAmount = 0;\n        var options = optionsFromArguments(Transport.getDefaults(), arguments);\n        // CLOCK/TEMPO\n        _this._ppq = options.ppq;\n        _this._clock = new Clock({\n            callback: _this._processTick.bind(_this),\n            context: _this.context,\n            frequency: 0,\n            units: \"bpm\",\n        });\n        _this._bindClockEvents();\n        _this.bpm = _this._clock.frequency;\n        _this._clock.frequency.multiplier = options.ppq;\n        _this.bpm.setValueAtTime(options.bpm, 0);\n        readOnly(_this, \"bpm\");\n        _this._timeSignature = options.timeSignature;\n        // SWING\n        _this._swingTicks = options.ppq / 2; // 8n\n        return _this;\n    }\n    Transport.getDefaults = function () {\n        return Object.assign(ToneWithContext.getDefaults(), {\n            bpm: 120,\n            loopEnd: \"4m\",\n            loopStart: 0,\n            ppq: 192,\n            swing: 0,\n            swingSubdivision: \"8n\",\n            timeSignature: 4,\n        });\n    };\n    //-------------------------------------\n    // \tTICKS\n    //-------------------------------------\n    /**\n     * called on every tick\n     * @param  tickTime clock relative tick time\n     */\n    Transport.prototype._processTick = function (tickTime, ticks) {\n        // handle swing\n        if (this._swingAmount > 0 &&\n            ticks % this._ppq !== 0 && // not on a downbeat\n            ticks % (this._swingTicks * 2) !== 0) {\n            // add some swing\n            var progress = (ticks % (this._swingTicks * 2)) / (this._swingTicks * 2);\n            var amount = Math.sin((progress) * Math.PI) * this._swingAmount;\n            tickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;\n        }\n        // do the loop test\n        if (this._loop.get(tickTime)) {\n            if (ticks >= this._loopEnd) {\n                this.emit(\"loopEnd\", tickTime);\n                this._clock.setTicksAtTime(this._loopStart, tickTime);\n                ticks = this._loopStart;\n                this.emit(\"loopStart\", tickTime, this._clock.getSecondsAtTime(tickTime));\n                this.emit(\"loop\", tickTime);\n            }\n        }\n        // invoke the timeline events scheduled on this tick\n        this._timeline.forEachAtTime(ticks, function (event) { return event.invoke(tickTime); });\n    };\n    //-------------------------------------\n    // \tSCHEDULABLE EVENTS\n    //-------------------------------------\n    /**\n     * Schedule an event along the timeline.\n     * @param callback The callback to be invoked at the time.\n     * @param time The time to invoke the callback at.\n     * @return The id of the event which can be used for canceling the event.\n     * @example\n     * import { Transport } from \"tone\";\n     * // schedule an event on the 16th measure\n     * Transport.schedule((time) => {\n     * \t// invoked on measure 16\n     * \tconsole.log(\"measure 16!\");\n     * }, \"16:0:0\");\n     */\n    Transport.prototype.schedule = function (callback, time) {\n        var event = new TransportEvent(this, {\n            callback: callback,\n            time: new TransportTimeClass(this.context, time).toTicks(),\n        });\n        return this._addEvent(event, this._timeline);\n    };\n    /**\n     * Schedule a repeated event along the timeline. The event will fire\n     * at the `interval` starting at the `startTime` and for the specified\n     * `duration`.\n     * @param  callback   The callback to invoke.\n     * @param  interval   The duration between successive callbacks. Must be a positive number.\n     * @param  startTime  When along the timeline the events should start being invoked.\n     * @param  duration How long the event should repeat.\n     * @return  The ID of the scheduled event. Use this to cancel the event.\n     * @example\n     * import { Oscillator, Transport } from \"tone\";\n     * const osc = new Oscillator().toDestination().start();\n     * // a callback invoked every eighth note after the first measure\n     * Transport.scheduleRepeat((time) => {\n     * \tosc.start(time).stop(time + 0.1);\n     * }, \"8n\", \"1m\");\n     */\n    Transport.prototype.scheduleRepeat = function (callback, interval, startTime, duration) {\n        if (duration === void 0) { duration = Infinity; }\n        var event = new TransportRepeatEvent(this, {\n            callback: callback,\n            duration: new TimeClass(this.context, duration).toTicks(),\n            interval: new TimeClass(this.context, interval).toTicks(),\n            time: new TransportTimeClass(this.context, startTime).toTicks(),\n        });\n        // kick it off if the Transport is started\n        // @ts-ignore\n        return this._addEvent(event, this._repeatedEvents);\n    };\n    /**\n     * Schedule an event that will be removed after it is invoked.\n     * @param callback The callback to invoke once.\n     * @param time The time the callback should be invoked.\n     * @returns The ID of the scheduled event.\n     */\n    Transport.prototype.scheduleOnce = function (callback, time) {\n        var event = new TransportEvent(this, {\n            callback: callback,\n            once: true,\n            time: new TransportTimeClass(this.context, time).toTicks(),\n        });\n        return this._addEvent(event, this._timeline);\n    };\n    /**\n     * Clear the passed in event id from the timeline\n     * @param eventId The id of the event.\n     */\n    Transport.prototype.clear = function (eventId) {\n        if (this._scheduledEvents.hasOwnProperty(eventId)) {\n            var item = this._scheduledEvents[eventId.toString()];\n            item.timeline.remove(item.event);\n            item.event.dispose();\n            delete this._scheduledEvents[eventId.toString()];\n        }\n        return this;\n    };\n    /**\n     * Add an event to the correct timeline. Keep track of the\n     * timeline it was added to.\n     * @returns the event id which was just added\n     */\n    Transport.prototype._addEvent = function (event, timeline) {\n        this._scheduledEvents[event.id.toString()] = {\n            event: event,\n            timeline: timeline,\n        };\n        timeline.add(event);\n        return event.id;\n    };\n    /**\n     * Remove scheduled events from the timeline after\n     * the given time. Repeated events will be removed\n     * if their startTime is after the given time\n     * @param after Clear all events after this time.\n     */\n    Transport.prototype.cancel = function (after) {\n        var _this = this;\n        if (after === void 0) { after = 0; }\n        var computedAfter = this.toTicks(after);\n        this._timeline.forEachFrom(computedAfter, function (event) { return _this.clear(event.id); });\n        this._repeatedEvents.forEachFrom(computedAfter, function (event) { return _this.clear(event.id); });\n        return this;\n    };\n    //-------------------------------------\n    // \tSTART/STOP/PAUSE\n    //-------------------------------------\n    /**\n     * Bind start/stop/pause events from the clock and emit them.\n     */\n    Transport.prototype._bindClockEvents = function () {\n        var _this = this;\n        this._clock.on(\"start\", function (time, offset) {\n            offset = new TicksClass(_this.context, offset).toSeconds();\n            _this.emit(\"start\", time, offset);\n        });\n        this._clock.on(\"stop\", function (time) {\n            _this.emit(\"stop\", time);\n        });\n        this._clock.on(\"pause\", function (time) {\n            _this.emit(\"pause\", time);\n        });\n    };\n    Object.defineProperty(Transport.prototype, \"state\", {\n        /**\n         * Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n         */\n        get: function () {\n            return this._clock.getStateAtTime(this.now());\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Start the transport and all sources synced to the transport.\n     * @param  time The time when the transport should start.\n     * @param  offset The timeline offset to start the transport.\n     * @example\n     * import { Transport } from \"tone\";\n     * // start the transport in one second starting at beginning of the 5th measure.\n     * Transport.start(\"+1\", \"4:0:0\");\n     */\n    Transport.prototype.start = function (time, offset) {\n        var offsetTicks;\n        if (isDefined(offset)) {\n            offsetTicks = this.toTicks(offset);\n        }\n        // start the clock\n        this._clock.start(time, offsetTicks);\n        return this;\n    };\n    /**\n     * Stop the transport and all sources synced to the transport.\n     * @param time The time when the transport should stop.\n     * @example\n     * import { Transport } from \"tone\";\n     * Transport.stop();\n     */\n    Transport.prototype.stop = function (time) {\n        this._clock.stop(time);\n        return this;\n    };\n    /**\n     * Pause the transport and all sources synced to the transport.\n     */\n    Transport.prototype.pause = function (time) {\n        this._clock.pause(time);\n        return this;\n    };\n    /**\n     * Toggle the current state of the transport. If it is\n     * started, it will stop it, otherwise it will start the Transport.\n     * @param  time The time of the event\n     */\n    Transport.prototype.toggle = function (time) {\n        time = this.toSeconds(time);\n        if (this._clock.getStateAtTime(time) !== \"started\") {\n            this.start(time);\n        }\n        else {\n            this.stop(time);\n        }\n        return this;\n    };\n    Object.defineProperty(Transport.prototype, \"timeSignature\", {\n        //-------------------------------------\n        // \tSETTERS/GETTERS\n        //-------------------------------------\n        /**\n         * The time signature as just the numerator over 4.\n         * For example 4/4 would be just 4 and 6/8 would be 3.\n         * @example\n         * import { Transport } from \"tone\";\n         * // common time\n         * Transport.timeSignature = 4;\n         * // 7/8\n         * Transport.timeSignature = [7, 8];\n         * // this will be reduced to a single number\n         * Transport.timeSignature; // returns 3.5\n         */\n        get: function () {\n            return this._timeSignature;\n        },\n        set: function (timeSig) {\n            if (isArray(timeSig)) {\n                timeSig = (timeSig[0] / timeSig[1]) * 4;\n            }\n            this._timeSignature = timeSig;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Transport.prototype, \"loopStart\", {\n        /**\n         * When the Transport.loop = true, this is the starting position of the loop.\n         */\n        get: function () {\n            return new TimeClass(this.context, this._loopStart, \"i\").toSeconds();\n        },\n        set: function (startPosition) {\n            this._loopStart = this.toTicks(startPosition);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Transport.prototype, \"loopEnd\", {\n        /**\n         * When the Transport.loop = true, this is the ending position of the loop.\n         */\n        get: function () {\n            return new TimeClass(this.context, this._loopEnd, \"i\").toSeconds();\n        },\n        set: function (endPosition) {\n            this._loopEnd = this.toTicks(endPosition);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Transport.prototype, \"loop\", {\n        /**\n         * If the transport loops or not.\n         */\n        get: function () {\n            return this._loop.get(this.now());\n        },\n        set: function (loop) {\n            this._loop.set(loop, this.now());\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Set the loop start and stop at the same time.\n     * @example\n     * import { Transport } from \"tone\";\n     * // loop over the first measure\n     * Transport.setLoopPoints(0, \"1m\");\n     * Transport.loop = true;\n     */\n    Transport.prototype.setLoopPoints = function (startPosition, endPosition) {\n        this.loopStart = startPosition;\n        this.loopEnd = endPosition;\n        return this;\n    };\n    Object.defineProperty(Transport.prototype, \"swing\", {\n        /**\n         * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n         */\n        get: function () {\n            return this._swingAmount;\n        },\n        set: function (amount) {\n            // scale the values to a normal range\n            this._swingAmount = amount;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Transport.prototype, \"swingSubdivision\", {\n        /**\n         * Set the subdivision which the swing will be applied to.\n         * The default value is an 8th note. Value must be less\n         * than a quarter note.\n         */\n        get: function () {\n            return new TicksClass(this.context, this._swingTicks).toNotation();\n        },\n        set: function (subdivision) {\n            this._swingTicks = this.toTicks(subdivision);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Transport.prototype, \"position\", {\n        /**\n         * The Transport's position in Bars:Beats:Sixteenths.\n         * Setting the value will jump to that position right away.\n         */\n        get: function () {\n            var now = this.now();\n            var ticks = this._clock.getTicksAtTime(now);\n            return new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n        },\n        set: function (progress) {\n            var ticks = this.toTicks(progress);\n            this.ticks = ticks;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Transport.prototype, \"seconds\", {\n        /**\n         * The Transport's position in seconds\n         * Setting the value will jump to that position right away.\n         */\n        get: function () {\n            return this._clock.seconds;\n        },\n        set: function (s) {\n            var now = this.now();\n            var ticks = this._clock.frequency.timeToTicks(s, now);\n            this.ticks = ticks;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Transport.prototype, \"progress\", {\n        /**\n         * The Transport's loop position as a normalized value. Always\n         * returns 0 if the transport if loop is not true.\n         */\n        get: function () {\n            if (this.loop) {\n                var now = this.now();\n                var ticks = this._clock.getTicksAtTime(now);\n                return (ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n            }\n            else {\n                return 0;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Transport.prototype, \"ticks\", {\n        /**\n         * The transports current tick position.\n         */\n        get: function () {\n            return this._clock.ticks;\n        },\n        set: function (t) {\n            if (this._clock.ticks !== t) {\n                var now = this.now();\n                // stop everything synced to the transport\n                if (this.state === \"started\") {\n                    var ticks = this._clock.getTicksAtTime(now);\n                    // schedule to start on the next tick, #573\n                    var time = this._clock.getTimeOfTick(Math.ceil(ticks));\n                    this.emit(\"stop\", time);\n                    this._clock.setTicksAtTime(t, time);\n                    // restart it with the new time\n                    this.emit(\"start\", time, this._clock.getSecondsAtTime(time));\n                }\n                else {\n                    this._clock.setTicksAtTime(t, now);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Get the clock's ticks at the given time.\n     * @param  time  When to get the tick value\n     * @return The tick value at the given time.\n     */\n    Transport.prototype.getTicksAtTime = function (time) {\n        return Math.round(this._clock.getTicksAtTime(time));\n    };\n    /**\n     * Return the elapsed seconds at the given time.\n     * @param  time  When to get the elapsed seconds\n     * @return  The number of elapsed seconds\n     */\n    Transport.prototype.getSecondsAtTime = function (time) {\n        return this._clock.getSecondsAtTime(time);\n    };\n    Object.defineProperty(Transport.prototype, \"PPQ\", {\n        /**\n         * Pulses Per Quarter note. This is the smallest resolution\n         * the Transport timing supports. This should be set once\n         * on initialization and not set again. Changing this value\n         * after other objects have been created can cause problems.\n         */\n        get: function () {\n            return this._clock.frequency.multiplier;\n        },\n        set: function (ppq) {\n            this._clock.frequency.multiplier = ppq;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    //-------------------------------------\n    // \tSYNCING\n    //-------------------------------------\n    /**\n     * Returns the time aligned to the next subdivision\n     * of the Transport. If the Transport is not started,\n     * it will return 0.\n     * Note: this will not work precisely during tempo ramps.\n     * @param  subdivision  The subdivision to quantize to\n     * @return  The context time of the next subdivision.\n     * @example\n     * import { Transport } from \"tone\";\n     * // the transport must be started, otherwise returns 0\n     * Transport.start();\n     * Transport.nextSubdivision(\"4n\");\n     */\n    Transport.prototype.nextSubdivision = function (subdivision) {\n        subdivision = this.toTicks(subdivision);\n        if (this.state !== \"started\") {\n            // if the transport's not started, return 0\n            return 0;\n        }\n        else {\n            var now = this.now();\n            // the remainder of the current ticks and the subdivision\n            var transportPos = this.getTicksAtTime(now);\n            var remainingTicks = subdivision - transportPos % subdivision;\n            return this._clock.nextTickTime(remainingTicks, now);\n        }\n    };\n    /**\n     * Attaches the signal to the tempo control signal so that\n     * any changes in the tempo will change the signal in the same\n     * ratio.\n     *\n     * @param signal\n     * @param ratio Optionally pass in the ratio between the two signals.\n     * \t\t\tOtherwise it will be computed based on their current values.\n     */\n    Transport.prototype.syncSignal = function (signal, ratio) {\n        if (!ratio) {\n            // get the sync ratio\n            var now = this.now();\n            if (signal.getValueAtTime(now) !== 0) {\n                var bpm = this.bpm.getValueAtTime(now);\n                var computedFreq = 1 / (60 / bpm / this.PPQ);\n                ratio = signal.getValueAtTime(now) / computedFreq;\n            }\n            else {\n                ratio = 0;\n            }\n        }\n        var ratioSignal = new Gain(ratio);\n        // @ts-ignore\n        this.bpm.connect(ratioSignal);\n        // @ts-ignore\n        ratioSignal.connect(signal._param);\n        this._syncedSignals.push({\n            initial: signal.value,\n            ratio: ratioSignal,\n            signal: signal,\n        });\n        signal.value = 0;\n        return this;\n    };\n    /**\n     * Unsyncs a previously synced signal from the transport's control.\n     * See Transport.syncSignal.\n     */\n    Transport.prototype.unsyncSignal = function (signal) {\n        for (var i = this._syncedSignals.length - 1; i >= 0; i--) {\n            var syncedSignal = this._syncedSignals[i];\n            if (syncedSignal.signal === signal) {\n                syncedSignal.ratio.dispose();\n                syncedSignal.signal.value = syncedSignal.initial;\n                this._syncedSignals.splice(i, 1);\n            }\n        }\n        return this;\n    };\n    /**\n     * Clean up.\n     */\n    Transport.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this._clock.dispose();\n        writable(this, \"bpm\");\n        this._timeline.dispose();\n        this._repeatedEvents.dispose();\n        return this;\n    };\n    return Transport;\n}(ToneWithContext));\nexport { Transport };\nEmitter.mixin(Transport);\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\nonContextInit(function (context) {\n    context.transport = new Transport({ context: context });\n});\nonContextClose(function (context) {\n    context.transport.dispose();\n});\n//# sourceMappingURL=Transport.js.map"]},"metadata":{},"sourceType":"module"}