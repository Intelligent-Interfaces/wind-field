{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { Tone } from \"../Tone\";\nimport { isUndef } from \"./TypeCheck\";\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n */\n\nvar Emitter =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Emitter, _super);\n\n  function Emitter() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.name = \"Emitter\";\n    return _this;\n  }\n  /**\n   * Bind a callback to a specific event.\n   * @param  event     The name of the event to listen for.\n   * @param  callback  The callback to invoke when the event is emitted\n   */\n\n\n  Emitter.prototype.on = function (event, callback) {\n    var _this = this; // split the event\n\n\n    var events = event.split(/\\W+/);\n    events.forEach(function (eventName) {\n      if (isUndef(_this._events)) {\n        _this._events = {};\n      }\n\n      if (!_this._events.hasOwnProperty(eventName)) {\n        _this._events[eventName] = [];\n      }\n\n      _this._events[eventName].push(callback);\n    });\n    return this;\n  };\n  /**\n   * Bind a callback which is only invoked once\n   * @param  event     The name of the event to listen for.\n   * @param  callback  The callback to invoke when the event is emitted\n   */\n\n\n  Emitter.prototype.once = function (event, callback) {\n    var _this = this;\n\n    var boundCallback = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      } // invoke the callback\n\n\n      callback.apply(void 0, tslib_1.__spread(args)); // remove the event\n\n      _this.off(event, boundCallback);\n    };\n\n    this.on(event, boundCallback);\n    return this;\n  };\n  /**\n   * Remove the event listener.\n   * @param  event     The event to stop listening to.\n   * @param  callback  The callback which was bound to the event with Emitter.on.\n   *                   If no callback is given, all callbacks events are removed.\n   */\n\n\n  Emitter.prototype.off = function (event, callback) {\n    var _this = this;\n\n    var events = event.split(/\\W+/);\n    events.forEach(function (eventName) {\n      if (isUndef(_this._events)) {\n        _this._events = {};\n      }\n\n      if (_this._events.hasOwnProperty(event)) {\n        if (isUndef(callback)) {\n          _this._events[event] = [];\n        } else {\n          var eventList = _this._events[event];\n\n          for (var i = 0; i < eventList.length; i++) {\n            if (eventList[i] === callback) {\n              eventList.splice(i, 1);\n            }\n          }\n        }\n      }\n    });\n    return this;\n  };\n  /**\n   * Invoke all of the callbacks bound to the event\n   * with any arguments passed in.\n   * @param  event  The name of the event.\n   * @param args The arguments to pass to the functions listening.\n   */\n\n\n  Emitter.prototype.emit = function (event) {\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    if (this._events) {\n      if (this._events.hasOwnProperty(event)) {\n        var eventList = this._events[event].slice(0);\n\n        for (var i = 0, len = eventList.length; i < len; i++) {\n          eventList[i].apply(this, args);\n        }\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Add Emitter functions (on/off/emit) to the object\n   */\n\n\n  Emitter.mixin = function (constr) {\n    // instance._events = {};\n    [\"on\", \"once\", \"off\", \"emit\"].forEach(function (name) {\n      var property = Object.getOwnPropertyDescriptor(Emitter.prototype, name);\n      Object.defineProperty(constr.prototype, name, property);\n    });\n  };\n  /**\n   * Clean up\n   */\n\n\n  Emitter.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._events = undefined;\n    return this;\n  };\n\n  return Emitter;\n}(Tone);\n\nexport { Emitter };","map":{"version":3,"sources":["../../../../Tone/core/util/Emitter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { Tone } from \"../Tone\";\nimport { isUndef } from \"./TypeCheck\";\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n */\nvar Emitter = /** @class */ (function (_super) {\n    tslib_1.__extends(Emitter, _super);\n    function Emitter() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.name = \"Emitter\";\n        return _this;\n    }\n    /**\n     * Bind a callback to a specific event.\n     * @param  event     The name of the event to listen for.\n     * @param  callback  The callback to invoke when the event is emitted\n     */\n    Emitter.prototype.on = function (event, callback) {\n        var _this = this;\n        // split the event\n        var events = event.split(/\\W+/);\n        events.forEach(function (eventName) {\n            if (isUndef(_this._events)) {\n                _this._events = {};\n            }\n            if (!_this._events.hasOwnProperty(eventName)) {\n                _this._events[eventName] = [];\n            }\n            _this._events[eventName].push(callback);\n        });\n        return this;\n    };\n    /**\n     * Bind a callback which is only invoked once\n     * @param  event     The name of the event to listen for.\n     * @param  callback  The callback to invoke when the event is emitted\n     */\n    Emitter.prototype.once = function (event, callback) {\n        var _this = this;\n        var boundCallback = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            // invoke the callback\n            callback.apply(void 0, tslib_1.__spread(args));\n            // remove the event\n            _this.off(event, boundCallback);\n        };\n        this.on(event, boundCallback);\n        return this;\n    };\n    /**\n     * Remove the event listener.\n     * @param  event     The event to stop listening to.\n     * @param  callback  The callback which was bound to the event with Emitter.on.\n     *                   If no callback is given, all callbacks events are removed.\n     */\n    Emitter.prototype.off = function (event, callback) {\n        var _this = this;\n        var events = event.split(/\\W+/);\n        events.forEach(function (eventName) {\n            if (isUndef(_this._events)) {\n                _this._events = {};\n            }\n            if (_this._events.hasOwnProperty(event)) {\n                if (isUndef(callback)) {\n                    _this._events[event] = [];\n                }\n                else {\n                    var eventList = _this._events[event];\n                    for (var i = 0; i < eventList.length; i++) {\n                        if (eventList[i] === callback) {\n                            eventList.splice(i, 1);\n                        }\n                    }\n                }\n            }\n        });\n        return this;\n    };\n    /**\n     * Invoke all of the callbacks bound to the event\n     * with any arguments passed in.\n     * @param  event  The name of the event.\n     * @param args The arguments to pass to the functions listening.\n     */\n    Emitter.prototype.emit = function (event) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        if (this._events) {\n            if (this._events.hasOwnProperty(event)) {\n                var eventList = this._events[event].slice(0);\n                for (var i = 0, len = eventList.length; i < len; i++) {\n                    eventList[i].apply(this, args);\n                }\n            }\n        }\n        return this;\n    };\n    /**\n     * Add Emitter functions (on/off/emit) to the object\n     */\n    Emitter.mixin = function (constr) {\n        // instance._events = {};\n        [\"on\", \"once\", \"off\", \"emit\"].forEach(function (name) {\n            var property = Object.getOwnPropertyDescriptor(Emitter.prototype, name);\n            Object.defineProperty(constr.prototype, name, property);\n        });\n    };\n    /**\n     * Clean up\n     */\n    Emitter.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this._events = undefined;\n        return this;\n    };\n    return Emitter;\n}(Tone));\nexport { Emitter };\n//# sourceMappingURL=Emitter.js.map"]},"metadata":{},"sourceType":"module"}