{"ast":null,"code":"import _slicedToArray from \"/Users/erickoduniyi/Desktop/affective_chaos_control/Emulators/wind-field/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/*! Source code licensed under Apache License 2.0. Copyright © 2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { Pt, Group } from \"./Pt\";\nimport { Util } from \"./Util\";\nimport { Num, Geom } from \"./Num\";\nexport class Color extends Pt {\n  constructor(...args) {\n    super(...args);\n    this._mode = \"rgb\";\n    this._isNorm = false;\n  }\n\n  static from(...args) {\n    let p = [1, 1, 1, 1];\n    let c = Util.getArgs(args);\n\n    for (let i = 0, len = p.length; i < len; i++) {\n      if (i < c.length) p[i] = c[i];\n    }\n\n    return new Color(p);\n  }\n\n  static fromHex(hex) {\n    if (hex[0] == \"#\") hex = hex.substr(1);\n\n    if (hex.length <= 3) {\n      let fn = i => hex[i] || \"F\";\n\n      hex = `${fn(0)}${fn(0)}${fn(1)}${fn(1)}${fn(2)}${fn(2)}`;\n    }\n\n    let alpha = 1;\n\n    if (hex.length === 8) {\n      alpha = hex.substr(6) && 0xFF / 255;\n      hex = hex.substring(0, 6);\n    }\n\n    let hexVal = parseInt(hex, 16);\n    return new Color(hexVal >> 16, hexVal >> 8 & 0xFF, hexVal & 0xFF, alpha);\n  }\n\n  static rgb(...args) {\n    return Color.from(...args).toMode(\"rgb\");\n  }\n\n  static hsl(...args) {\n    return Color.from(...args).toMode(\"hsl\");\n  }\n\n  static hsb(...args) {\n    return Color.from(...args).toMode(\"hsb\");\n  }\n\n  static lab(...args) {\n    return Color.from(...args).toMode(\"lab\");\n  }\n\n  static lch(...args) {\n    return Color.from(...args).toMode(\"lch\");\n  }\n\n  static luv(...args) {\n    return Color.from(...args).toMode(\"luv\");\n  }\n\n  static xyz(...args) {\n    return Color.from(...args).toMode(\"xyz\");\n  }\n\n  static maxValues(mode) {\n    return Color.ranges[mode].zipSlice(1).$take([0, 1, 2]);\n  }\n\n  get hex() {\n    return this.toString(\"hex\");\n  }\n\n  get rgb() {\n    return this.toString(\"rgb\");\n  }\n\n  get rgba() {\n    return this.toString(\"rgba\");\n  }\n\n  clone() {\n    let c = new Color(this);\n    c.toMode(this._mode);\n    return c;\n  }\n\n  toMode(mode, convert = false) {\n    if (convert) {\n      let fname = this._mode.toUpperCase() + \"to\" + mode.toUpperCase();\n\n      if (Color[fname]) {\n        this.to(Color[fname](this, this._isNorm, this._isNorm));\n      } else {\n        throw new Error(\"Cannot convert color with \" + fname);\n      }\n    }\n\n    this._mode = mode;\n    return this;\n  }\n\n  get mode() {\n    return this._mode;\n  }\n\n  get r() {\n    return this[0];\n  }\n\n  set r(n) {\n    this[0] = n;\n  }\n\n  get g() {\n    return this[1];\n  }\n\n  set g(n) {\n    this[1] = n;\n  }\n\n  get b() {\n    return this[2];\n  }\n\n  set b(n) {\n    this[2] = n;\n  }\n\n  get h() {\n    return this._mode == \"lch\" ? this[2] : this[0];\n  }\n\n  set h(n) {\n    let i = this._mode == \"lch\" ? 2 : 0;\n    this[i] = n;\n  }\n\n  get s() {\n    return this[1];\n  }\n\n  set s(n) {\n    this[1] = n;\n  }\n\n  get l() {\n    return this._mode == \"hsl\" ? this[2] : this[0];\n  }\n\n  set l(n) {\n    let i = this._mode == \"hsl\" ? 2 : 0;\n    this[i] = n;\n  }\n\n  get a() {\n    return this[1];\n  }\n\n  set a(n) {\n    this[1] = n;\n  }\n\n  get c() {\n    return this[1];\n  }\n\n  set c(n) {\n    this[1] = n;\n  }\n\n  get u() {\n    return this[1];\n  }\n\n  set u(n) {\n    this[1] = n;\n  }\n\n  get v() {\n    return this[2];\n  }\n\n  set v(n) {\n    this[2] = n;\n  }\n\n  set alpha(n) {\n    if (this.length > 3) this[3] = n;\n  }\n\n  get alpha() {\n    return this.length > 3 ? this[3] : 1;\n  }\n\n  get normalized() {\n    return this._isNorm;\n  }\n\n  set normalized(b) {\n    this._isNorm = b;\n  }\n\n  normalize(toNorm = true) {\n    if (this._isNorm == toNorm) return this;\n    let ranges = Color.ranges[this._mode];\n\n    for (let i = 0; i < 3; i++) {\n      this[i] = !toNorm ? Num.mapToRange(this[i], 0, 1, ranges[i][0], ranges[i][1]) : Num.mapToRange(this[i], ranges[i][0], ranges[i][1], 0, 1);\n    }\n\n    this._isNorm = toNorm;\n    return this;\n  }\n\n  $normalize(toNorm = true) {\n    return this.clone().normalize(toNorm);\n  }\n\n  toString(format = \"mode\") {\n    if (format == \"hex\") {\n      let _hex = n => {\n        let s = Math.floor(n).toString(16);\n        return s.length < 2 ? '0' + s : s;\n      };\n\n      return `#${_hex(this[0])}${_hex(this[1])}${_hex(this[2])}`;\n    } else if (format == \"rgba\") {\n      return `rgba(${Math.floor(this[0])},${Math.floor(this[1])},${Math.floor(this[2])},${this.alpha}`;\n    } else if (format == \"rgb\") {\n      return `rgb(${Math.floor(this[0])},${Math.floor(this[1])},${Math.floor(this[2])}`;\n    } else {\n      return `${this._mode}(${this[0]},${this[1]},${this[2]},${this.alpha})`;\n    }\n  }\n\n  static RGBtoHSL(rgb, normalizedInput = false, normalizedOutput = false) {\n    let _ref = !normalizedInput ? rgb.$normalize() : rgb,\n        _ref2 = _slicedToArray(_ref, 3),\n        r = _ref2[0],\n        g = _ref2[1],\n        b = _ref2[2];\n\n    let max = Math.max(r, g, b);\n    let min = Math.min(r, g, b);\n    let h = (max + min) / 2;\n    let s = h;\n    let l = h;\n\n    if (max == min) {\n      h = 0;\n      s = 0;\n    } else {\n      let d = max - min;\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n      h = 0;\n\n      if (max === r) {\n        h = (g - b) / d + (g < b ? 6 : 0);\n      } else if (max === g) {\n        h = (b - r) / d + 2;\n      } else if (max === b) {\n        h = (r - g) / d + 4;\n      }\n    }\n\n    return Color.hsl(normalizedOutput ? h / 60 : h * 60, s, l, rgb.alpha);\n  }\n\n  static HSLtoRGB(hsl, normalizedInput = false, normalizedOutput = false) {\n    let _hsl = _slicedToArray(hsl, 3),\n        h = _hsl[0],\n        s = _hsl[1],\n        l = _hsl[2];\n\n    if (!normalizedInput) h = h / 360;\n    if (s == 0) return Color.rgb(l * 255, l * 255, l * 255, hsl.alpha);\n    let q = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n    let p = 2 * l - q;\n\n    let convert = t => {\n      t = t < 0 ? t + 1 : t > 1 ? t - 1 : t;\n\n      if (t * 6 < 1) {\n        return p + (q - p) * t * 6;\n      } else if (t * 2 < 1) {\n        return q;\n      } else if (t * 3 < 2) {\n        return p + (q - p) * (2 / 3 - t) * 6;\n      } else {\n        return p;\n      }\n    };\n\n    let sc = normalizedOutput ? 1 : 255;\n    return Color.rgb(sc * convert(h + 1 / 3), sc * convert(h), sc * convert(h - 1 / 3), hsl.alpha);\n  }\n\n  static RGBtoHSB(rgb, normalizedInput = false, normalizedOutput = false) {\n    let _ref3 = !normalizedInput ? rgb.$normalize() : rgb,\n        _ref4 = _slicedToArray(_ref3, 3),\n        r = _ref4[0],\n        g = _ref4[1],\n        b = _ref4[2];\n\n    let max = Math.max(r, g, b);\n    let min = Math.min(r, g, b);\n    let d = max - min;\n    let h = 0;\n    let s = max === 0 ? 0 : d / max;\n    let v = max;\n\n    if (max != min) {\n      if (max === r) {\n        h = (g - b) / d + (g < b ? 6 : 0);\n      } else if (max === g) {\n        h = (b - r) / d + 2;\n      } else if (max === b) {\n        h = (r - g) / d + 4;\n      }\n    }\n\n    return Color.hsb(normalizedOutput ? h / 60 : h * 60, s, v, rgb.alpha);\n  }\n\n  static HSBtoRGB(hsb, normalizedInput = false, normalizedOutput = false) {\n    let _hsb = _slicedToArray(hsb, 3),\n        h = _hsb[0],\n        s = _hsb[1],\n        v = _hsb[2];\n\n    if (!normalizedInput) h = h / 360;\n    let i = Math.floor(h * 6);\n    let f = h * 6 - i;\n    let p = v * (1 - s);\n    let q = v * (1 - f * s);\n    let t = v * (1 - (1 - f) * s);\n    let pick = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]];\n    let c = pick[i % 6];\n    let sc = normalizedOutput ? 1 : 255;\n    return Color.rgb(sc * c[0], sc * c[1], sc * c[2], hsb.alpha);\n  }\n\n  static RGBtoLAB(rgb, normalizedInput = false, normalizedOutput = false) {\n    let c = normalizedInput ? rgb.$normalize(false) : rgb;\n    return Color.XYZtoLAB(Color.RGBtoXYZ(c), false, normalizedOutput);\n  }\n\n  static LABtoRGB(lab, normalizedInput = false, normalizedOutput = false) {\n    let c = normalizedInput ? lab.$normalize(false) : lab;\n    return Color.XYZtoRGB(Color.LABtoXYZ(c), false, normalizedOutput);\n  }\n\n  static RGBtoLCH(rgb, normalizedInput = false, normalizedOutput = false) {\n    let c = normalizedInput ? rgb.$normalize(false) : rgb;\n    return Color.LABtoLCH(Color.RGBtoLAB(c), false, normalizedOutput);\n  }\n\n  static LCHtoRGB(lch, normalizedInput = false, normalizedOutput = false) {\n    let c = normalizedInput ? lch.$normalize(false) : lch;\n    return Color.LABtoRGB(Color.LCHtoLAB(c), false, normalizedOutput);\n  }\n\n  static RGBtoLUV(rgb, normalizedInput = false, normalizedOutput = false) {\n    let c = normalizedInput ? rgb.$normalize(false) : rgb;\n    return Color.XYZtoLUV(Color.RGBtoXYZ(c), false, normalizedOutput);\n  }\n\n  static LUVtoRGB(luv, normalizedInput = false, normalizedOutput = false) {\n    let c = normalizedInput ? luv.$normalize(false) : luv;\n    return Color.XYZtoRGB(Color.LUVtoXYZ(c), false, normalizedOutput);\n  }\n\n  static RGBtoXYZ(rgb, normalizedInput = false, normalizedOutput = false) {\n    let c = !normalizedInput ? rgb.$normalize() : rgb.clone();\n\n    for (let i = 0; i < 3; i++) {\n      c[i] = c[i] > 0.04045 ? Math.pow((c[i] + 0.055) / 1.055, 2.4) : c[i] / 12.92;\n      if (!normalizedOutput) c[i] = c[i] * 100;\n    }\n\n    let cc = Color.xyz(c[0] * 0.4124564 + c[1] * 0.3575761 + c[2] * 0.1804375, c[0] * 0.2126729 + c[1] * 0.7151522 + c[2] * 0.0721750, c[0] * 0.0193339 + c[1] * 0.1191920 + c[2] * 0.9503041, rgb.alpha);\n    return normalizedOutput ? cc.normalize() : cc;\n  }\n\n  static XYZtoRGB(xyz, normalizedInput = false, normalizedOutput = false) {\n    let _ref5 = !normalizedInput ? xyz.$normalize() : xyz,\n        _ref6 = _slicedToArray(_ref5, 3),\n        x = _ref6[0],\n        y = _ref6[1],\n        z = _ref6[2];\n\n    let rgb = [x * 3.2404542 + y * -1.5371385 + z * -0.4985314, x * -0.9692660 + y * 1.8760108 + z * 0.0415560, x * 0.0556434 + y * -0.2040259 + z * 1.0572252];\n\n    for (let i = 0; i < 3; i++) {\n      rgb[i] = rgb[i] < 0 ? 0 : rgb[i] > 0.0031308 ? 1.055 * Math.pow(rgb[i], 1 / 2.4) - 0.055 : 12.92 * rgb[i];\n      rgb[i] = Math.max(0, Math.min(1, rgb[i]));\n      if (!normalizedOutput) rgb[i] = Math.round(rgb[i] * 255);\n    }\n\n    let cc = Color.rgb(rgb[0], rgb[1], rgb[2], xyz.alpha);\n    return normalizedOutput ? cc.normalize() : cc;\n  }\n\n  static XYZtoLAB(xyz, normalizedInput = false, normalizedOutput = false) {\n    let c = normalizedInput ? xyz.$normalize(false) : xyz.clone();\n    c.divide(Color.D65);\n\n    let fn = n => n > 0.008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116;\n\n    let cy = fn(c[1]);\n    let cc = Color.lab(116 * cy - 16, 500 * (fn(c[0]) - cy), 200 * (cy - fn(c[2])), xyz.alpha);\n    return normalizedOutput ? cc.normalize() : cc;\n  }\n\n  static LABtoXYZ(lab, normalizedInput = false, normalizedOutput = false) {\n    let c = normalizedInput ? lab.$normalize(false) : lab;\n    let y = (c[0] + 16) / 116;\n    let x = c[1] / 500 + y;\n    let z = y - c[2] / 200;\n\n    let fn = n => {\n      let nnn = n * n * n;\n      return nnn > 0.008856 ? nnn : (n - 16 / 116) / 7.787;\n    };\n\n    let d = Color.D65;\n    let cc = Color.xyz(Math.max(0, d[0] * fn(x)), Math.max(0, d[1] * fn(y)), Math.max(0, d[2] * fn(z)), lab.alpha);\n    return normalizedOutput ? cc.normalize() : cc;\n  }\n\n  static XYZtoLUV(xyz, normalizedInput = false, normalizedOutput = false) {\n    let _ref7 = normalizedInput ? xyz.$normalize(false) : xyz,\n        _ref8 = _slicedToArray(_ref7, 3),\n        x = _ref8[0],\n        y = _ref8[1],\n        z = _ref8[2];\n\n    let u = 4 * x / (x + 15 * y + 3 * z);\n    let v = 9 * y / (x + 15 * y + 3 * z);\n    y = y / 100;\n    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;\n    let refU = 4 * Color.D65[0] / (Color.D65[0] + 15 * Color.D65[1] + 3 * Color.D65[2]);\n    let refV = 9 * Color.D65[1] / (Color.D65[0] + 15 * Color.D65[1] + 3 * Color.D65[2]);\n    let L = 116 * y - 16;\n    return Color.luv(L, 13 * L * (u - refU), 13 * L * (v - refV), xyz.alpha);\n  }\n\n  static LUVtoXYZ(luv, normalizedInput = false, normalizedOutput = false) {\n    let _ref9 = normalizedInput ? luv.$normalize(false) : luv,\n        _ref10 = _slicedToArray(_ref9, 3),\n        l = _ref10[0],\n        u = _ref10[1],\n        v = _ref10[2];\n\n    let y = (l + 16) / 116;\n    let cubeY = y * y * y;\n    y = cubeY > 0.008856 ? cubeY : (y - 16 / 116) / 7.787;\n    let refU = 4 * Color.D65[0] / (Color.D65[0] + 15 * Color.D65[1] + 3 * Color.D65[2]);\n    let refV = 9 * Color.D65[1] / (Color.D65[0] + 15 * Color.D65[1] + 3 * Color.D65[2]);\n    u = u / (13 * l) + refU;\n    v = v / (13 * l) + refV;\n    y = y * 100;\n    let x = -1 * (9 * y * u) / ((u - 4) * v - u * v);\n    let z = (9 * y - 15 * v * y - v * x) / (3 * v);\n    return Color.xyz(x, y, z, luv.alpha);\n  }\n\n  static LABtoLCH(lab, normalizedInput = false, normalizedOutput = false) {\n    let c = normalizedInput ? lab.$normalize(false) : lab;\n    let h = Geom.toDegree(Geom.boundRadian(Math.atan2(c[2], c[1])));\n    return Color.lch(c[0], Math.sqrt(c[1] * c[1] + c[2] * c[2]), h, lab.alpha);\n  }\n\n  static LCHtoLAB(lch, normalizedInput = false, normalizedOutput = false) {\n    let c = normalizedInput ? lch.$normalize(false) : lch;\n    let rad = Geom.toRadian(c[2]);\n    return Color.lab(c[0], Math.cos(rad) * c[1], Math.sin(rad) * c[1], lch.alpha);\n  }\n\n}\nColor.D65 = new Pt(95.047, 100, 108.883, 1);\nColor.ranges = {\n  rgb: new Group(new Pt(0, 255), new Pt(0, 255), new Pt(0, 255)),\n  hsl: new Group(new Pt(0, 360), new Pt(0, 1), new Pt(0, 1)),\n  hsb: new Group(new Pt(0, 360), new Pt(0, 1), new Pt(0, 1)),\n  lab: new Group(new Pt(0, 100), new Pt(-128, 127), new Pt(-128, 127)),\n  lch: new Group(new Pt(0, 100), new Pt(0, 100), new Pt(0, 360)),\n  luv: new Group(new Pt(0, 100), new Pt(-134, 220), new Pt(-140, 122)),\n  xyz: new Group(new Pt(0, 100), new Pt(0, 100), new Pt(0, 100))\n};","map":{"version":3,"sources":["/Users/erickoduniyi/Desktop/affective_chaos_control/Emulators/wind-field/node_modules/pts/dist/es2015/Color.js"],"names":["Pt","Group","Util","Num","Geom","Color","constructor","args","_mode","_isNorm","from","p","c","getArgs","i","len","length","fromHex","hex","substr","fn","alpha","substring","hexVal","parseInt","rgb","toMode","hsl","hsb","lab","lch","luv","xyz","maxValues","mode","ranges","zipSlice","$take","toString","rgba","clone","convert","fname","toUpperCase","to","Error","r","n","g","b","h","s","l","a","u","v","normalized","normalize","toNorm","mapToRange","$normalize","format","_hex","Math","floor","RGBtoHSL","normalizedInput","normalizedOutput","max","min","d","HSLtoRGB","q","t","sc","RGBtoHSB","HSBtoRGB","f","pick","RGBtoLAB","XYZtoLAB","RGBtoXYZ","LABtoRGB","XYZtoRGB","LABtoXYZ","RGBtoLCH","LABtoLCH","LCHtoRGB","LCHtoLAB","RGBtoLUV","XYZtoLUV","LUVtoRGB","LUVtoXYZ","pow","cc","x","y","z","round","divide","D65","cy","nnn","refU","refV","L","cubeY","toDegree","boundRadian","atan2","sqrt","rad","toRadian","cos","sin"],"mappings":"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","sourcesContent":["/*! Source code licensed under Apache License 2.0. Copyright © 2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { Pt, Group } from \"./Pt\";\nimport { Util } from \"./Util\";\nimport { Num, Geom } from \"./Num\";\nexport class Color extends Pt {\n    constructor(...args) {\n        super(...args);\n        this._mode = \"rgb\";\n        this._isNorm = false;\n    }\n    static from(...args) {\n        let p = [1, 1, 1, 1];\n        let c = Util.getArgs(args);\n        for (let i = 0, len = p.length; i < len; i++) {\n            if (i < c.length)\n                p[i] = c[i];\n        }\n        return new Color(p);\n    }\n    static fromHex(hex) {\n        if (hex[0] == \"#\")\n            hex = hex.substr(1);\n        if (hex.length <= 3) {\n            let fn = (i) => hex[i] || \"F\";\n            hex = `${fn(0)}${fn(0)}${fn(1)}${fn(1)}${fn(2)}${fn(2)}`;\n        }\n        let alpha = 1;\n        if (hex.length === 8) {\n            alpha = hex.substr(6) && 0xFF / 255;\n            hex = hex.substring(0, 6);\n        }\n        let hexVal = parseInt(hex, 16);\n        return new Color(hexVal >> 16, hexVal >> 8 & 0xFF, hexVal & 0xFF, alpha);\n    }\n    static rgb(...args) { return Color.from(...args).toMode(\"rgb\"); }\n    static hsl(...args) { return Color.from(...args).toMode(\"hsl\"); }\n    static hsb(...args) { return Color.from(...args).toMode(\"hsb\"); }\n    static lab(...args) { return Color.from(...args).toMode(\"lab\"); }\n    static lch(...args) { return Color.from(...args).toMode(\"lch\"); }\n    static luv(...args) { return Color.from(...args).toMode(\"luv\"); }\n    static xyz(...args) { return Color.from(...args).toMode(\"xyz\"); }\n    static maxValues(mode) { return Color.ranges[mode].zipSlice(1).$take([0, 1, 2]); }\n    get hex() { return this.toString(\"hex\"); }\n    get rgb() { return this.toString(\"rgb\"); }\n    get rgba() { return this.toString(\"rgba\"); }\n    clone() {\n        let c = new Color(this);\n        c.toMode(this._mode);\n        return c;\n    }\n    toMode(mode, convert = false) {\n        if (convert) {\n            let fname = this._mode.toUpperCase() + \"to\" + mode.toUpperCase();\n            if (Color[fname]) {\n                this.to(Color[fname](this, this._isNorm, this._isNorm));\n            }\n            else {\n                throw new Error(\"Cannot convert color with \" + fname);\n            }\n        }\n        this._mode = mode;\n        return this;\n    }\n    get mode() { return this._mode; }\n    get r() { return this[0]; }\n    set r(n) { this[0] = n; }\n    get g() { return this[1]; }\n    set g(n) { this[1] = n; }\n    get b() { return this[2]; }\n    set b(n) { this[2] = n; }\n    get h() { return (this._mode == \"lch\") ? this[2] : this[0]; }\n    set h(n) {\n        let i = (this._mode == \"lch\") ? 2 : 0;\n        this[i] = n;\n    }\n    get s() { return this[1]; }\n    set s(n) { this[1] = n; }\n    get l() { return (this._mode == \"hsl\") ? this[2] : this[0]; }\n    set l(n) {\n        let i = (this._mode == \"hsl\") ? 2 : 0;\n        this[i] = n;\n    }\n    get a() { return this[1]; }\n    set a(n) { this[1] = n; }\n    get c() { return this[1]; }\n    set c(n) { this[1] = n; }\n    get u() { return this[1]; }\n    set u(n) { this[1] = n; }\n    get v() { return this[2]; }\n    set v(n) { this[2] = n; }\n    set alpha(n) { if (this.length > 3)\n        this[3] = n; }\n    get alpha() { return (this.length > 3) ? this[3] : 1; }\n    get normalized() { return this._isNorm; }\n    set normalized(b) { this._isNorm = b; }\n    normalize(toNorm = true) {\n        if (this._isNorm == toNorm)\n            return this;\n        let ranges = Color.ranges[this._mode];\n        for (let i = 0; i < 3; i++) {\n            this[i] = (!toNorm)\n                ? Num.mapToRange(this[i], 0, 1, ranges[i][0], ranges[i][1])\n                : Num.mapToRange(this[i], ranges[i][0], ranges[i][1], 0, 1);\n        }\n        this._isNorm = toNorm;\n        return this;\n    }\n    $normalize(toNorm = true) { return this.clone().normalize(toNorm); }\n    toString(format = \"mode\") {\n        if (format == \"hex\") {\n            let _hex = (n) => {\n                let s = Math.floor(n).toString(16);\n                return (s.length < 2) ? '0' + s : s;\n            };\n            return `#${_hex(this[0])}${_hex(this[1])}${_hex(this[2])}`;\n        }\n        else if (format == \"rgba\") {\n            return `rgba(${Math.floor(this[0])},${Math.floor(this[1])},${Math.floor(this[2])},${this.alpha}`;\n        }\n        else if (format == \"rgb\") {\n            return `rgb(${Math.floor(this[0])},${Math.floor(this[1])},${Math.floor(this[2])}`;\n        }\n        else {\n            return `${this._mode}(${this[0]},${this[1]},${this[2]},${this.alpha})`;\n        }\n    }\n    static RGBtoHSL(rgb, normalizedInput = false, normalizedOutput = false) {\n        let [r, g, b] = (!normalizedInput) ? rgb.$normalize() : rgb;\n        let max = Math.max(r, g, b);\n        let min = Math.min(r, g, b);\n        let h = (max + min) / 2;\n        let s = h;\n        let l = h;\n        if (max == min) {\n            h = 0;\n            s = 0;\n        }\n        else {\n            let d = max - min;\n            s = (l > 0.5) ? d / (2 - max - min) : d / (max + min);\n            h = 0;\n            if (max === r) {\n                h = (g - b) / d + ((g < b) ? 6 : 0);\n            }\n            else if (max === g) {\n                h = (b - r) / d + 2;\n            }\n            else if (max === b) {\n                h = (r - g) / d + 4;\n            }\n        }\n        return Color.hsl(((normalizedOutput) ? h / 60 : h * 60), s, l, rgb.alpha);\n    }\n    static HSLtoRGB(hsl, normalizedInput = false, normalizedOutput = false) {\n        let [h, s, l] = hsl;\n        if (!normalizedInput)\n            h = h / 360;\n        if (s == 0)\n            return Color.rgb(l * 255, l * 255, l * 255, hsl.alpha);\n        let q = (l <= 0.5) ? l * (1 + s) : l + s - (l * s);\n        let p = 2 * l - q;\n        let convert = (t) => {\n            t = (t < 0) ? t + 1 : (t > 1) ? t - 1 : t;\n            if (t * 6 < 1) {\n                return p + (q - p) * t * 6;\n            }\n            else if (t * 2 < 1) {\n                return q;\n            }\n            else if (t * 3 < 2) {\n                return p + (q - p) * ((2 / 3) - t) * 6;\n            }\n            else {\n                return p;\n            }\n        };\n        let sc = (normalizedOutput) ? 1 : 255;\n        return Color.rgb(sc * convert((h + 1 / 3)), sc * convert(h), sc * convert((h - 1 / 3)), hsl.alpha);\n    }\n    static RGBtoHSB(rgb, normalizedInput = false, normalizedOutput = false) {\n        let [r, g, b] = (!normalizedInput) ? rgb.$normalize() : rgb;\n        let max = Math.max(r, g, b);\n        let min = Math.min(r, g, b);\n        let d = max - min;\n        let h = 0;\n        let s = (max === 0) ? 0 : d / max;\n        let v = max;\n        if (max != min) {\n            if (max === r) {\n                h = (g - b) / d + ((g < b) ? 6 : 0);\n            }\n            else if (max === g) {\n                h = (b - r) / d + 2;\n            }\n            else if (max === b) {\n                h = (r - g) / d + 4;\n            }\n        }\n        return Color.hsb(((normalizedOutput) ? h / 60 : h * 60), s, v, rgb.alpha);\n    }\n    static HSBtoRGB(hsb, normalizedInput = false, normalizedOutput = false) {\n        let [h, s, v] = hsb;\n        if (!normalizedInput)\n            h = h / 360;\n        let i = Math.floor(h * 6);\n        let f = h * 6 - i;\n        let p = v * (1 - s);\n        let q = v * (1 - f * s);\n        let t = v * (1 - (1 - f) * s);\n        let pick = [\n            [v, t, p], [q, v, p], [p, v, t],\n            [p, q, v], [t, p, v], [v, p, q]\n        ];\n        let c = pick[i % 6];\n        let sc = (normalizedOutput) ? 1 : 255;\n        return Color.rgb(sc * c[0], sc * c[1], sc * c[2], hsb.alpha);\n    }\n    static RGBtoLAB(rgb, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? rgb.$normalize(false) : rgb;\n        return Color.XYZtoLAB(Color.RGBtoXYZ(c), false, normalizedOutput);\n    }\n    static LABtoRGB(lab, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? lab.$normalize(false) : lab;\n        return Color.XYZtoRGB(Color.LABtoXYZ(c), false, normalizedOutput);\n    }\n    static RGBtoLCH(rgb, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? rgb.$normalize(false) : rgb;\n        return Color.LABtoLCH(Color.RGBtoLAB(c), false, normalizedOutput);\n    }\n    static LCHtoRGB(lch, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? lch.$normalize(false) : lch;\n        return Color.LABtoRGB(Color.LCHtoLAB(c), false, normalizedOutput);\n    }\n    static RGBtoLUV(rgb, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? rgb.$normalize(false) : rgb;\n        return Color.XYZtoLUV(Color.RGBtoXYZ(c), false, normalizedOutput);\n    }\n    static LUVtoRGB(luv, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? luv.$normalize(false) : luv;\n        return Color.XYZtoRGB(Color.LUVtoXYZ(c), false, normalizedOutput);\n    }\n    static RGBtoXYZ(rgb, normalizedInput = false, normalizedOutput = false) {\n        let c = (!normalizedInput) ? rgb.$normalize() : rgb.clone();\n        for (let i = 0; i < 3; i++) {\n            c[i] = (c[i] > 0.04045) ? Math.pow((c[i] + 0.055) / 1.055, 2.4) : c[i] / 12.92;\n            if (!normalizedOutput)\n                c[i] = c[i] * 100;\n        }\n        let cc = Color.xyz(c[0] * 0.4124564 + c[1] * 0.3575761 + c[2] * 0.1804375, c[0] * 0.2126729 + c[1] * 0.7151522 + c[2] * 0.0721750, c[0] * 0.0193339 + c[1] * 0.1191920 + c[2] * 0.9503041, rgb.alpha);\n        return (normalizedOutput) ? cc.normalize() : cc;\n    }\n    static XYZtoRGB(xyz, normalizedInput = false, normalizedOutput = false) {\n        let [x, y, z] = (!normalizedInput) ? xyz.$normalize() : xyz;\n        let rgb = [\n            x * 3.2404542 + y * -1.5371385 + z * -0.4985314,\n            x * -0.9692660 + y * 1.8760108 + z * 0.0415560,\n            x * 0.0556434 + y * -0.2040259 + z * 1.0572252\n        ];\n        for (let i = 0; i < 3; i++) {\n            rgb[i] = (rgb[i] < 0) ? 0 : (rgb[i] > 0.0031308) ? (1.055 * Math.pow(rgb[i], 1 / 2.4) - 0.055) : (12.92 * rgb[i]);\n            rgb[i] = Math.max(0, Math.min(1, rgb[i]));\n            if (!normalizedOutput)\n                rgb[i] = Math.round(rgb[i] * 255);\n        }\n        let cc = Color.rgb(rgb[0], rgb[1], rgb[2], xyz.alpha);\n        return (normalizedOutput) ? cc.normalize() : cc;\n    }\n    static XYZtoLAB(xyz, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? xyz.$normalize(false) : xyz.clone();\n        c.divide(Color.D65);\n        let fn = (n) => (n > 0.008856) ? Math.pow(n, 1 / 3) : (7.787 * n) + 16 / 116;\n        let cy = fn(c[1]);\n        let cc = Color.lab((116 * cy) - 16, 500 * (fn(c[0]) - cy), 200 * (cy - fn(c[2])), xyz.alpha);\n        return (normalizedOutput) ? cc.normalize() : cc;\n    }\n    static LABtoXYZ(lab, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? lab.$normalize(false) : lab;\n        let y = (c[0] + 16) / 116;\n        let x = (c[1] / 500) + y;\n        let z = y - c[2] / 200;\n        let fn = (n) => {\n            let nnn = n * n * n;\n            return (nnn > 0.008856) ? nnn : (n - 16 / 116) / 7.787;\n        };\n        let d = Color.D65;\n        let cc = Color.xyz(Math.max(0, d[0] * fn(x)), Math.max(0, d[1] * fn(y)), Math.max(0, d[2] * fn(z)), lab.alpha);\n        return (normalizedOutput) ? cc.normalize() : cc;\n    }\n    static XYZtoLUV(xyz, normalizedInput = false, normalizedOutput = false) {\n        let [x, y, z] = (normalizedInput) ? xyz.$normalize(false) : xyz;\n        let u = (4 * x) / (x + (15 * y) + (3 * z));\n        let v = (9 * y) / (x + (15 * y) + (3 * z));\n        y = y / 100;\n        y = (y > 0.008856) ? Math.pow(y, 1 / 3) : (7.787 * y + 16 / 116);\n        let refU = (4 * Color.D65[0]) / (Color.D65[0] + (15 * Color.D65[1]) + (3 * Color.D65[2]));\n        let refV = (9 * Color.D65[1]) / (Color.D65[0] + (15 * Color.D65[1]) + (3 * Color.D65[2]));\n        let L = (116 * y) - 16;\n        return Color.luv(L, 13 * L * (u - refU), 13 * L * (v - refV), xyz.alpha);\n    }\n    static LUVtoXYZ(luv, normalizedInput = false, normalizedOutput = false) {\n        let [l, u, v] = (normalizedInput) ? luv.$normalize(false) : luv;\n        let y = (l + 16) / 116;\n        let cubeY = y * y * y;\n        y = (cubeY > 0.008856) ? cubeY : (y - 16 / 116) / 7.787;\n        let refU = (4 * Color.D65[0]) / (Color.D65[0] + (15 * Color.D65[1]) + (3 * Color.D65[2]));\n        let refV = (9 * Color.D65[1]) / (Color.D65[0] + (15 * Color.D65[1]) + (3 * Color.D65[2]));\n        u = u / (13 * l) + refU;\n        v = v / (13 * l) + refV;\n        y = y * 100;\n        let x = -1 * (9 * y * u) / ((u - 4) * v - u * v);\n        let z = (9 * y - (15 * v * y) - (v * x)) / (3 * v);\n        return Color.xyz(x, y, z, luv.alpha);\n    }\n    static LABtoLCH(lab, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? lab.$normalize(false) : lab;\n        let h = Geom.toDegree(Geom.boundRadian(Math.atan2(c[2], c[1])));\n        return Color.lch(c[0], Math.sqrt(c[1] * c[1] + c[2] * c[2]), h, lab.alpha);\n    }\n    static LCHtoLAB(lch, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? lch.$normalize(false) : lch;\n        let rad = Geom.toRadian(c[2]);\n        return Color.lab(c[0], Math.cos(rad) * c[1], Math.sin(rad) * c[1], lch.alpha);\n    }\n}\nColor.D65 = new Pt(95.047, 100, 108.883, 1);\nColor.ranges = {\n    rgb: new Group(new Pt(0, 255), new Pt(0, 255), new Pt(0, 255)),\n    hsl: new Group(new Pt(0, 360), new Pt(0, 1), new Pt(0, 1)),\n    hsb: new Group(new Pt(0, 360), new Pt(0, 1), new Pt(0, 1)),\n    lab: new Group(new Pt(0, 100), new Pt(-128, 127), new Pt(-128, 127)),\n    lch: new Group(new Pt(0, 100), new Pt(0, 100), new Pt(0, 360)),\n    luv: new Group(new Pt(0, 100), new Pt(-134, 220), new Pt(-140, 122)),\n    xyz: new Group(new Pt(0, 100), new Pt(0, 100), new Pt(0, 100))\n};\n//# sourceMappingURL=Color.js.map"]},"metadata":{},"sourceType":"module"}