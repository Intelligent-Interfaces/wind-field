{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { getContext, setContext } from \"../Global\";\nimport { OfflineContext } from \"./OfflineContext\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n/**\n * Generate a buffer by rendering all of the Tone.js code within the callback using the OfflineAudioContext.\n * The OfflineAudioContext is capable of rendering much faster than real time in many cases.\n * The callback function also passes in an offline instance of [[Context]] which can be used\n * to schedule events along the Transport.\n * @param  callback  All Tone.js nodes which are created and scheduled within this callback are recorded into the output Buffer.\n * @param  duration     the amount of time to record for.\n * @return  The promise which is invoked with the ToneAudioBuffer of the recorded output.\n * @example\n * import { Offline, Oscillator } from \"tone\";\n * // render 2 seconds of the oscillator\n * Offline(() => {\n * \t// only nodes created in this callback will be recorded\n * \tconst oscillator = new Oscillator().toDestination().start(0);\n * }, 2).then((buffer) => {\n * \t// do something with the output buffer\n * \tconsole.log(buffer);\n * });\n * @example\n * import { Offline, Oscillator } from \"tone\";\n * // can also schedule events along the Transport\n * // using the passed in Offline Transport\n * Offline(({ transport }) => {\n * \tconst osc = new Oscillator().toDestination();\n * \ttransport.schedule(time => {\n * \t\tosc.start(time).stop(time + 0.1);\n * \t}, 1);\n * \t// make sure to start the transport\n * \ttransport.start(0.2);\n * }, 4).then((buffer) => {\n * \t// do something with the output buffer\n * \tconsole.log(buffer);\n * });\n * @category Core\n */\n\nexport function Offline(callback, duration, channels, sampleRate) {\n  if (channels === void 0) {\n    channels = 2;\n  }\n\n  if (sampleRate === void 0) {\n    sampleRate = getContext().sampleRate;\n  }\n\n  return tslib_1.__awaiter(this, void 0, void 0, function () {\n    var originalContext, context, bufferPromise, buffer;\n    return tslib_1.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          originalContext = getContext();\n          context = new OfflineContext(channels, duration, sampleRate);\n          setContext(context); // invoke the callback/scheduling\n\n          return [4\n          /*yield*/\n          , callback(context)];\n\n        case 1:\n          // invoke the callback/scheduling\n          _a.sent();\n\n          bufferPromise = context.render(); // return the original AudioContext\n\n          setContext(originalContext);\n          return [4\n          /*yield*/\n          , bufferPromise];\n\n        case 2:\n          buffer = _a.sent(); // return the audio\n\n          return [2\n          /*return*/\n          , new ToneAudioBuffer(buffer)];\n      }\n    });\n  });\n}","map":{"version":3,"sources":["../../../../Tone/core/context/Offline.ts"],"names":[],"mappings":";AAAA,SAAS,UAAT,EAAqB,UAArB,QAAuC,WAAvC;AAEA,SAAS,cAAT,QAA+B,kBAA/B;AACA,SAAS,eAAT,QAAgC,mBAAhC;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA,OAAM,SAAgB,OAAhB,CACL,QADK,EAEL,QAFK,EAGL,QAHK,EAIL,UAJK,EAIuC;AAD5C,MAAA,QAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,QAAA,GAAA,CAAA;AAAY;;AACZ,MAAA,UAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,UAAA,GAAqB,UAAU,GAAG,UAAlC;AAA4C;;;;;;;AAGtC,UAAA,eAAe,GAAG,UAAU,EAA5B;AAEA,UAAA,OAAO,GAAG,IAAI,cAAJ,CAAmB,QAAnB,EAA6B,QAA7B,EAAuC,UAAvC,CAAV;AACN,UAAA,UAAU,CAAC,OAAD,CAAV,C,CAEA;;AACA,iBAAA,CAAA;AAAA;AAAA,YAAM,QAAQ,CAAC,OAAD,CAAd,CAAA;;;AADA;AACA,UAAA,EAAA,CAAA,IAAA;;AAGM,UAAA,aAAa,GAAG,OAAO,CAAC,MAAR,EAAhB,C,CAEN;;AACA,UAAA,UAAU,CAAC,eAAD,CAAV;AAGe,iBAAA,CAAA;AAAA;AAAA,YAAM,aAAN,CAAA;;;AAAT,UAAA,MAAM,GAAG,EAAA,CAAA,IAAA,EAAT,C,CAEN;;AACA,iBAAA,CAAA;AAAA;AAAA,YAAO,IAAI,eAAJ,CAAoB,MAApB,CAAP,CAAA;;;;AACA","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { getContext, setContext } from \"../Global\";\nimport { OfflineContext } from \"./OfflineContext\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n/**\n * Generate a buffer by rendering all of the Tone.js code within the callback using the OfflineAudioContext.\n * The OfflineAudioContext is capable of rendering much faster than real time in many cases.\n * The callback function also passes in an offline instance of [[Context]] which can be used\n * to schedule events along the Transport.\n * @param  callback  All Tone.js nodes which are created and scheduled within this callback are recorded into the output Buffer.\n * @param  duration     the amount of time to record for.\n * @return  The promise which is invoked with the ToneAudioBuffer of the recorded output.\n * @example\n * import { Offline, Oscillator } from \"tone\";\n * // render 2 seconds of the oscillator\n * Offline(() => {\n * \t// only nodes created in this callback will be recorded\n * \tconst oscillator = new Oscillator().toDestination().start(0);\n * }, 2).then((buffer) => {\n * \t// do something with the output buffer\n * \tconsole.log(buffer);\n * });\n * @example\n * import { Offline, Oscillator } from \"tone\";\n * // can also schedule events along the Transport\n * // using the passed in Offline Transport\n * Offline(({ transport }) => {\n * \tconst osc = new Oscillator().toDestination();\n * \ttransport.schedule(time => {\n * \t\tosc.start(time).stop(time + 0.1);\n * \t}, 1);\n * \t// make sure to start the transport\n * \ttransport.start(0.2);\n * }, 4).then((buffer) => {\n * \t// do something with the output buffer\n * \tconsole.log(buffer);\n * });\n * @category Core\n */\nexport function Offline(callback, duration, channels, sampleRate) {\n    if (channels === void 0) { channels = 2; }\n    if (sampleRate === void 0) { sampleRate = getContext().sampleRate; }\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n        var originalContext, context, bufferPromise, buffer;\n        return tslib_1.__generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    originalContext = getContext();\n                    context = new OfflineContext(channels, duration, sampleRate);\n                    setContext(context);\n                    // invoke the callback/scheduling\n                    return [4 /*yield*/, callback(context)];\n                case 1:\n                    // invoke the callback/scheduling\n                    _a.sent();\n                    bufferPromise = context.render();\n                    // return the original AudioContext\n                    setContext(originalContext);\n                    return [4 /*yield*/, bufferPromise];\n                case 2:\n                    buffer = _a.sent();\n                    // return the audio\n                    return [2 /*return*/, new ToneAudioBuffer(buffer)];\n            }\n        });\n    });\n}\n//# sourceMappingURL=Offline.js.map"]},"metadata":{},"sourceType":"module"}