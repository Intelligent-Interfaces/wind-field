{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { isAudioBuffer, isAudioNode, isAudioParam } from \"./AdvancedTypeCheck\";\nimport { isDefined, isObject, isUndef } from \"./TypeCheck\";\n/**\n * Some objects should not be merged\n */\n\nfunction noCopy(key, arg) {\n  return key === \"value\" || isAudioParam(arg) || isAudioNode(arg) || isAudioBuffer(arg);\n}\n\nexport function deepMerge(target) {\n  var _a, _b;\n\n  var sources = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    sources[_i - 1] = arguments[_i];\n  }\n\n  if (!sources.length) {\n    return target;\n  }\n\n  var source = sources.shift();\n\n  if (isObject(target) && isObject(source)) {\n    for (var key in source) {\n      if (noCopy(key, source[key])) {\n        target[key] = source[key];\n      } else if (isObject(source[key])) {\n        if (!target[key]) {\n          Object.assign(target, (_a = {}, _a[key] = {}, _a));\n        }\n\n        deepMerge(target[key], source[key]);\n      } else {\n        Object.assign(target, (_b = {}, _b[key] = source[key], _b));\n      }\n    }\n  } // @ts-ignore\n\n\n  return deepMerge.apply(void 0, tslib_1.__spread([target], sources));\n}\n/**\n * Returns true if the two arrays have the same value for each of the elements\n */\n\nexport function deepEquals(arrayA, arrayB) {\n  return arrayA.length === arrayB.length && arrayA.every(function (element, index) {\n    return arrayB[index] === element;\n  });\n}\n/**\n * Convert an args array into an object.\n */\n\nexport function optionsFromArguments(defaults, argsArray, keys, objKey) {\n  var _a;\n\n  if (keys === void 0) {\n    keys = [];\n  }\n\n  var opts = {};\n  var args = Array.from(argsArray); // if the first argument is an object and has an object key\n\n  if (isObject(args[0]) && objKey && !Reflect.has(args[0], objKey)) {\n    // if it's not part of the defaults\n    var partOfDefaults = Object.keys(args[0]).some(function (key) {\n      return Reflect.has(defaults, key);\n    });\n\n    if (!partOfDefaults) {\n      // merge that key\n      deepMerge(opts, (_a = {}, _a[objKey] = args[0], _a)); // remove the obj key from the keys\n\n      keys.splice(keys.indexOf(objKey), 1); // shift the first argument off\n\n      args.shift();\n    }\n  }\n\n  if (args.length === 1 && isObject(args[0])) {\n    deepMerge(opts, args[0]);\n  } else {\n    for (var i = 0; i < keys.length; i++) {\n      if (isDefined(args[i])) {\n        opts[keys[i]] = args[i];\n      }\n    }\n  }\n\n  return deepMerge(defaults, opts);\n}\n/**\n * Return this instances default values by calling Constructor.getDefaults()\n */\n\nexport function getDefaultsFromInstance(instance) {\n  return instance.constructor.getDefaults();\n}\n/**\n * Returns the fallback if the given object is undefined.\n * Take an array of arguments and return a formatted options object.\n */\n\nexport function defaultArg(given, fallback) {\n  if (isUndef(given)) {\n    return fallback;\n  } else {\n    return given;\n  }\n}\n/**\n * Remove all of the properties belonging to omit from obj.\n */\n\nexport function omitFromObject(obj, omit) {\n  omit.forEach(function (prop) {\n    if (Reflect.has(obj, prop)) {\n      delete obj[prop];\n    }\n  });\n  return obj;\n}","map":{"version":3,"sources":["../../../../Tone/core/util/Defaults.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { isAudioBuffer, isAudioNode, isAudioParam } from \"./AdvancedTypeCheck\";\nimport { isDefined, isObject, isUndef } from \"./TypeCheck\";\n/**\n * Some objects should not be merged\n */\nfunction noCopy(key, arg) {\n    return key === \"value\" || isAudioParam(arg) || isAudioNode(arg) || isAudioBuffer(arg);\n}\nexport function deepMerge(target) {\n    var _a, _b;\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    if (!sources.length) {\n        return target;\n    }\n    var source = sources.shift();\n    if (isObject(target) && isObject(source)) {\n        for (var key in source) {\n            if (noCopy(key, source[key])) {\n                target[key] = source[key];\n            }\n            else if (isObject(source[key])) {\n                if (!target[key]) {\n                    Object.assign(target, (_a = {}, _a[key] = {}, _a));\n                }\n                deepMerge(target[key], source[key]);\n            }\n            else {\n                Object.assign(target, (_b = {}, _b[key] = source[key], _b));\n            }\n        }\n    }\n    // @ts-ignore\n    return deepMerge.apply(void 0, tslib_1.__spread([target], sources));\n}\n/**\n * Returns true if the two arrays have the same value for each of the elements\n */\nexport function deepEquals(arrayA, arrayB) {\n    return arrayA.length === arrayB.length && arrayA.every(function (element, index) { return arrayB[index] === element; });\n}\n/**\n * Convert an args array into an object.\n */\nexport function optionsFromArguments(defaults, argsArray, keys, objKey) {\n    var _a;\n    if (keys === void 0) { keys = []; }\n    var opts = {};\n    var args = Array.from(argsArray);\n    // if the first argument is an object and has an object key\n    if (isObject(args[0]) && objKey && !Reflect.has(args[0], objKey)) {\n        // if it's not part of the defaults\n        var partOfDefaults = Object.keys(args[0]).some(function (key) { return Reflect.has(defaults, key); });\n        if (!partOfDefaults) {\n            // merge that key\n            deepMerge(opts, (_a = {}, _a[objKey] = args[0], _a));\n            // remove the obj key from the keys\n            keys.splice(keys.indexOf(objKey), 1);\n            // shift the first argument off\n            args.shift();\n        }\n    }\n    if (args.length === 1 && isObject(args[0])) {\n        deepMerge(opts, args[0]);\n    }\n    else {\n        for (var i = 0; i < keys.length; i++) {\n            if (isDefined(args[i])) {\n                opts[keys[i]] = args[i];\n            }\n        }\n    }\n    return deepMerge(defaults, opts);\n}\n/**\n * Return this instances default values by calling Constructor.getDefaults()\n */\nexport function getDefaultsFromInstance(instance) {\n    return instance.constructor.getDefaults();\n}\n/**\n * Returns the fallback if the given object is undefined.\n * Take an array of arguments and return a formatted options object.\n */\nexport function defaultArg(given, fallback) {\n    if (isUndef(given)) {\n        return fallback;\n    }\n    else {\n        return given;\n    }\n}\n/**\n * Remove all of the properties belonging to omit from obj.\n */\nexport function omitFromObject(obj, omit) {\n    omit.forEach(function (prop) {\n        if (Reflect.has(obj, prop)) {\n            delete obj[prop];\n        }\n    });\n    return obj;\n}\n//# sourceMappingURL=Defaults.js.map"]},"metadata":{},"sourceType":"module"}