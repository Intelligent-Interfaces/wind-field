{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { Volume } from \"../component/channel/Volume\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\n/**\n * Base-class for all instruments\n */\n\nvar Instrument =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Instrument, _super);\n\n  function Instrument() {\n    var _this = _super.call(this, optionsFromArguments(Instrument.getDefaults(), arguments)) || this;\n    /**\n     * Keep track of all events scheduled to the transport\n     * when the instrument is 'synced'\n     */\n\n\n    _this._scheduledEvents = [];\n    /**\n     * If the instrument is currently synced\n     */\n\n    _this._synced = false;\n    _this._original_triggerAttack = _this.triggerAttack;\n    _this._original_triggerRelease = _this.triggerRelease;\n    var options = optionsFromArguments(Instrument.getDefaults(), arguments);\n    _this._volume = _this.output = new Volume({\n      context: _this.context,\n      volume: options.volume\n    });\n    _this.volume = _this._volume.volume;\n    readOnly(_this, \"volume\");\n    return _this;\n  }\n\n  Instrument.getDefaults = function () {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      volume: 0\n    });\n  };\n  /**\n   * Sync the instrument to the Transport. All subsequent calls of\n   * [[triggerAttack]] and [[triggerRelease]] will be scheduled along the transport.\n   * @example\n   * import { FMSynth, Transport } from \"tone\";\n   * const fmSynth = new FMSynth().toDestination();\n   * fmSynth.volume.value = -6;\n   * fmSynth.sync();\n   * // schedule 3 notes when the transport first starts\n   * fmSynth.triggerAttackRelease(\"C4\", \"8n\", 0);\n   * fmSynth.triggerAttackRelease(\"E4\", \"8n\", \"8n\");\n   * fmSynth.triggerAttackRelease(\"G4\", \"8n\", \"4n\");\n   * // start the transport to hear the notes\n   * Transport.start();\n   */\n\n\n  Instrument.prototype.sync = function () {\n    if (!this._synced) {\n      this._synced = true;\n\n      this._syncMethod(\"triggerAttack\", 1);\n\n      this._syncMethod(\"triggerRelease\", 0);\n    }\n\n    return this;\n  };\n  /**\n   * Wrap the given method so that it can be synchronized\n   * @param method Which method to wrap and sync\n   * @param  timePosition What position the time argument appears in\n   */\n\n\n  Instrument.prototype._syncMethod = function (method, timePosition) {\n    var _this = this;\n\n    var originalMethod = this[\"_original_\" + method] = this[method];\n\n    this[method] = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var time = args[timePosition];\n\n      var id = _this.context.transport.schedule(function (t) {\n        args[timePosition] = t;\n        originalMethod.apply(_this, args);\n      }, time);\n\n      _this._scheduledEvents.push(id);\n    };\n  };\n  /**\n   * Unsync the instrument from the Transport\n   */\n\n\n  Instrument.prototype.unsync = function () {\n    var _this = this;\n\n    this._scheduledEvents.forEach(function (id) {\n      return _this.context.transport.clear(id);\n    });\n\n    this._scheduledEvents = [];\n\n    if (this._synced) {\n      this._synced = false;\n      this.triggerAttack = this._original_triggerAttack;\n      this.triggerRelease = this._original_triggerRelease;\n    }\n\n    return this;\n  };\n  /**\n   * Trigger the attack and then the release after the duration.\n   * @param  note     The note to trigger.\n   * @param  duration How long the note should be held for before\n   *                         triggering the release. This value must be greater than 0.\n   * @param time  When the note should be triggered.\n   * @param  velocity The velocity the note should be triggered at.\n   * @example\n   * import { Synth } from \"tone\";\n   * const synth = new Synth().toDestination();\n   * // trigger \"C4\" for the duration of an 8th note\n   * synth.triggerAttackRelease(\"C4\", \"8n\");\n   */\n\n\n  Instrument.prototype.triggerAttackRelease = function (note, duration, time, velocity) {\n    var computedTime = this.toSeconds(time);\n    var computedDuration = this.toSeconds(duration);\n    this.triggerAttack(note, computedTime, velocity);\n    this.triggerRelease(computedTime + computedDuration);\n    return this;\n  };\n  /**\n   * clean up\n   * @returns {Instrument} this\n   */\n\n\n  Instrument.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._volume.dispose();\n\n    this.unsync();\n    this._scheduledEvents = [];\n    return this;\n  };\n\n  return Instrument;\n}(ToneAudioNode);\n\nexport { Instrument };","map":{"version":3,"sources":["../../../Tone/instrument/Instrument.ts"],"names":[],"mappings":";AAAA,SAAS,MAAT,QAAuB,6BAAvB;AAEA,SAAqB,aAArB,QAAgE,+BAAhE;AAEA,SAAS,oBAAT,QAAqC,uBAArC;AACA,SAAS,QAAT,QAAyB,wBAAzB;AAMA;;;;AAGA,IAAA,UAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAA4E,EAAA,OAAA,CAAA,SAAA,CAAA,UAAA,EAAA,MAAA;;AAmC3E,WAAA,UAAA,GAAA;AAAA,QAAA,KAAA,GAEC,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,oBAAoB,CAAC,UAAU,CAAC,WAAX,EAAD,EAA2B,SAA3B,CAA1B,KAAgE,IAFjE;AAZA;;;;;;AAIQ,IAAA,KAAA,CAAA,gBAAA,GAA6B,EAA7B;AAER;;;;AAGQ,IAAA,KAAA,CAAA,OAAA,GAAU,KAAV;AAyGA,IAAA,KAAA,CAAA,uBAAA,GAA0B,KAAI,CAAC,aAA/B;AAOA,IAAA,KAAA,CAAA,wBAAA,GAA2B,KAAI,CAAC,cAAhC;AA1GP,QAAM,OAAO,GAAG,oBAAoB,CAAC,UAAU,CAAC,WAAX,EAAD,EAA2B,SAA3B,CAApC;AAEA,IAAA,KAAI,CAAC,OAAL,GAAe,KAAI,CAAC,MAAL,GAAc,IAAI,MAAJ,CAAW;AACvC,MAAA,OAAO,EAAE,KAAI,CAAC,OADyB;AAEvC,MAAA,MAAM,EAAE,OAAO,CAAC;AAFuB,KAAX,CAA7B;AAIA,IAAA,KAAI,CAAC,MAAL,GAAc,KAAI,CAAC,OAAL,CAAa,MAA3B;AACA,IAAA,QAAQ,CAAC,KAAD,EAAO,QAAP,CAAR;;AACA;;AAEM,EAAA,UAAA,CAAA,WAAA,GAAP,YAAA;AACC,WAAO,MAAM,CAAC,MAAP,CAAc,aAAa,CAAC,WAAd,EAAd,EAA2C;AACjD,MAAA,MAAM,EAAE;AADyC,KAA3C,CAAP;AAGA,GAJM;AAMP;;;;;;;;;;;;;;;;;AAeA,EAAA,UAAA,CAAA,SAAA,CAAA,IAAA,GAAA,YAAA;AACC,QAAI,CAAC,KAAK,OAAV,EAAmB;AAClB,WAAK,OAAL,GAAe,IAAf;;AACA,WAAK,WAAL,CAAiB,eAAjB,EAAkC,CAAlC;;AACA,WAAK,WAAL,CAAiB,gBAAjB,EAAmC,CAAnC;AACA;;AACD,WAAO,IAAP;AACA,GAPD;AASA;;;;;;;AAKU,EAAA,UAAA,CAAA,SAAA,CAAA,WAAA,GAAV,UAAsB,MAAtB,EAAsC,YAAtC,EAA0D;AAA1D,QAAA,KAAA,GAAA,IAAA;;AACC,QAAM,cAAc,GAAG,KAAK,eAAe,MAApB,IAA8B,KAAK,MAAL,CAArD;;AACA,SAAK,MAAL,IAAe,YAAA;AAAC,UAAA,IAAA,GAAA,EAAA;;WAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAc;AAAd,QAAA,IAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AACf,UAAM,IAAI,GAAG,IAAI,CAAC,YAAD,CAAjB;;AACA,UAAM,EAAE,GAAG,KAAI,CAAC,OAAL,CAAa,SAAb,CAAuB,QAAvB,CAAgC,UAAC,CAAD,EAAE;AAC5C,QAAA,IAAI,CAAC,YAAD,CAAJ,GAAqB,CAArB;AACA,QAAA,cAAc,CAAC,KAAf,CAAqB,KAArB,EAA2B,IAA3B;AACA,OAHU,EAGR,IAHQ,CAAX;;AAIA,MAAA,KAAI,CAAC,gBAAL,CAAsB,IAAtB,CAA2B,EAA3B;AACA,KAPD;AAQA,GAVS;AAYV;;;;;AAGA,EAAA,UAAA,CAAA,SAAA,CAAA,MAAA,GAAA,YAAA;AAAA,QAAA,KAAA,GAAA,IAAA;;AACC,SAAK,gBAAL,CAAsB,OAAtB,CAA8B,UAAA,EAAA,EAAE;AAAI,aAAA,KAAI,CAAC,OAAL,CAAa,SAAb,CAAuB,KAAvB,CAAA,EAAA,CAAA;AAAgC,KAApE;;AACA,SAAK,gBAAL,GAAwB,EAAxB;;AACA,QAAI,KAAK,OAAT,EAAkB;AACjB,WAAK,OAAL,GAAe,KAAf;AACA,WAAK,aAAL,GAAqB,KAAK,uBAA1B;AACA,WAAK,cAAL,GAAsB,KAAK,wBAA3B;AACA;;AACD,WAAO,IAAP;AACA,GATD;AAWA;;;;;;;;;;;;;;;AAaA,EAAA,UAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,UAAqB,IAArB,EAAsC,QAAtC,EAAsD,IAAtD,EAAmE,QAAnE,EAAyF;AACxF,QAAM,YAAY,GAAG,KAAK,SAAL,CAAe,IAAf,CAArB;AACA,QAAM,gBAAgB,GAAG,KAAK,SAAL,CAAe,QAAf,CAAzB;AACA,SAAK,aAAL,CAAmB,IAAnB,EAAyB,YAAzB,EAAuC,QAAvC;AACA,SAAK,cAAL,CAAoB,YAAY,GAAG,gBAAnC;AACA,WAAO,IAAP;AACA,GAND;AAwBA;;;;;;AAIA,EAAA,UAAA,CAAA,SAAA,CAAA,OAAA,GAAA,YAAA;AACC,IAAA,MAAA,CAAA,SAAA,CAAM,OAAN,CAAa,IAAb,CAAa,IAAb;;AACA,SAAK,OAAL,CAAa,OAAb;;AACA,SAAK,MAAL;AACA,SAAK,gBAAL,GAAwB,EAAxB;AACA,WAAO,IAAP;AACA,GAND;;AAOD,SAAA,UAAA;AAAC,CA7JD,CAA4E,aAA5E,CAAA","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { Volume } from \"../component/channel/Volume\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\n/**\n * Base-class for all instruments\n */\nvar Instrument = /** @class */ (function (_super) {\n    tslib_1.__extends(Instrument, _super);\n    function Instrument() {\n        var _this = _super.call(this, optionsFromArguments(Instrument.getDefaults(), arguments)) || this;\n        /**\n         * Keep track of all events scheduled to the transport\n         * when the instrument is 'synced'\n         */\n        _this._scheduledEvents = [];\n        /**\n         * If the instrument is currently synced\n         */\n        _this._synced = false;\n        _this._original_triggerAttack = _this.triggerAttack;\n        _this._original_triggerRelease = _this.triggerRelease;\n        var options = optionsFromArguments(Instrument.getDefaults(), arguments);\n        _this._volume = _this.output = new Volume({\n            context: _this.context,\n            volume: options.volume,\n        });\n        _this.volume = _this._volume.volume;\n        readOnly(_this, \"volume\");\n        return _this;\n    }\n    Instrument.getDefaults = function () {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            volume: 0,\n        });\n    };\n    /**\n     * Sync the instrument to the Transport. All subsequent calls of\n     * [[triggerAttack]] and [[triggerRelease]] will be scheduled along the transport.\n     * @example\n     * import { FMSynth, Transport } from \"tone\";\n     * const fmSynth = new FMSynth().toDestination();\n     * fmSynth.volume.value = -6;\n     * fmSynth.sync();\n     * // schedule 3 notes when the transport first starts\n     * fmSynth.triggerAttackRelease(\"C4\", \"8n\", 0);\n     * fmSynth.triggerAttackRelease(\"E4\", \"8n\", \"8n\");\n     * fmSynth.triggerAttackRelease(\"G4\", \"8n\", \"4n\");\n     * // start the transport to hear the notes\n     * Transport.start();\n     */\n    Instrument.prototype.sync = function () {\n        if (!this._synced) {\n            this._synced = true;\n            this._syncMethod(\"triggerAttack\", 1);\n            this._syncMethod(\"triggerRelease\", 0);\n        }\n        return this;\n    };\n    /**\n     * Wrap the given method so that it can be synchronized\n     * @param method Which method to wrap and sync\n     * @param  timePosition What position the time argument appears in\n     */\n    Instrument.prototype._syncMethod = function (method, timePosition) {\n        var _this = this;\n        var originalMethod = this[\"_original_\" + method] = this[method];\n        this[method] = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var time = args[timePosition];\n            var id = _this.context.transport.schedule(function (t) {\n                args[timePosition] = t;\n                originalMethod.apply(_this, args);\n            }, time);\n            _this._scheduledEvents.push(id);\n        };\n    };\n    /**\n     * Unsync the instrument from the Transport\n     */\n    Instrument.prototype.unsync = function () {\n        var _this = this;\n        this._scheduledEvents.forEach(function (id) { return _this.context.transport.clear(id); });\n        this._scheduledEvents = [];\n        if (this._synced) {\n            this._synced = false;\n            this.triggerAttack = this._original_triggerAttack;\n            this.triggerRelease = this._original_triggerRelease;\n        }\n        return this;\n    };\n    /**\n     * Trigger the attack and then the release after the duration.\n     * @param  note     The note to trigger.\n     * @param  duration How long the note should be held for before\n     *                         triggering the release. This value must be greater than 0.\n     * @param time  When the note should be triggered.\n     * @param  velocity The velocity the note should be triggered at.\n     * @example\n     * import { Synth } from \"tone\";\n     * const synth = new Synth().toDestination();\n     * // trigger \"C4\" for the duration of an 8th note\n     * synth.triggerAttackRelease(\"C4\", \"8n\");\n     */\n    Instrument.prototype.triggerAttackRelease = function (note, duration, time, velocity) {\n        var computedTime = this.toSeconds(time);\n        var computedDuration = this.toSeconds(duration);\n        this.triggerAttack(note, computedTime, velocity);\n        this.triggerRelease(computedTime + computedDuration);\n        return this;\n    };\n    /**\n     * clean up\n     * @returns {Instrument} this\n     */\n    Instrument.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this._volume.dispose();\n        this.unsync();\n        this._scheduledEvents = [];\n        return this;\n    };\n    return Instrument;\n}(ToneAudioNode));\nexport { Instrument };\n//# sourceMappingURL=Instrument.js.map"]},"metadata":{},"sourceType":"module"}