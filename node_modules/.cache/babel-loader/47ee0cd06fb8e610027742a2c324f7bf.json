{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { connectSeries, ToneAudioNode } from \"../../core/context/ToneAudioNode\";\n/**\n * PhaseShiftAllpass is an very efficient implementation of a Hilbert Transform\n * using two Allpass filter banks whose outputs have a phase difference of 90째.\n * Here the `offset90` phase is offset by +90째 in relation to `output`.\n * Coefficients and structure was developed by Olli Niemitalo.\n * For more details see: http://yehar.com/blog/?p=368\n * @category Component\n */\n\nvar PhaseShiftAllpass =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(PhaseShiftAllpass, _super);\n\n  function PhaseShiftAllpass(options) {\n    var _this = _super.call(this, options) || this;\n\n    _this.name = \"PhaseShiftAllpass\";\n    _this.input = new Gain({\n      context: _this.context\n    });\n    /**\n     * The phase shifted output\n     */\n\n    _this.output = new Gain({\n      context: _this.context\n    });\n    /**\n     * The PhaseShifted allpass output\n     */\n\n    _this.offset90 = new Gain({\n      context: _this.context\n    });\n    var allpassBank1Values = [0.6923878, 0.9360654322959, 0.9882295226860, 0.9987488452737];\n    var allpassBank2Values = [0.4021921162426, 0.8561710882420, 0.9722909545651, 0.9952884791278];\n    _this._bank0 = _this._createAllPassFilterBank(allpassBank1Values);\n    _this._bank1 = _this._createAllPassFilterBank(allpassBank2Values);\n    _this._oneSampleDelay = _this.context.createIIRFilter([0.0, 1.0], [1.0, 0.0]); // connect Allpass filter banks\n\n    connectSeries.apply(void 0, tslib_1.__spread([_this.input], _this._bank0, [_this._oneSampleDelay, _this.output]));\n    connectSeries.apply(void 0, tslib_1.__spread([_this.input], _this._bank1, [_this.offset90]));\n    return _this;\n  }\n  /**\n   * Create all of the IIR filters from an array of values using the coefficient calculation.\n   */\n\n\n  PhaseShiftAllpass.prototype._createAllPassFilterBank = function (bankValues) {\n    var _this = this;\n\n    var nodes = bankValues.map(function (value) {\n      var coefficients = [[value * value, 0, -1], [1, 0, -(value * value)]];\n      return _this.context.createIIRFilter(coefficients[0], coefficients[1]);\n    });\n    return nodes;\n  };\n\n  PhaseShiftAllpass.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.input.dispose();\n    this.output.dispose();\n    this.offset90.dispose();\n\n    this._bank0.forEach(function (f) {\n      return f.disconnect();\n    });\n\n    this._bank1.forEach(function (f) {\n      return f.disconnect();\n    });\n\n    this._oneSampleDelay.disconnect();\n\n    return this;\n  };\n\n  return PhaseShiftAllpass;\n}(ToneAudioNode);\n\nexport { PhaseShiftAllpass };","map":{"version":3,"sources":["../../../../Tone/component/filter/PhaseShiftAllpass.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { connectSeries, ToneAudioNode } from \"../../core/context/ToneAudioNode\";\n/**\n * PhaseShiftAllpass is an very efficient implementation of a Hilbert Transform\n * using two Allpass filter banks whose outputs have a phase difference of 90째.\n * Here the `offset90` phase is offset by +90째 in relation to `output`.\n * Coefficients and structure was developed by Olli Niemitalo.\n * For more details see: http://yehar.com/blog/?p=368\n * @category Component\n */\nvar PhaseShiftAllpass = /** @class */ (function (_super) {\n    tslib_1.__extends(PhaseShiftAllpass, _super);\n    function PhaseShiftAllpass(options) {\n        var _this = _super.call(this, options) || this;\n        _this.name = \"PhaseShiftAllpass\";\n        _this.input = new Gain({ context: _this.context });\n        /**\n         * The phase shifted output\n         */\n        _this.output = new Gain({ context: _this.context });\n        /**\n         * The PhaseShifted allpass output\n         */\n        _this.offset90 = new Gain({ context: _this.context });\n        var allpassBank1Values = [0.6923878, 0.9360654322959, 0.9882295226860, 0.9987488452737];\n        var allpassBank2Values = [0.4021921162426, 0.8561710882420, 0.9722909545651, 0.9952884791278];\n        _this._bank0 = _this._createAllPassFilterBank(allpassBank1Values);\n        _this._bank1 = _this._createAllPassFilterBank(allpassBank2Values);\n        _this._oneSampleDelay = _this.context.createIIRFilter([0.0, 1.0], [1.0, 0.0]);\n        // connect Allpass filter banks\n        connectSeries.apply(void 0, tslib_1.__spread([_this.input], _this._bank0, [_this._oneSampleDelay, _this.output]));\n        connectSeries.apply(void 0, tslib_1.__spread([_this.input], _this._bank1, [_this.offset90]));\n        return _this;\n    }\n    /**\n     * Create all of the IIR filters from an array of values using the coefficient calculation.\n     */\n    PhaseShiftAllpass.prototype._createAllPassFilterBank = function (bankValues) {\n        var _this = this;\n        var nodes = bankValues.map(function (value) {\n            var coefficients = [[value * value, 0, -1], [1, 0, -(value * value)]];\n            return _this.context.createIIRFilter(coefficients[0], coefficients[1]);\n        });\n        return nodes;\n    };\n    PhaseShiftAllpass.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this.input.dispose();\n        this.output.dispose();\n        this.offset90.dispose();\n        this._bank0.forEach(function (f) { return f.disconnect(); });\n        this._bank1.forEach(function (f) { return f.disconnect(); });\n        this._oneSampleDelay.disconnect();\n        return this;\n    };\n    return PhaseShiftAllpass;\n}(ToneAudioNode));\nexport { PhaseShiftAllpass };\n//# sourceMappingURL=PhaseShiftAllpass.js.map"]},"metadata":{},"sourceType":"module"}