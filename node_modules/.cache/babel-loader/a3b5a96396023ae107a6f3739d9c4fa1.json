{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { Tone } from \"../Tone\";\nimport { isDefined } from \"./TypeCheck\";\nimport { assert } from \"./Debug\";\n/**\n * Similar to Tone.Timeline, but all events represent\n * intervals with both \"time\" and \"duration\" times. The\n * events are placed in a tree structure optimized\n * for querying an intersection point with the timeline\n * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n * to represent the data.\n */\n\nvar IntervalTimeline =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(IntervalTimeline, _super);\n\n  function IntervalTimeline() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.name = \"IntervalTimeline\";\n    /**\n     * The root node of the inteval tree\n     */\n\n    _this._root = null;\n    /**\n     * Keep track of the length of the timeline.\n     */\n\n    _this._length = 0;\n    return _this;\n  }\n  /**\n   * The event to add to the timeline. All events must\n   * have a time and duration value\n   * @param  event  The event to add to the timeline\n   */\n\n\n  IntervalTimeline.prototype.add = function (event) {\n    assert(isDefined(event.time), \"Events must have a time property\");\n    assert(isDefined(event.duration), \"Events must have a duration parameter\");\n    event.time = event.time.valueOf();\n    var node = new IntervalNode(event.time, event.time + event.duration, event);\n\n    if (this._root === null) {\n      this._root = node;\n    } else {\n      this._root.insert(node);\n    }\n\n    this._length++; // Restructure tree to be balanced\n\n    while (node !== null) {\n      node.updateHeight();\n      node.updateMax();\n\n      this._rebalance(node);\n\n      node = node.parent;\n    }\n\n    return this;\n  };\n  /**\n   * Remove an event from the timeline.\n   * @param  event  The event to remove from the timeline\n   */\n\n\n  IntervalTimeline.prototype.remove = function (event) {\n    var e_1, _a;\n\n    if (this._root !== null) {\n      var results = [];\n\n      this._root.search(event.time, results);\n\n      try {\n        for (var results_1 = tslib_1.__values(results), results_1_1 = results_1.next(); !results_1_1.done; results_1_1 = results_1.next()) {\n          var node = results_1_1.value;\n\n          if (node.event === event) {\n            this._removeNode(node);\n\n            this._length--;\n            break;\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (results_1_1 && !results_1_1.done && (_a = results_1.return)) _a.call(results_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    return this;\n  };\n\n  Object.defineProperty(IntervalTimeline.prototype, \"length\", {\n    /**\n     * The number of items in the timeline.\n     * @readOnly\n     */\n    get: function () {\n      return this._length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Remove events whose time time is after the given time\n   * @param  after  The time to query.\n   */\n\n  IntervalTimeline.prototype.cancel = function (after) {\n    var _this = this;\n\n    this.forEachFrom(after, function (event) {\n      return _this.remove(event);\n    });\n    return this;\n  };\n  /**\n   * Set the root node as the given node\n   */\n\n\n  IntervalTimeline.prototype._setRoot = function (node) {\n    this._root = node;\n\n    if (this._root !== null) {\n      this._root.parent = null;\n    }\n  };\n  /**\n   * Replace the references to the node in the node's parent\n   * with the replacement node.\n   */\n\n\n  IntervalTimeline.prototype._replaceNodeInParent = function (node, replacement) {\n    if (node.parent !== null) {\n      if (node.isLeftChild()) {\n        node.parent.left = replacement;\n      } else {\n        node.parent.right = replacement;\n      }\n\n      this._rebalance(node.parent);\n    } else {\n      this._setRoot(replacement);\n    }\n  };\n  /**\n   * Remove the node from the tree and replace it with\n   * a successor which follows the schema.\n   */\n\n\n  IntervalTimeline.prototype._removeNode = function (node) {\n    if (node.left === null && node.right === null) {\n      this._replaceNodeInParent(node, null);\n    } else if (node.right === null) {\n      this._replaceNodeInParent(node, node.left);\n    } else if (node.left === null) {\n      this._replaceNodeInParent(node, node.right);\n    } else {\n      var balance = node.getBalance();\n      var replacement = void 0;\n      var temp = null;\n\n      if (balance > 0) {\n        if (node.left.right === null) {\n          replacement = node.left;\n          replacement.right = node.right;\n          temp = replacement;\n        } else {\n          replacement = node.left.right;\n\n          while (replacement.right !== null) {\n            replacement = replacement.right;\n          }\n\n          if (replacement.parent) {\n            replacement.parent.right = replacement.left;\n            temp = replacement.parent;\n            replacement.left = node.left;\n            replacement.right = node.right;\n          }\n        }\n      } else if (node.right.left === null) {\n        replacement = node.right;\n        replacement.left = node.left;\n        temp = replacement;\n      } else {\n        replacement = node.right.left;\n\n        while (replacement.left !== null) {\n          replacement = replacement.left;\n        }\n\n        if (replacement.parent) {\n          replacement.parent.left = replacement.right;\n          temp = replacement.parent;\n          replacement.left = node.left;\n          replacement.right = node.right;\n        }\n      }\n\n      if (node.parent !== null) {\n        if (node.isLeftChild()) {\n          node.parent.left = replacement;\n        } else {\n          node.parent.right = replacement;\n        }\n      } else {\n        this._setRoot(replacement);\n      }\n\n      if (temp) {\n        this._rebalance(temp);\n      }\n    }\n\n    node.dispose();\n  };\n  /**\n   * Rotate the tree to the left\n   */\n\n\n  IntervalTimeline.prototype._rotateLeft = function (node) {\n    var parent = node.parent;\n    var isLeftChild = node.isLeftChild(); // Make node.right the new root of this sub tree (instead of node)\n\n    var pivotNode = node.right;\n\n    if (pivotNode) {\n      node.right = pivotNode.left;\n      pivotNode.left = node;\n    }\n\n    if (parent !== null) {\n      if (isLeftChild) {\n        parent.left = pivotNode;\n      } else {\n        parent.right = pivotNode;\n      }\n    } else {\n      this._setRoot(pivotNode);\n    }\n  };\n  /**\n   * Rotate the tree to the right\n   */\n\n\n  IntervalTimeline.prototype._rotateRight = function (node) {\n    var parent = node.parent;\n    var isLeftChild = node.isLeftChild(); // Make node.left the new root of this sub tree (instead of node)\n\n    var pivotNode = node.left;\n\n    if (pivotNode) {\n      node.left = pivotNode.right;\n      pivotNode.right = node;\n    }\n\n    if (parent !== null) {\n      if (isLeftChild) {\n        parent.left = pivotNode;\n      } else {\n        parent.right = pivotNode;\n      }\n    } else {\n      this._setRoot(pivotNode);\n    }\n  };\n  /**\n   * Balance the BST\n   */\n\n\n  IntervalTimeline.prototype._rebalance = function (node) {\n    var balance = node.getBalance();\n\n    if (balance > 1 && node.left) {\n      if (node.left.getBalance() < 0) {\n        this._rotateLeft(node.left);\n      } else {\n        this._rotateRight(node);\n      }\n    } else if (balance < -1 && node.right) {\n      if (node.right.getBalance() > 0) {\n        this._rotateRight(node.right);\n      } else {\n        this._rotateLeft(node);\n      }\n    }\n  };\n  /**\n   * Get an event whose time and duration span the give time. Will\n   * return the match whose \"time\" value is closest to the given time.\n   * @return  The event which spans the desired time\n   */\n\n\n  IntervalTimeline.prototype.get = function (time) {\n    if (this._root !== null) {\n      var results = [];\n\n      this._root.search(time, results);\n\n      if (results.length > 0) {\n        var max = results[0];\n\n        for (var i = 1; i < results.length; i++) {\n          if (results[i].low > max.low) {\n            max = results[i];\n          }\n        }\n\n        return max.event;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Iterate over everything in the timeline.\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  IntervalTimeline.prototype.forEach = function (callback) {\n    if (this._root !== null) {\n      var allNodes_1 = [];\n\n      this._root.traverse(function (node) {\n        return allNodes_1.push(node);\n      });\n\n      allNodes_1.forEach(function (node) {\n        if (node.event) {\n          callback(node.event);\n        }\n      });\n    }\n\n    return this;\n  };\n  /**\n   * Iterate over everything in the array in which the given time\n   * overlaps with the time and duration time of the event.\n   * @param  time The time to check if items are overlapping\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  IntervalTimeline.prototype.forEachAtTime = function (time, callback) {\n    if (this._root !== null) {\n      var results = [];\n\n      this._root.search(time, results);\n\n      results.forEach(function (node) {\n        if (node.event) {\n          callback(node.event);\n        }\n      });\n    }\n\n    return this;\n  };\n  /**\n   * Iterate over everything in the array in which the time is greater\n   * than or equal to the given time.\n   * @param  time The time to check if items are before\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  IntervalTimeline.prototype.forEachFrom = function (time, callback) {\n    if (this._root !== null) {\n      var results = [];\n\n      this._root.searchAfter(time, results);\n\n      results.forEach(function (node) {\n        if (node.event) {\n          callback(node.event);\n        }\n      });\n    }\n\n    return this;\n  };\n  /**\n   * Clean up\n   */\n\n\n  IntervalTimeline.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    if (this._root !== null) {\n      this._root.traverse(function (node) {\n        return node.dispose();\n      });\n    }\n\n    this._root = null;\n    return this;\n  };\n\n  return IntervalTimeline;\n}(Tone);\n\nexport { IntervalTimeline }; //-------------------------------------\n// \tINTERVAL NODE HELPER\n//-------------------------------------\n\n/**\n * Represents a node in the binary search tree, with the addition\n * of a \"high\" value which keeps track of the highest value of\n * its children.\n * References:\n * https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n * http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n * @param low\n * @param high\n */\n\nvar IntervalNode =\n/** @class */\nfunction () {\n  function IntervalNode(low, high, event) {\n    // the nodes to the left\n    this._left = null; // the nodes to the right\n\n    this._right = null; // the parent node\n\n    this.parent = null; // the number of child nodes\n\n    this.height = 0;\n    this.event = event; // the low value\n\n    this.low = low; // the high value\n\n    this.high = high; // the high value for this and all child nodes\n\n    this.max = this.high;\n  }\n  /**\n   * Insert a node into the correct spot in the tree\n   */\n\n\n  IntervalNode.prototype.insert = function (node) {\n    if (node.low <= this.low) {\n      if (this.left === null) {\n        this.left = node;\n      } else {\n        this.left.insert(node);\n      }\n    } else if (this.right === null) {\n      this.right = node;\n    } else {\n      this.right.insert(node);\n    }\n  };\n  /**\n   * Search the tree for nodes which overlap\n   * with the given point\n   * @param  point  The point to query\n   * @param  results  The array to put the results\n   */\n\n\n  IntervalNode.prototype.search = function (point, results) {\n    // If p is to the right of the rightmost point of any interval\n    // in this node and all children, there won't be any matches.\n    if (point > this.max) {\n      return;\n    } // Search left children\n\n\n    if (this.left !== null) {\n      this.left.search(point, results);\n    } // Check this node\n\n\n    if (this.low <= point && this.high > point) {\n      results.push(this);\n    } // If p is to the left of the time of this interval,\n    // then it can't be in any child to the right.\n\n\n    if (this.low > point) {\n      return;\n    } // Search right children\n\n\n    if (this.right !== null) {\n      this.right.search(point, results);\n    }\n  };\n  /**\n   * Search the tree for nodes which are less\n   * than the given point\n   * @param  point  The point to query\n   * @param  results  The array to put the results\n   */\n\n\n  IntervalNode.prototype.searchAfter = function (point, results) {\n    // Check this node\n    if (this.low >= point) {\n      results.push(this);\n\n      if (this.left !== null) {\n        this.left.searchAfter(point, results);\n      }\n    } // search the right side\n\n\n    if (this.right !== null) {\n      this.right.searchAfter(point, results);\n    }\n  };\n  /**\n   * Invoke the callback on this element and both it's branches\n   * @param  {Function}  callback\n   */\n\n\n  IntervalNode.prototype.traverse = function (callback) {\n    callback(this);\n\n    if (this.left !== null) {\n      this.left.traverse(callback);\n    }\n\n    if (this.right !== null) {\n      this.right.traverse(callback);\n    }\n  };\n  /**\n   * Update the height of the node\n   */\n\n\n  IntervalNode.prototype.updateHeight = function () {\n    if (this.left !== null && this.right !== null) {\n      this.height = Math.max(this.left.height, this.right.height) + 1;\n    } else if (this.right !== null) {\n      this.height = this.right.height + 1;\n    } else if (this.left !== null) {\n      this.height = this.left.height + 1;\n    } else {\n      this.height = 0;\n    }\n  };\n  /**\n   * Update the height of the node\n   */\n\n\n  IntervalNode.prototype.updateMax = function () {\n    this.max = this.high;\n\n    if (this.left !== null) {\n      this.max = Math.max(this.max, this.left.max);\n    }\n\n    if (this.right !== null) {\n      this.max = Math.max(this.max, this.right.max);\n    }\n  };\n  /**\n   * The balance is how the leafs are distributed on the node\n   * @return  Negative numbers are balanced to the right\n   */\n\n\n  IntervalNode.prototype.getBalance = function () {\n    var balance = 0;\n\n    if (this.left !== null && this.right !== null) {\n      balance = this.left.height - this.right.height;\n    } else if (this.left !== null) {\n      balance = this.left.height + 1;\n    } else if (this.right !== null) {\n      balance = -(this.right.height + 1);\n    }\n\n    return balance;\n  };\n  /**\n   * @returns true if this node is the left child of its parent\n   */\n\n\n  IntervalNode.prototype.isLeftChild = function () {\n    return this.parent !== null && this.parent.left === this;\n  };\n\n  Object.defineProperty(IntervalNode.prototype, \"left\", {\n    /**\n     * get/set the left node\n     */\n    get: function () {\n      return this._left;\n    },\n    set: function (node) {\n      this._left = node;\n\n      if (node !== null) {\n        node.parent = this;\n      }\n\n      this.updateHeight();\n      this.updateMax();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(IntervalNode.prototype, \"right\", {\n    /**\n     * get/set the right node\n     */\n    get: function () {\n      return this._right;\n    },\n    set: function (node) {\n      this._right = node;\n\n      if (node !== null) {\n        node.parent = this;\n      }\n\n      this.updateHeight();\n      this.updateMax();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * null out references.\n   */\n\n  IntervalNode.prototype.dispose = function () {\n    this.parent = null;\n    this._left = null;\n    this._right = null;\n    this.event = null;\n  };\n\n  return IntervalNode;\n}();","map":{"version":3,"sources":["../../../../Tone/core/util/IntervalTimeline.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { Tone } from \"../Tone\";\nimport { isDefined } from \"./TypeCheck\";\nimport { assert } from \"./Debug\";\n/**\n * Similar to Tone.Timeline, but all events represent\n * intervals with both \"time\" and \"duration\" times. The\n * events are placed in a tree structure optimized\n * for querying an intersection point with the timeline\n * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n * to represent the data.\n */\nvar IntervalTimeline = /** @class */ (function (_super) {\n    tslib_1.__extends(IntervalTimeline, _super);\n    function IntervalTimeline() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.name = \"IntervalTimeline\";\n        /**\n         * The root node of the inteval tree\n         */\n        _this._root = null;\n        /**\n         * Keep track of the length of the timeline.\n         */\n        _this._length = 0;\n        return _this;\n    }\n    /**\n     * The event to add to the timeline. All events must\n     * have a time and duration value\n     * @param  event  The event to add to the timeline\n     */\n    IntervalTimeline.prototype.add = function (event) {\n        assert(isDefined(event.time), \"Events must have a time property\");\n        assert(isDefined(event.duration), \"Events must have a duration parameter\");\n        event.time = event.time.valueOf();\n        var node = new IntervalNode(event.time, event.time + event.duration, event);\n        if (this._root === null) {\n            this._root = node;\n        }\n        else {\n            this._root.insert(node);\n        }\n        this._length++;\n        // Restructure tree to be balanced\n        while (node !== null) {\n            node.updateHeight();\n            node.updateMax();\n            this._rebalance(node);\n            node = node.parent;\n        }\n        return this;\n    };\n    /**\n     * Remove an event from the timeline.\n     * @param  event  The event to remove from the timeline\n     */\n    IntervalTimeline.prototype.remove = function (event) {\n        var e_1, _a;\n        if (this._root !== null) {\n            var results = [];\n            this._root.search(event.time, results);\n            try {\n                for (var results_1 = tslib_1.__values(results), results_1_1 = results_1.next(); !results_1_1.done; results_1_1 = results_1.next()) {\n                    var node = results_1_1.value;\n                    if (node.event === event) {\n                        this._removeNode(node);\n                        this._length--;\n                        break;\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (results_1_1 && !results_1_1.done && (_a = results_1.return)) _a.call(results_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        return this;\n    };\n    Object.defineProperty(IntervalTimeline.prototype, \"length\", {\n        /**\n         * The number of items in the timeline.\n         * @readOnly\n         */\n        get: function () {\n            return this._length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Remove events whose time time is after the given time\n     * @param  after  The time to query.\n     */\n    IntervalTimeline.prototype.cancel = function (after) {\n        var _this = this;\n        this.forEachFrom(after, function (event) { return _this.remove(event); });\n        return this;\n    };\n    /**\n     * Set the root node as the given node\n     */\n    IntervalTimeline.prototype._setRoot = function (node) {\n        this._root = node;\n        if (this._root !== null) {\n            this._root.parent = null;\n        }\n    };\n    /**\n     * Replace the references to the node in the node's parent\n     * with the replacement node.\n     */\n    IntervalTimeline.prototype._replaceNodeInParent = function (node, replacement) {\n        if (node.parent !== null) {\n            if (node.isLeftChild()) {\n                node.parent.left = replacement;\n            }\n            else {\n                node.parent.right = replacement;\n            }\n            this._rebalance(node.parent);\n        }\n        else {\n            this._setRoot(replacement);\n        }\n    };\n    /**\n     * Remove the node from the tree and replace it with\n     * a successor which follows the schema.\n     */\n    IntervalTimeline.prototype._removeNode = function (node) {\n        if (node.left === null && node.right === null) {\n            this._replaceNodeInParent(node, null);\n        }\n        else if (node.right === null) {\n            this._replaceNodeInParent(node, node.left);\n        }\n        else if (node.left === null) {\n            this._replaceNodeInParent(node, node.right);\n        }\n        else {\n            var balance = node.getBalance();\n            var replacement = void 0;\n            var temp = null;\n            if (balance > 0) {\n                if (node.left.right === null) {\n                    replacement = node.left;\n                    replacement.right = node.right;\n                    temp = replacement;\n                }\n                else {\n                    replacement = node.left.right;\n                    while (replacement.right !== null) {\n                        replacement = replacement.right;\n                    }\n                    if (replacement.parent) {\n                        replacement.parent.right = replacement.left;\n                        temp = replacement.parent;\n                        replacement.left = node.left;\n                        replacement.right = node.right;\n                    }\n                }\n            }\n            else if (node.right.left === null) {\n                replacement = node.right;\n                replacement.left = node.left;\n                temp = replacement;\n            }\n            else {\n                replacement = node.right.left;\n                while (replacement.left !== null) {\n                    replacement = replacement.left;\n                }\n                if (replacement.parent) {\n                    replacement.parent.left = replacement.right;\n                    temp = replacement.parent;\n                    replacement.left = node.left;\n                    replacement.right = node.right;\n                }\n            }\n            if (node.parent !== null) {\n                if (node.isLeftChild()) {\n                    node.parent.left = replacement;\n                }\n                else {\n                    node.parent.right = replacement;\n                }\n            }\n            else {\n                this._setRoot(replacement);\n            }\n            if (temp) {\n                this._rebalance(temp);\n            }\n        }\n        node.dispose();\n    };\n    /**\n     * Rotate the tree to the left\n     */\n    IntervalTimeline.prototype._rotateLeft = function (node) {\n        var parent = node.parent;\n        var isLeftChild = node.isLeftChild();\n        // Make node.right the new root of this sub tree (instead of node)\n        var pivotNode = node.right;\n        if (pivotNode) {\n            node.right = pivotNode.left;\n            pivotNode.left = node;\n        }\n        if (parent !== null) {\n            if (isLeftChild) {\n                parent.left = pivotNode;\n            }\n            else {\n                parent.right = pivotNode;\n            }\n        }\n        else {\n            this._setRoot(pivotNode);\n        }\n    };\n    /**\n     * Rotate the tree to the right\n     */\n    IntervalTimeline.prototype._rotateRight = function (node) {\n        var parent = node.parent;\n        var isLeftChild = node.isLeftChild();\n        // Make node.left the new root of this sub tree (instead of node)\n        var pivotNode = node.left;\n        if (pivotNode) {\n            node.left = pivotNode.right;\n            pivotNode.right = node;\n        }\n        if (parent !== null) {\n            if (isLeftChild) {\n                parent.left = pivotNode;\n            }\n            else {\n                parent.right = pivotNode;\n            }\n        }\n        else {\n            this._setRoot(pivotNode);\n        }\n    };\n    /**\n     * Balance the BST\n     */\n    IntervalTimeline.prototype._rebalance = function (node) {\n        var balance = node.getBalance();\n        if (balance > 1 && node.left) {\n            if (node.left.getBalance() < 0) {\n                this._rotateLeft(node.left);\n            }\n            else {\n                this._rotateRight(node);\n            }\n        }\n        else if (balance < -1 && node.right) {\n            if (node.right.getBalance() > 0) {\n                this._rotateRight(node.right);\n            }\n            else {\n                this._rotateLeft(node);\n            }\n        }\n    };\n    /**\n     * Get an event whose time and duration span the give time. Will\n     * return the match whose \"time\" value is closest to the given time.\n     * @return  The event which spans the desired time\n     */\n    IntervalTimeline.prototype.get = function (time) {\n        if (this._root !== null) {\n            var results = [];\n            this._root.search(time, results);\n            if (results.length > 0) {\n                var max = results[0];\n                for (var i = 1; i < results.length; i++) {\n                    if (results[i].low > max.low) {\n                        max = results[i];\n                    }\n                }\n                return max.event;\n            }\n        }\n        return null;\n    };\n    /**\n     * Iterate over everything in the timeline.\n     * @param  callback The callback to invoke with every item\n     */\n    IntervalTimeline.prototype.forEach = function (callback) {\n        if (this._root !== null) {\n            var allNodes_1 = [];\n            this._root.traverse(function (node) { return allNodes_1.push(node); });\n            allNodes_1.forEach(function (node) {\n                if (node.event) {\n                    callback(node.event);\n                }\n            });\n        }\n        return this;\n    };\n    /**\n     * Iterate over everything in the array in which the given time\n     * overlaps with the time and duration time of the event.\n     * @param  time The time to check if items are overlapping\n     * @param  callback The callback to invoke with every item\n     */\n    IntervalTimeline.prototype.forEachAtTime = function (time, callback) {\n        if (this._root !== null) {\n            var results = [];\n            this._root.search(time, results);\n            results.forEach(function (node) {\n                if (node.event) {\n                    callback(node.event);\n                }\n            });\n        }\n        return this;\n    };\n    /**\n     * Iterate over everything in the array in which the time is greater\n     * than or equal to the given time.\n     * @param  time The time to check if items are before\n     * @param  callback The callback to invoke with every item\n     */\n    IntervalTimeline.prototype.forEachFrom = function (time, callback) {\n        if (this._root !== null) {\n            var results = [];\n            this._root.searchAfter(time, results);\n            results.forEach(function (node) {\n                if (node.event) {\n                    callback(node.event);\n                }\n            });\n        }\n        return this;\n    };\n    /**\n     * Clean up\n     */\n    IntervalTimeline.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        if (this._root !== null) {\n            this._root.traverse(function (node) { return node.dispose(); });\n        }\n        this._root = null;\n        return this;\n    };\n    return IntervalTimeline;\n}(Tone));\nexport { IntervalTimeline };\n//-------------------------------------\n// \tINTERVAL NODE HELPER\n//-------------------------------------\n/**\n * Represents a node in the binary search tree, with the addition\n * of a \"high\" value which keeps track of the highest value of\n * its children.\n * References:\n * https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n * http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n * @param low\n * @param high\n */\nvar IntervalNode = /** @class */ (function () {\n    function IntervalNode(low, high, event) {\n        // the nodes to the left\n        this._left = null;\n        // the nodes to the right\n        this._right = null;\n        // the parent node\n        this.parent = null;\n        // the number of child nodes\n        this.height = 0;\n        this.event = event;\n        // the low value\n        this.low = low;\n        // the high value\n        this.high = high;\n        // the high value for this and all child nodes\n        this.max = this.high;\n    }\n    /**\n     * Insert a node into the correct spot in the tree\n     */\n    IntervalNode.prototype.insert = function (node) {\n        if (node.low <= this.low) {\n            if (this.left === null) {\n                this.left = node;\n            }\n            else {\n                this.left.insert(node);\n            }\n        }\n        else if (this.right === null) {\n            this.right = node;\n        }\n        else {\n            this.right.insert(node);\n        }\n    };\n    /**\n     * Search the tree for nodes which overlap\n     * with the given point\n     * @param  point  The point to query\n     * @param  results  The array to put the results\n     */\n    IntervalNode.prototype.search = function (point, results) {\n        // If p is to the right of the rightmost point of any interval\n        // in this node and all children, there won't be any matches.\n        if (point > this.max) {\n            return;\n        }\n        // Search left children\n        if (this.left !== null) {\n            this.left.search(point, results);\n        }\n        // Check this node\n        if (this.low <= point && this.high > point) {\n            results.push(this);\n        }\n        // If p is to the left of the time of this interval,\n        // then it can't be in any child to the right.\n        if (this.low > point) {\n            return;\n        }\n        // Search right children\n        if (this.right !== null) {\n            this.right.search(point, results);\n        }\n    };\n    /**\n     * Search the tree for nodes which are less\n     * than the given point\n     * @param  point  The point to query\n     * @param  results  The array to put the results\n     */\n    IntervalNode.prototype.searchAfter = function (point, results) {\n        // Check this node\n        if (this.low >= point) {\n            results.push(this);\n            if (this.left !== null) {\n                this.left.searchAfter(point, results);\n            }\n        }\n        // search the right side\n        if (this.right !== null) {\n            this.right.searchAfter(point, results);\n        }\n    };\n    /**\n     * Invoke the callback on this element and both it's branches\n     * @param  {Function}  callback\n     */\n    IntervalNode.prototype.traverse = function (callback) {\n        callback(this);\n        if (this.left !== null) {\n            this.left.traverse(callback);\n        }\n        if (this.right !== null) {\n            this.right.traverse(callback);\n        }\n    };\n    /**\n     * Update the height of the node\n     */\n    IntervalNode.prototype.updateHeight = function () {\n        if (this.left !== null && this.right !== null) {\n            this.height = Math.max(this.left.height, this.right.height) + 1;\n        }\n        else if (this.right !== null) {\n            this.height = this.right.height + 1;\n        }\n        else if (this.left !== null) {\n            this.height = this.left.height + 1;\n        }\n        else {\n            this.height = 0;\n        }\n    };\n    /**\n     * Update the height of the node\n     */\n    IntervalNode.prototype.updateMax = function () {\n        this.max = this.high;\n        if (this.left !== null) {\n            this.max = Math.max(this.max, this.left.max);\n        }\n        if (this.right !== null) {\n            this.max = Math.max(this.max, this.right.max);\n        }\n    };\n    /**\n     * The balance is how the leafs are distributed on the node\n     * @return  Negative numbers are balanced to the right\n     */\n    IntervalNode.prototype.getBalance = function () {\n        var balance = 0;\n        if (this.left !== null && this.right !== null) {\n            balance = this.left.height - this.right.height;\n        }\n        else if (this.left !== null) {\n            balance = this.left.height + 1;\n        }\n        else if (this.right !== null) {\n            balance = -(this.right.height + 1);\n        }\n        return balance;\n    };\n    /**\n     * @returns true if this node is the left child of its parent\n     */\n    IntervalNode.prototype.isLeftChild = function () {\n        return this.parent !== null && this.parent.left === this;\n    };\n    Object.defineProperty(IntervalNode.prototype, \"left\", {\n        /**\n         * get/set the left node\n         */\n        get: function () {\n            return this._left;\n        },\n        set: function (node) {\n            this._left = node;\n            if (node !== null) {\n                node.parent = this;\n            }\n            this.updateHeight();\n            this.updateMax();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(IntervalNode.prototype, \"right\", {\n        /**\n         * get/set the right node\n         */\n        get: function () {\n            return this._right;\n        },\n        set: function (node) {\n            this._right = node;\n            if (node !== null) {\n                node.parent = this;\n            }\n            this.updateHeight();\n            this.updateMax();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * null out references.\n     */\n    IntervalNode.prototype.dispose = function () {\n        this.parent = null;\n        this._left = null;\n        this._right = null;\n        this.event = null;\n    };\n    return IntervalNode;\n}());\n//# sourceMappingURL=IntervalTimeline.js.map"]},"metadata":{},"sourceType":"module"}