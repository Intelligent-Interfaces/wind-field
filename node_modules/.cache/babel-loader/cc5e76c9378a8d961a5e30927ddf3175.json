{"ast":null,"code":"/*! Source code licensed under Apache License 2.0. Copyright Â© 2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { MultiTouchSpace } from './Space';\nimport { VisualForm, Font } from \"./Form\";\nimport { Pt, Group, Bound } from \"./Pt\";\nimport { Const } from \"./Util\";\nimport { Typography as Typo } from \"./Typography\";\nimport { Rectangle } from './Op';\nexport class CanvasSpace extends MultiTouchSpace {\n  constructor(elem, callback) {\n    super();\n    this._pixelScale = 1;\n    this._autoResize = true;\n    this._bgcolor = \"#e1e9f0\";\n    this._offscreen = false;\n    this._initialResize = false;\n    var _selector = null;\n    var _existed = false;\n    this.id = \"pt\";\n\n    if (elem instanceof Element) {\n      _selector = elem;\n      this.id = \"pts_existing_space\";\n    } else {\n      let id = elem;\n      id = elem[0] === \"#\" || elem[0] === \".\" ? elem : \"#\" + elem;\n      _selector = document.querySelector(id);\n      _existed = true;\n      this.id = id.substr(1);\n    }\n\n    if (!_selector) {\n      this._container = this._createElement(\"div\", this.id + \"_container\");\n      this._canvas = this._createElement(\"canvas\", this.id);\n\n      this._container.appendChild(this._canvas);\n\n      document.body.appendChild(this._container);\n      _existed = false;\n    } else if (_selector.nodeName.toLowerCase() != \"canvas\") {\n      this._container = _selector;\n      this._canvas = this._createElement(\"canvas\", this.id + \"_canvas\");\n\n      this._container.appendChild(this._canvas);\n\n      this._initialResize = true;\n    } else {\n      this._canvas = _selector;\n      this._container = _selector.parentElement;\n      this._autoResize = false;\n    }\n\n    setTimeout(this._ready.bind(this, callback), 100);\n    this._ctx = this._canvas.getContext('2d');\n  }\n\n  _createElement(elem = \"div\", id) {\n    let d = document.createElement(elem);\n    d.setAttribute(\"id\", id);\n    return d;\n  }\n\n  _ready(callback) {\n    if (!this._container) throw new Error(`Cannot initiate #${this.id} element`);\n    this._isReady = true;\n\n    this._resizeHandler(null);\n\n    this.clear(this._bgcolor);\n\n    this._canvas.dispatchEvent(new Event(\"ready\"));\n\n    for (let k in this.players) {\n      if (this.players.hasOwnProperty(k)) {\n        if (this.players[k].start) this.players[k].start(this.bound.clone(), this);\n      }\n    }\n\n    this._pointer = this.center;\n    this._initialResize = false;\n    if (callback) callback(this.bound, this._canvas);\n  }\n\n  setup(opt) {\n    if (opt.bgcolor) this._bgcolor = opt.bgcolor;\n    this.autoResize = opt.resize != undefined ? opt.resize : false;\n\n    if (opt.retina !== false) {\n      let r1 = window.devicePixelRatio || 1;\n      let r2 = this._ctx.webkitBackingStorePixelRatio || this._ctx.mozBackingStorePixelRatio || this._ctx.msBackingStorePixelRatio || this._ctx.oBackingStorePixelRatio || this._ctx.backingStorePixelRatio || 1;\n      this._pixelScale = Math.max(1, r1 / r2);\n    }\n\n    if (opt.offscreen) {\n      this._offscreen = true;\n      this._offCanvas = this._createElement(\"canvas\", this.id + \"_offscreen\");\n      this._offCtx = this._offCanvas.getContext('2d');\n    } else {\n      this._offscreen = false;\n    }\n\n    return this;\n  }\n\n  set autoResize(auto) {\n    this._autoResize = auto;\n\n    if (auto) {\n      window.addEventListener('resize', this._resizeHandler.bind(this));\n    } else {\n      window.removeEventListener('resize', this._resizeHandler.bind(this));\n    }\n  }\n\n  get autoResize() {\n    return this._autoResize;\n  }\n\n  resize(b, evt) {\n    this.bound = b;\n    this._canvas.width = this.bound.size.x * this._pixelScale;\n    this._canvas.height = this.bound.size.y * this._pixelScale;\n    this._canvas.style.width = Math.floor(this.bound.size.x) + \"px\";\n    this._canvas.style.height = Math.floor(this.bound.size.y) + \"px\";\n\n    if (this._offscreen) {\n      this._offCanvas.width = this.bound.size.x * this._pixelScale;\n      this._offCanvas.height = this.bound.size.y * this._pixelScale;\n    }\n\n    if (this._pixelScale != 1) {\n      this._ctx.scale(this._pixelScale, this._pixelScale);\n\n      this._ctx.translate(0.5, 0.5);\n\n      if (this._offscreen) {\n        this._offCtx.scale(this._pixelScale, this._pixelScale);\n\n        this._offCtx.translate(0.5, 0.5);\n      }\n    }\n\n    for (let k in this.players) {\n      if (this.players.hasOwnProperty(k)) {\n        let p = this.players[k];\n        if (p.resize) p.resize(this.bound, evt);\n      }\n    }\n\n    this.render(this._ctx);\n    if (evt && !this.isPlaying) this.playOnce(0);\n    return this;\n  }\n\n  _resizeHandler(evt) {\n    let b = this._autoResize || this._initialResize ? this._container.getBoundingClientRect() : this._canvas.getBoundingClientRect();\n\n    if (b) {\n      let box = Bound.fromBoundingRect(b);\n      box.center = box.center.add(window.pageXOffset, window.pageYOffset);\n      this.resize(box, evt);\n    }\n  }\n\n  set background(bg) {\n    this._bgcolor = bg;\n  }\n\n  get background() {\n    return this._bgcolor;\n  }\n\n  get pixelScale() {\n    return this._pixelScale;\n  }\n\n  get hasOffscreen() {\n    return this._offscreen;\n  }\n\n  get offscreenCtx() {\n    return this._offCtx;\n  }\n\n  get offscreenCanvas() {\n    return this._offCanvas;\n  }\n\n  getForm() {\n    return new CanvasForm(this);\n  }\n\n  get element() {\n    return this._canvas;\n  }\n\n  get parent() {\n    return this._container;\n  }\n\n  get ready() {\n    return this._isReady;\n  }\n\n  get ctx() {\n    return this._ctx;\n  }\n\n  clear(bg) {\n    if (bg) this._bgcolor = bg;\n    let lastColor = this._ctx.fillStyle;\n\n    if (this._bgcolor && this._bgcolor != \"transparent\") {\n      this._ctx.fillStyle = this._bgcolor;\n\n      this._ctx.fillRect(-1, -1, this._canvas.width + 1, this._canvas.height + 1);\n    } else {\n      this._ctx.clearRect(-1, -1, this._canvas.width + 1, this._canvas.height + 1);\n    }\n\n    this._ctx.fillStyle = lastColor;\n    return this;\n  }\n\n  clearOffscreen(bg) {\n    if (this._offscreen) {\n      if (bg) {\n        this._offCtx.fillStyle = bg;\n\n        this._offCtx.fillRect(-1, -1, this._canvas.width + 1, this._canvas.height + 1);\n      } else {\n        this._offCtx.clearRect(-1, -1, this._offCanvas.width + 1, this._offCanvas.height + 1);\n      }\n    }\n\n    return this;\n  }\n\n  playItems(time) {\n    if (this._isReady) {\n      this._ctx.save();\n\n      if (this._offscreen) this._offCtx.save();\n      super.playItems(time);\n\n      this._ctx.restore();\n\n      if (this._offscreen) this._offCtx.restore();\n      this.render(this._ctx);\n    }\n  }\n\n}\nexport class CanvasForm extends VisualForm {\n  constructor(space) {\n    super();\n    this._style = {\n      fillStyle: \"#f03\",\n      strokeStyle: \"#fff\",\n      lineWidth: 1,\n      lineJoin: \"bevel\",\n      lineCap: \"butt\",\n      globalAlpha: 1\n    };\n    this._space = space;\n\n    this._space.add({\n      start: () => {\n        this._ctx = this._space.ctx;\n        this._ctx.fillStyle = this._style.fillStyle;\n        this._ctx.strokeStyle = this._style.strokeStyle;\n        this._ctx.lineJoin = \"bevel\";\n        this._ctx.font = this._font.value;\n        this._ready = true;\n      }\n    });\n  }\n\n  get space() {\n    return this._space;\n  }\n\n  useOffscreen(off = true, clear = false) {\n    if (clear) this._space.clearOffscreen(typeof clear == \"string\" ? clear : null);\n    this._ctx = this._space.hasOffscreen && off ? this._space.offscreenCtx : this._space.ctx;\n    return this;\n  }\n\n  renderOffscreen(offset = [0, 0]) {\n    if (this._space.hasOffscreen) {\n      this._space.ctx.drawImage(this._space.offscreenCanvas, offset[0], offset[1], this._space.width, this._space.height);\n    }\n  }\n\n  alpha(a) {\n    this._ctx.globalAlpha = a;\n    this._style.globalAlpha = a;\n    return this;\n  }\n\n  fill(c) {\n    if (typeof c == \"boolean\") {\n      this.filled = c;\n    } else {\n      this.filled = true;\n      this._style.fillStyle = c;\n      this._ctx.fillStyle = c;\n    }\n\n    return this;\n  }\n\n  stroke(c, width, linejoin, linecap) {\n    if (typeof c == \"boolean\") {\n      this.stroked = c;\n    } else {\n      this.stroked = true;\n      this._style.strokeStyle = c;\n      this._ctx.strokeStyle = c;\n\n      if (width) {\n        this._ctx.lineWidth = width;\n        this._style.lineWidth = width;\n      }\n\n      if (linejoin) {\n        this._ctx.lineJoin = linejoin;\n        this._style.lineJoin = linejoin;\n      }\n\n      if (linecap) {\n        this._ctx.lineCap = linecap;\n        this._style.lineCap = linecap;\n      }\n    }\n\n    return this;\n  }\n\n  dash(segments = true, offset = 0) {\n    if (!segments) {\n      this._ctx.setLineDash([]);\n\n      this._ctx.lineDashOffset = 0;\n    } else {\n      if (segments === true) {\n        segments = [5, 5];\n      }\n\n      this._ctx.setLineDash([segments[0], segments[1]]);\n\n      this._ctx.lineDashOffset = offset;\n    }\n\n    return this;\n  }\n\n  font(sizeOrFont, weight, style, lineHeight, family) {\n    if (typeof sizeOrFont == \"number\") {\n      this._font.size = sizeOrFont;\n      if (family) this._font.face = family;\n      if (weight) this._font.weight = weight;\n      if (style) this._font.style = style;\n      if (lineHeight) this._font.lineHeight = lineHeight;\n    } else {\n      this._font = sizeOrFont;\n    }\n\n    this._ctx.font = this._font.value;\n    if (this._estimateTextWidth) this.fontWidthEstimate(true);\n    return this;\n  }\n\n  fontWidthEstimate(estimate = true) {\n    this._estimateTextWidth = estimate ? Typo.textWidthEstimator(c => this._ctx.measureText(c).width) : undefined;\n    return this;\n  }\n\n  getTextWidth(c) {\n    return !this._estimateTextWidth ? this._ctx.measureText(c + \" .\").width : this._estimateTextWidth(c);\n  }\n\n  _textTruncate(str, width, tail = \"\") {\n    return Typo.truncate(this.getTextWidth.bind(this), str, width, tail);\n  }\n\n  _textAlign(box, vertical, offset, center) {\n    if (!center) center = Rectangle.center(box);\n    var px = box[0][0];\n\n    if (this._ctx.textAlign == \"end\" || this._ctx.textAlign == \"right\") {\n      px = box[1][0];\n    } else if (this._ctx.textAlign == \"center\" || this._ctx.textAlign == \"middle\") {\n      px = center[0];\n    }\n\n    var py = center[1];\n\n    if (vertical == \"top\" || vertical == \"start\") {\n      py = box[0][1];\n    } else if (vertical == \"end\" || vertical == \"bottom\") {\n      py = box[1][1];\n    }\n\n    return offset ? new Pt(px + offset[0], py + offset[1]) : new Pt(px, py);\n  }\n\n  reset() {\n    for (let k in this._style) {\n      if (this._style.hasOwnProperty(k)) {\n        this._ctx[k] = this._style[k];\n      }\n    }\n\n    this._font = new Font();\n    this._ctx.font = this._font.value;\n    return this;\n  }\n\n  _paint() {\n    if (this._filled) this._ctx.fill();\n    if (this._stroked) this._ctx.stroke();\n  }\n\n  point(p, radius = 5, shape = \"square\") {\n    if (!p) return;\n    if (!CanvasForm[shape]) throw new Error(`${shape} is not a static function of CanvasForm`);\n    CanvasForm[shape](this._ctx, p, radius);\n\n    this._paint();\n\n    return this;\n  }\n\n  static circle(ctx, pt, radius = 10) {\n    if (!pt) return;\n    ctx.beginPath();\n    ctx.arc(pt[0], pt[1], radius, 0, Const.two_pi, false);\n    ctx.closePath();\n  }\n\n  circle(pts) {\n    CanvasForm.circle(this._ctx, pts[0], pts[1][0]);\n\n    this._paint();\n\n    return this;\n  }\n\n  static ellipse(ctx, pt, radius, rotation = 0, startAngle = 0, endAngle = Const.two_pi, cc = false) {\n    if (!pt || !radius) return;\n    ctx.beginPath();\n    ctx.ellipse(pt[0], pt[1], radius[0], radius[1], rotation, startAngle, endAngle, cc);\n  }\n\n  ellipse(pt, radius, rotation = 0, startAngle = 0, endAngle = Const.two_pi, cc = false) {\n    CanvasForm.ellipse(this._ctx, pt, radius, rotation, startAngle, endAngle, cc);\n\n    this._paint();\n\n    return this;\n  }\n\n  static arc(ctx, pt, radius, startAngle, endAngle, cc) {\n    if (!pt) return;\n    ctx.beginPath();\n    ctx.arc(pt[0], pt[1], radius, startAngle, endAngle, cc);\n  }\n\n  arc(pt, radius, startAngle, endAngle, cc) {\n    CanvasForm.arc(this._ctx, pt, radius, startAngle, endAngle, cc);\n\n    this._paint();\n\n    return this;\n  }\n\n  static square(ctx, pt, halfsize) {\n    if (!pt) return;\n    let x1 = pt[0] - halfsize;\n    let y1 = pt[1] - halfsize;\n    let x2 = pt[0] + halfsize;\n    let y2 = pt[1] + halfsize;\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x1, y2);\n    ctx.lineTo(x2, y2);\n    ctx.lineTo(x2, y1);\n    ctx.closePath();\n  }\n\n  square(pt, halfsize) {\n    CanvasForm.square(this._ctx, pt, halfsize);\n\n    this._paint();\n\n    return this;\n  }\n\n  static line(ctx, pts) {\n    if (pts.length < 2) return;\n    ctx.beginPath();\n    ctx.moveTo(pts[0][0], pts[0][1]);\n\n    for (let i = 1, len = pts.length; i < len; i++) {\n      if (pts[i]) ctx.lineTo(pts[i][0], pts[i][1]);\n    }\n  }\n\n  line(pts) {\n    CanvasForm.line(this._ctx, pts);\n\n    this._paint();\n\n    return this;\n  }\n\n  static polygon(ctx, pts) {\n    if (pts.length < 2) return;\n    ctx.beginPath();\n    ctx.moveTo(pts[0][0], pts[0][1]);\n\n    for (let i = 1, len = pts.length; i < len; i++) {\n      if (pts[i]) ctx.lineTo(pts[i][0], pts[i][1]);\n    }\n\n    ctx.closePath();\n  }\n\n  polygon(pts) {\n    CanvasForm.polygon(this._ctx, pts);\n\n    this._paint();\n\n    return this;\n  }\n\n  static rect(ctx, pts) {\n    if (pts.length < 2) return;\n    ctx.beginPath();\n    ctx.moveTo(pts[0][0], pts[0][1]);\n    ctx.lineTo(pts[0][0], pts[1][1]);\n    ctx.lineTo(pts[1][0], pts[1][1]);\n    ctx.lineTo(pts[1][0], pts[0][1]);\n    ctx.closePath();\n  }\n\n  rect(pts) {\n    CanvasForm.rect(this._ctx, pts);\n\n    this._paint();\n\n    return this;\n  }\n\n  static image(ctx, img, target = new Pt(), orig) {\n    if (typeof target[0] === \"number\") {\n      ctx.drawImage(img, target[0], target[1]);\n    } else {\n      let t = target;\n\n      if (orig) {\n        ctx.drawImage(img, orig[0][0], orig[0][1], orig[1][0] - orig[0][0], orig[1][1] - orig[0][1], t[0][0], t[0][1], t[1][0] - t[0][0], t[1][1] - t[0][1]);\n      } else {\n        ctx.drawImage(img, t[0][0], t[0][1], t[1][0] - t[0][0], t[1][1] - t[0][1]);\n      }\n    }\n  }\n\n  image(img, target, original) {\n    CanvasForm.image(this._ctx, img, target, original);\n    return this;\n  }\n\n  static text(ctx, pt, txt, maxWidth) {\n    if (!pt) return;\n    ctx.fillText(txt, pt[0], pt[1], maxWidth);\n  }\n\n  text(pt, txt, maxWidth) {\n    CanvasForm.text(this._ctx, pt, txt, maxWidth);\n    return this;\n  }\n\n  textBox(box, txt, verticalAlign = \"middle\", tail = \"\", overrideBaseline = true) {\n    if (overrideBaseline) this._ctx.textBaseline = verticalAlign;\n    let size = Rectangle.size(box);\n\n    let t = this._textTruncate(txt, size[0], tail);\n\n    this.text(this._textAlign(box, verticalAlign), t[0]);\n    return this;\n  }\n\n  paragraphBox(box, txt, lineHeight = 1.2, verticalAlign = \"top\", crop = true) {\n    let size = Rectangle.size(box);\n    this._ctx.textBaseline = \"top\";\n    let lstep = this._font.size * lineHeight;\n\n    let nextLine = (sub, buffer = [], cc = 0) => {\n      if (!sub) return buffer;\n      if (crop && cc * lstep > size[1] - lstep * 2) return buffer;\n      if (cc > 10000) throw new Error(\"max recursion reached (10000)\");\n\n      let t = this._textTruncate(sub, size[0], \"\");\n\n      let newln = t[0].indexOf(\"\\n\");\n\n      if (newln >= 0) {\n        buffer.push(t[0].substr(0, newln));\n        return nextLine(sub.substr(newln + 1), buffer, cc + 1);\n      }\n\n      let dt = t[0].lastIndexOf(\" \") + 1;\n      if (dt <= 0 || t[1] === sub.length) dt = undefined;\n      let line = t[0].substr(0, dt);\n      buffer.push(line);\n      return t[1] <= 0 || t[1] === sub.length ? buffer : nextLine(sub.substr(dt || t[1]), buffer, cc + 1);\n    };\n\n    let lines = nextLine(txt);\n    let lsize = lines.length * lstep;\n    let lbox = box;\n\n    if (verticalAlign == \"middle\" || verticalAlign == \"center\") {\n      let lpad = (size[1] - lsize) / 2;\n      if (crop) lpad = Math.max(0, lpad);\n      lbox = new Group(box[0].$add(0, lpad), box[1].$subtract(0, lpad));\n    } else if (verticalAlign == \"bottom\") {\n      lbox = new Group(box[0].$add(0, size[1] - lsize), box[1]);\n    } else {\n      lbox = new Group(box[0], box[0].$add(size[0], lsize));\n    }\n\n    let center = Rectangle.center(lbox);\n\n    for (let i = 0, len = lines.length; i < len; i++) {\n      this.text(this._textAlign(lbox, \"top\", [0, i * lstep], center), lines[i]);\n    }\n\n    return this;\n  }\n\n  alignText(alignment = \"left\", baseline = \"alphabetic\") {\n    if (baseline == \"center\") baseline = \"middle\";\n    if (baseline == \"baseline\") baseline = \"alphabetic\";\n    this._ctx.textAlign = alignment;\n    this._ctx.textBaseline = baseline;\n    return this;\n  }\n\n  log(txt) {\n    let w = this._ctx.measureText(txt).width + 20;\n    this.stroke(false).fill(\"rgba(0,0,0,.4)\").rect([[0, 0], [w, 20]]);\n    this.fill(\"#fff\").text([10, 14], txt);\n    return this;\n  }\n\n}","map":{"version":3,"sources":["/Users/erickoduniyi/Desktop/Work/multi_media_signal_processing/skeuomorphic-synth-master/node_modules/pts/dist/es2015/Canvas.js"],"names":["MultiTouchSpace","VisualForm","Font","Pt","Group","Bound","Const","Typography","Typo","Rectangle","CanvasSpace","constructor","elem","callback","_pixelScale","_autoResize","_bgcolor","_offscreen","_initialResize","_selector","_existed","id","Element","document","querySelector","substr","_container","_createElement","_canvas","appendChild","body","nodeName","toLowerCase","parentElement","setTimeout","_ready","bind","_ctx","getContext","d","createElement","setAttribute","Error","_isReady","_resizeHandler","clear","dispatchEvent","Event","k","players","hasOwnProperty","start","bound","clone","_pointer","center","setup","opt","bgcolor","autoResize","resize","undefined","retina","r1","window","devicePixelRatio","r2","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","Math","max","offscreen","_offCanvas","_offCtx","auto","addEventListener","removeEventListener","b","evt","width","size","x","height","y","style","floor","scale","translate","p","render","isPlaying","playOnce","getBoundingClientRect","box","fromBoundingRect","add","pageXOffset","pageYOffset","background","bg","pixelScale","hasOffscreen","offscreenCtx","offscreenCanvas","getForm","CanvasForm","element","parent","ready","ctx","lastColor","fillStyle","fillRect","clearRect","clearOffscreen","playItems","time","save","restore","space","_style","strokeStyle","lineWidth","lineJoin","lineCap","globalAlpha","_space","font","_font","value","useOffscreen","off","renderOffscreen","offset","drawImage","alpha","a","fill","c","filled","stroke","linejoin","linecap","stroked","dash","segments","setLineDash","lineDashOffset","sizeOrFont","weight","lineHeight","family","face","_estimateTextWidth","fontWidthEstimate","estimate","textWidthEstimator","measureText","getTextWidth","_textTruncate","str","tail","truncate","_textAlign","vertical","px","textAlign","py","reset","_paint","_filled","_stroked","point","radius","shape","circle","pt","beginPath","arc","two_pi","closePath","pts","ellipse","rotation","startAngle","endAngle","cc","square","halfsize","x1","y1","x2","y2","moveTo","lineTo","line","length","i","len","polygon","rect","image","img","target","orig","t","original","text","txt","maxWidth","fillText","textBox","verticalAlign","overrideBaseline","textBaseline","paragraphBox","crop","lstep","nextLine","sub","buffer","newln","indexOf","push","dt","lastIndexOf","lines","lsize","lbox","lpad","$add","$subtract","alignText","alignment","baseline","log","w"],"mappings":"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","sourcesContent":["/*! Source code licensed under Apache License 2.0. Copyright Â© 2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { MultiTouchSpace } from './Space';\nimport { VisualForm, Font } from \"./Form\";\nimport { Pt, Group, Bound } from \"./Pt\";\nimport { Const } from \"./Util\";\nimport { Typography as Typo } from \"./Typography\";\nimport { Rectangle } from './Op';\nexport class CanvasSpace extends MultiTouchSpace {\n    constructor(elem, callback) {\n        super();\n        this._pixelScale = 1;\n        this._autoResize = true;\n        this._bgcolor = \"#e1e9f0\";\n        this._offscreen = false;\n        this._initialResize = false;\n        var _selector = null;\n        var _existed = false;\n        this.id = \"pt\";\n        if (elem instanceof Element) {\n            _selector = elem;\n            this.id = \"pts_existing_space\";\n        }\n        else {\n            let id = elem;\n            id = (elem[0] === \"#\" || elem[0] === \".\") ? elem : \"#\" + elem;\n            _selector = document.querySelector(id);\n            _existed = true;\n            this.id = id.substr(1);\n        }\n        if (!_selector) {\n            this._container = this._createElement(\"div\", this.id + \"_container\");\n            this._canvas = this._createElement(\"canvas\", this.id);\n            this._container.appendChild(this._canvas);\n            document.body.appendChild(this._container);\n            _existed = false;\n        }\n        else if (_selector.nodeName.toLowerCase() != \"canvas\") {\n            this._container = _selector;\n            this._canvas = this._createElement(\"canvas\", this.id + \"_canvas\");\n            this._container.appendChild(this._canvas);\n            this._initialResize = true;\n        }\n        else {\n            this._canvas = _selector;\n            this._container = _selector.parentElement;\n            this._autoResize = false;\n        }\n        setTimeout(this._ready.bind(this, callback), 100);\n        this._ctx = this._canvas.getContext('2d');\n    }\n    _createElement(elem = \"div\", id) {\n        let d = document.createElement(elem);\n        d.setAttribute(\"id\", id);\n        return d;\n    }\n    _ready(callback) {\n        if (!this._container)\n            throw new Error(`Cannot initiate #${this.id} element`);\n        this._isReady = true;\n        this._resizeHandler(null);\n        this.clear(this._bgcolor);\n        this._canvas.dispatchEvent(new Event(\"ready\"));\n        for (let k in this.players) {\n            if (this.players.hasOwnProperty(k)) {\n                if (this.players[k].start)\n                    this.players[k].start(this.bound.clone(), this);\n            }\n        }\n        this._pointer = this.center;\n        this._initialResize = false;\n        if (callback)\n            callback(this.bound, this._canvas);\n    }\n    setup(opt) {\n        if (opt.bgcolor)\n            this._bgcolor = opt.bgcolor;\n        this.autoResize = (opt.resize != undefined) ? opt.resize : false;\n        if (opt.retina !== false) {\n            let r1 = window.devicePixelRatio || 1;\n            let r2 = this._ctx.webkitBackingStorePixelRatio || this._ctx.mozBackingStorePixelRatio || this._ctx.msBackingStorePixelRatio || this._ctx.oBackingStorePixelRatio || this._ctx.backingStorePixelRatio || 1;\n            this._pixelScale = Math.max(1, r1 / r2);\n        }\n        if (opt.offscreen) {\n            this._offscreen = true;\n            this._offCanvas = this._createElement(\"canvas\", this.id + \"_offscreen\");\n            this._offCtx = this._offCanvas.getContext('2d');\n        }\n        else {\n            this._offscreen = false;\n        }\n        return this;\n    }\n    set autoResize(auto) {\n        this._autoResize = auto;\n        if (auto) {\n            window.addEventListener('resize', this._resizeHandler.bind(this));\n        }\n        else {\n            window.removeEventListener('resize', this._resizeHandler.bind(this));\n        }\n    }\n    get autoResize() { return this._autoResize; }\n    resize(b, evt) {\n        this.bound = b;\n        this._canvas.width = this.bound.size.x * this._pixelScale;\n        this._canvas.height = this.bound.size.y * this._pixelScale;\n        this._canvas.style.width = Math.floor(this.bound.size.x) + \"px\";\n        this._canvas.style.height = Math.floor(this.bound.size.y) + \"px\";\n        if (this._offscreen) {\n            this._offCanvas.width = this.bound.size.x * this._pixelScale;\n            this._offCanvas.height = this.bound.size.y * this._pixelScale;\n        }\n        if (this._pixelScale != 1) {\n            this._ctx.scale(this._pixelScale, this._pixelScale);\n            this._ctx.translate(0.5, 0.5);\n            if (this._offscreen) {\n                this._offCtx.scale(this._pixelScale, this._pixelScale);\n                this._offCtx.translate(0.5, 0.5);\n            }\n        }\n        for (let k in this.players) {\n            if (this.players.hasOwnProperty(k)) {\n                let p = this.players[k];\n                if (p.resize)\n                    p.resize(this.bound, evt);\n            }\n        }\n        this.render(this._ctx);\n        if (evt && !this.isPlaying)\n            this.playOnce(0);\n        return this;\n    }\n    _resizeHandler(evt) {\n        let b = (this._autoResize || this._initialResize) ? this._container.getBoundingClientRect() : this._canvas.getBoundingClientRect();\n        if (b) {\n            let box = Bound.fromBoundingRect(b);\n            box.center = box.center.add(window.pageXOffset, window.pageYOffset);\n            this.resize(box, evt);\n        }\n    }\n    set background(bg) { this._bgcolor = bg; }\n    get background() { return this._bgcolor; }\n    get pixelScale() {\n        return this._pixelScale;\n    }\n    get hasOffscreen() {\n        return this._offscreen;\n    }\n    get offscreenCtx() { return this._offCtx; }\n    get offscreenCanvas() { return this._offCanvas; }\n    getForm() { return new CanvasForm(this); }\n    get element() {\n        return this._canvas;\n    }\n    get parent() {\n        return this._container;\n    }\n    get ready() {\n        return this._isReady;\n    }\n    get ctx() { return this._ctx; }\n    clear(bg) {\n        if (bg)\n            this._bgcolor = bg;\n        let lastColor = this._ctx.fillStyle;\n        if (this._bgcolor && this._bgcolor != \"transparent\") {\n            this._ctx.fillStyle = this._bgcolor;\n            this._ctx.fillRect(-1, -1, this._canvas.width + 1, this._canvas.height + 1);\n        }\n        else {\n            this._ctx.clearRect(-1, -1, this._canvas.width + 1, this._canvas.height + 1);\n        }\n        this._ctx.fillStyle = lastColor;\n        return this;\n    }\n    clearOffscreen(bg) {\n        if (this._offscreen) {\n            if (bg) {\n                this._offCtx.fillStyle = bg;\n                this._offCtx.fillRect(-1, -1, this._canvas.width + 1, this._canvas.height + 1);\n            }\n            else {\n                this._offCtx.clearRect(-1, -1, this._offCanvas.width + 1, this._offCanvas.height + 1);\n            }\n        }\n        return this;\n    }\n    playItems(time) {\n        if (this._isReady) {\n            this._ctx.save();\n            if (this._offscreen)\n                this._offCtx.save();\n            super.playItems(time);\n            this._ctx.restore();\n            if (this._offscreen)\n                this._offCtx.restore();\n            this.render(this._ctx);\n        }\n    }\n}\nexport class CanvasForm extends VisualForm {\n    constructor(space) {\n        super();\n        this._style = {\n            fillStyle: \"#f03\", strokeStyle: \"#fff\",\n            lineWidth: 1, lineJoin: \"bevel\", lineCap: \"butt\",\n            globalAlpha: 1\n        };\n        this._space = space;\n        this._space.add({ start: () => {\n                this._ctx = this._space.ctx;\n                this._ctx.fillStyle = this._style.fillStyle;\n                this._ctx.strokeStyle = this._style.strokeStyle;\n                this._ctx.lineJoin = \"bevel\";\n                this._ctx.font = this._font.value;\n                this._ready = true;\n            } });\n    }\n    get space() { return this._space; }\n    useOffscreen(off = true, clear = false) {\n        if (clear)\n            this._space.clearOffscreen((typeof clear == \"string\") ? clear : null);\n        this._ctx = (this._space.hasOffscreen && off) ? this._space.offscreenCtx : this._space.ctx;\n        return this;\n    }\n    renderOffscreen(offset = [0, 0]) {\n        if (this._space.hasOffscreen) {\n            this._space.ctx.drawImage(this._space.offscreenCanvas, offset[0], offset[1], this._space.width, this._space.height);\n        }\n    }\n    alpha(a) {\n        this._ctx.globalAlpha = a;\n        this._style.globalAlpha = a;\n        return this;\n    }\n    fill(c) {\n        if (typeof c == \"boolean\") {\n            this.filled = c;\n        }\n        else {\n            this.filled = true;\n            this._style.fillStyle = c;\n            this._ctx.fillStyle = c;\n        }\n        return this;\n    }\n    stroke(c, width, linejoin, linecap) {\n        if (typeof c == \"boolean\") {\n            this.stroked = c;\n        }\n        else {\n            this.stroked = true;\n            this._style.strokeStyle = c;\n            this._ctx.strokeStyle = c;\n            if (width) {\n                this._ctx.lineWidth = width;\n                this._style.lineWidth = width;\n            }\n            if (linejoin) {\n                this._ctx.lineJoin = linejoin;\n                this._style.lineJoin = linejoin;\n            }\n            if (linecap) {\n                this._ctx.lineCap = linecap;\n                this._style.lineCap = linecap;\n            }\n        }\n        return this;\n    }\n    dash(segments = true, offset = 0) {\n        if (!segments) {\n            this._ctx.setLineDash([]);\n            this._ctx.lineDashOffset = 0;\n        }\n        else {\n            if (segments === true) {\n                segments = [5, 5];\n            }\n            this._ctx.setLineDash([segments[0], segments[1]]);\n            this._ctx.lineDashOffset = offset;\n        }\n        return this;\n    }\n    font(sizeOrFont, weight, style, lineHeight, family) {\n        if (typeof sizeOrFont == \"number\") {\n            this._font.size = sizeOrFont;\n            if (family)\n                this._font.face = family;\n            if (weight)\n                this._font.weight = weight;\n            if (style)\n                this._font.style = style;\n            if (lineHeight)\n                this._font.lineHeight = lineHeight;\n        }\n        else {\n            this._font = sizeOrFont;\n        }\n        this._ctx.font = this._font.value;\n        if (this._estimateTextWidth)\n            this.fontWidthEstimate(true);\n        return this;\n    }\n    fontWidthEstimate(estimate = true) {\n        this._estimateTextWidth = (estimate) ? Typo.textWidthEstimator(((c) => this._ctx.measureText(c).width)) : undefined;\n        return this;\n    }\n    getTextWidth(c) {\n        return (!this._estimateTextWidth) ? this._ctx.measureText(c + \" .\").width : this._estimateTextWidth(c);\n    }\n    _textTruncate(str, width, tail = \"\") {\n        return Typo.truncate(this.getTextWidth.bind(this), str, width, tail);\n    }\n    _textAlign(box, vertical, offset, center) {\n        if (!center)\n            center = Rectangle.center(box);\n        var px = box[0][0];\n        if (this._ctx.textAlign == \"end\" || this._ctx.textAlign == \"right\") {\n            px = box[1][0];\n        }\n        else if (this._ctx.textAlign == \"center\" || this._ctx.textAlign == \"middle\") {\n            px = center[0];\n        }\n        var py = center[1];\n        if (vertical == \"top\" || vertical == \"start\") {\n            py = box[0][1];\n        }\n        else if (vertical == \"end\" || vertical == \"bottom\") {\n            py = box[1][1];\n        }\n        return (offset) ? new Pt(px + offset[0], py + offset[1]) : new Pt(px, py);\n    }\n    reset() {\n        for (let k in this._style) {\n            if (this._style.hasOwnProperty(k)) {\n                this._ctx[k] = this._style[k];\n            }\n        }\n        this._font = new Font();\n        this._ctx.font = this._font.value;\n        return this;\n    }\n    _paint() {\n        if (this._filled)\n            this._ctx.fill();\n        if (this._stroked)\n            this._ctx.stroke();\n    }\n    point(p, radius = 5, shape = \"square\") {\n        if (!p)\n            return;\n        if (!CanvasForm[shape])\n            throw new Error(`${shape} is not a static function of CanvasForm`);\n        CanvasForm[shape](this._ctx, p, radius);\n        this._paint();\n        return this;\n    }\n    static circle(ctx, pt, radius = 10) {\n        if (!pt)\n            return;\n        ctx.beginPath();\n        ctx.arc(pt[0], pt[1], radius, 0, Const.two_pi, false);\n        ctx.closePath();\n    }\n    circle(pts) {\n        CanvasForm.circle(this._ctx, pts[0], pts[1][0]);\n        this._paint();\n        return this;\n    }\n    static ellipse(ctx, pt, radius, rotation = 0, startAngle = 0, endAngle = Const.two_pi, cc = false) {\n        if (!pt || !radius)\n            return;\n        ctx.beginPath();\n        ctx.ellipse(pt[0], pt[1], radius[0], radius[1], rotation, startAngle, endAngle, cc);\n    }\n    ellipse(pt, radius, rotation = 0, startAngle = 0, endAngle = Const.two_pi, cc = false) {\n        CanvasForm.ellipse(this._ctx, pt, radius, rotation, startAngle, endAngle, cc);\n        this._paint();\n        return this;\n    }\n    static arc(ctx, pt, radius, startAngle, endAngle, cc) {\n        if (!pt)\n            return;\n        ctx.beginPath();\n        ctx.arc(pt[0], pt[1], radius, startAngle, endAngle, cc);\n    }\n    arc(pt, radius, startAngle, endAngle, cc) {\n        CanvasForm.arc(this._ctx, pt, radius, startAngle, endAngle, cc);\n        this._paint();\n        return this;\n    }\n    static square(ctx, pt, halfsize) {\n        if (!pt)\n            return;\n        let x1 = pt[0] - halfsize;\n        let y1 = pt[1] - halfsize;\n        let x2 = pt[0] + halfsize;\n        let y2 = pt[1] + halfsize;\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x1, y2);\n        ctx.lineTo(x2, y2);\n        ctx.lineTo(x2, y1);\n        ctx.closePath();\n    }\n    square(pt, halfsize) {\n        CanvasForm.square(this._ctx, pt, halfsize);\n        this._paint();\n        return this;\n    }\n    static line(ctx, pts) {\n        if (pts.length < 2)\n            return;\n        ctx.beginPath();\n        ctx.moveTo(pts[0][0], pts[0][1]);\n        for (let i = 1, len = pts.length; i < len; i++) {\n            if (pts[i])\n                ctx.lineTo(pts[i][0], pts[i][1]);\n        }\n    }\n    line(pts) {\n        CanvasForm.line(this._ctx, pts);\n        this._paint();\n        return this;\n    }\n    static polygon(ctx, pts) {\n        if (pts.length < 2)\n            return;\n        ctx.beginPath();\n        ctx.moveTo(pts[0][0], pts[0][1]);\n        for (let i = 1, len = pts.length; i < len; i++) {\n            if (pts[i])\n                ctx.lineTo(pts[i][0], pts[i][1]);\n        }\n        ctx.closePath();\n    }\n    polygon(pts) {\n        CanvasForm.polygon(this._ctx, pts);\n        this._paint();\n        return this;\n    }\n    static rect(ctx, pts) {\n        if (pts.length < 2)\n            return;\n        ctx.beginPath();\n        ctx.moveTo(pts[0][0], pts[0][1]);\n        ctx.lineTo(pts[0][0], pts[1][1]);\n        ctx.lineTo(pts[1][0], pts[1][1]);\n        ctx.lineTo(pts[1][0], pts[0][1]);\n        ctx.closePath();\n    }\n    rect(pts) {\n        CanvasForm.rect(this._ctx, pts);\n        this._paint();\n        return this;\n    }\n    static image(ctx, img, target = new Pt(), orig) {\n        if (typeof target[0] === \"number\") {\n            ctx.drawImage(img, target[0], target[1]);\n        }\n        else {\n            let t = target;\n            if (orig) {\n                ctx.drawImage(img, orig[0][0], orig[0][1], orig[1][0] - orig[0][0], orig[1][1] - orig[0][1], t[0][0], t[0][1], t[1][0] - t[0][0], t[1][1] - t[0][1]);\n            }\n            else {\n                ctx.drawImage(img, t[0][0], t[0][1], t[1][0] - t[0][0], t[1][1] - t[0][1]);\n            }\n        }\n    }\n    image(img, target, original) {\n        CanvasForm.image(this._ctx, img, target, original);\n        return this;\n    }\n    static text(ctx, pt, txt, maxWidth) {\n        if (!pt)\n            return;\n        ctx.fillText(txt, pt[0], pt[1], maxWidth);\n    }\n    text(pt, txt, maxWidth) {\n        CanvasForm.text(this._ctx, pt, txt, maxWidth);\n        return this;\n    }\n    textBox(box, txt, verticalAlign = \"middle\", tail = \"\", overrideBaseline = true) {\n        if (overrideBaseline)\n            this._ctx.textBaseline = verticalAlign;\n        let size = Rectangle.size(box);\n        let t = this._textTruncate(txt, size[0], tail);\n        this.text(this._textAlign(box, verticalAlign), t[0]);\n        return this;\n    }\n    paragraphBox(box, txt, lineHeight = 1.2, verticalAlign = \"top\", crop = true) {\n        let size = Rectangle.size(box);\n        this._ctx.textBaseline = \"top\";\n        let lstep = this._font.size * lineHeight;\n        let nextLine = (sub, buffer = [], cc = 0) => {\n            if (!sub)\n                return buffer;\n            if (crop && cc * lstep > size[1] - lstep * 2)\n                return buffer;\n            if (cc > 10000)\n                throw new Error(\"max recursion reached (10000)\");\n            let t = this._textTruncate(sub, size[0], \"\");\n            let newln = t[0].indexOf(\"\\n\");\n            if (newln >= 0) {\n                buffer.push(t[0].substr(0, newln));\n                return nextLine(sub.substr(newln + 1), buffer, cc + 1);\n            }\n            let dt = t[0].lastIndexOf(\" \") + 1;\n            if (dt <= 0 || t[1] === sub.length)\n                dt = undefined;\n            let line = t[0].substr(0, dt);\n            buffer.push(line);\n            return (t[1] <= 0 || t[1] === sub.length) ? buffer : nextLine(sub.substr((dt || t[1])), buffer, cc + 1);\n        };\n        let lines = nextLine(txt);\n        let lsize = lines.length * lstep;\n        let lbox = box;\n        if (verticalAlign == \"middle\" || verticalAlign == \"center\") {\n            let lpad = (size[1] - lsize) / 2;\n            if (crop)\n                lpad = Math.max(0, lpad);\n            lbox = new Group(box[0].$add(0, lpad), box[1].$subtract(0, lpad));\n        }\n        else if (verticalAlign == \"bottom\") {\n            lbox = new Group(box[0].$add(0, size[1] - lsize), box[1]);\n        }\n        else {\n            lbox = new Group(box[0], box[0].$add(size[0], lsize));\n        }\n        let center = Rectangle.center(lbox);\n        for (let i = 0, len = lines.length; i < len; i++) {\n            this.text(this._textAlign(lbox, \"top\", [0, i * lstep], center), lines[i]);\n        }\n        return this;\n    }\n    alignText(alignment = \"left\", baseline = \"alphabetic\") {\n        if (baseline == \"center\")\n            baseline = \"middle\";\n        if (baseline == \"baseline\")\n            baseline = \"alphabetic\";\n        this._ctx.textAlign = alignment;\n        this._ctx.textBaseline = baseline;\n        return this;\n    }\n    log(txt) {\n        let w = this._ctx.measureText(txt).width + 20;\n        this.stroke(false).fill(\"rgba(0,0,0,.4)\").rect([[0, 0], [w, 20]]);\n        this.fill(\"#fff\").text([10, 14], txt);\n        return this;\n    }\n}\n//# sourceMappingURL=Canvas.js.map"]},"metadata":{},"sourceType":"module"}