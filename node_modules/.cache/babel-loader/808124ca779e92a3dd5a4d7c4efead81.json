{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { deepMerge, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Monophonic } from \"./Monophonic\";\nimport { Synth } from \"./Synth\";\nimport { range, timeRange } from \"../core/util/Decorator\";\n/**\n * MembraneSynth makes kick and tom sounds using a single oscillator\n * with an amplitude envelope and frequency ramp. A Tone.OmniOscillator\n * is routed through a Tone.AmplitudeEnvelope to the output. The drum\n * quality of the sound comes from the frequency envelope applied\n * during MembraneSynth.triggerAttack(note). The frequency envelope\n * starts at <code>note * .octaves</code> and ramps to <code>note</code>\n * over the duration of <code>.pitchDecay</code>.\n * @example\n * import { MembraneSynth } from \"tone\";\n * const synth = new MembraneSynth().toDestination();\n * synth.triggerAttackRelease(\"C2\", \"8n\");\n * @category Instrument\n */\n\nvar MembraneSynth =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(MembraneSynth, _super);\n\n  function MembraneSynth() {\n    var _this = _super.call(this, optionsFromArguments(MembraneSynth.getDefaults(), arguments)) || this;\n\n    _this.name = \"MembraneSynth\";\n    /**\n     * Portamento is ignored in this synth. use pitch decay instead.\n     */\n\n    _this.portamento = 0;\n    var options = optionsFromArguments(MembraneSynth.getDefaults(), arguments);\n    _this.pitchDecay = options.pitchDecay;\n    _this.octaves = options.octaves;\n    readOnly(_this, [\"oscillator\", \"envelope\"]);\n    return _this;\n  }\n\n  MembraneSynth.getDefaults = function () {\n    return deepMerge(Monophonic.getDefaults(), Synth.getDefaults(), {\n      envelope: {\n        attack: 0.001,\n        attackCurve: \"exponential\",\n        decay: 0.4,\n        release: 1.4,\n        sustain: 0.01\n      },\n      octaves: 10,\n      oscillator: {\n        type: \"sine\"\n      },\n      pitchDecay: 0.05\n    });\n  };\n\n  MembraneSynth.prototype.setNote = function (note, time) {\n    var seconds = this.toSeconds(time);\n    var hertz = this.toFrequency(note instanceof FrequencyClass ? note.toFrequency() : note);\n    var maxNote = hertz * this.octaves;\n    this.oscillator.frequency.setValueAtTime(maxNote, seconds);\n    this.oscillator.frequency.exponentialRampToValueAtTime(hertz, seconds + this.toSeconds(this.pitchDecay));\n    return this;\n  };\n\n  MembraneSynth.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    return this;\n  };\n\n  tslib_1.__decorate([range(0)], MembraneSynth.prototype, \"octaves\", void 0);\n\n  tslib_1.__decorate([timeRange(0)], MembraneSynth.prototype, \"pitchDecay\", void 0);\n\n  return MembraneSynth;\n}(Synth);\n\nexport { MembraneSynth };","map":{"version":3,"sources":["../../../Tone/instrument/MembraneSynth.ts"],"names":[],"mappings":";AAAA,SAAS,cAAT,QAA+B,wBAA/B;AAEA,SAAS,SAAT,EAAoB,oBAApB,QAAgD,uBAAhD;AACA,SAAS,QAAT,QAA2C,wBAA3C;AACA,SAAS,UAAT,QAA2B,cAA3B;AACA,SAAS,KAAT,QAAoC,SAApC;AACA,SAAS,KAAT,EAAgB,SAAhB,QAAiC,wBAAjC;AAOA;;;;;;;;;;;;;;;AAcA,IAAA,aAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAmC,EAAA,OAAA,CAAA,SAAA,CAAA,aAAA,EAAA,MAAA;;AA6BlC,WAAA,aAAA,GAAA;AAAA,QAAA,KAAA,GAEC,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,oBAAoB,CAAC,aAAa,CAAC,WAAd,EAAD,EAA8B,SAA9B,CAA1B,KAAmE,IAFpE;;AA3BS,IAAA,KAAA,CAAA,IAAA,GAAe,eAAf;AAkBT;;;;AAGS,IAAA,KAAA,CAAA,UAAA,GAAa,CAAb;AASR,QAAM,OAAO,GAAG,oBAAoB,CAAC,aAAa,CAAC,WAAd,EAAD,EAA8B,SAA9B,CAApC;AAEA,IAAA,KAAI,CAAC,UAAL,GAAkB,OAAO,CAAC,UAA1B;AACA,IAAA,KAAI,CAAC,OAAL,GAAe,OAAO,CAAC,OAAvB;AACA,IAAA,QAAQ,CAAC,KAAD,EAAO,CAAC,YAAD,EAAe,UAAf,CAAP,CAAR;;AACA;;AAEM,EAAA,aAAA,CAAA,WAAA,GAAP,YAAA;AACC,WAAO,SAAS,CAAC,UAAU,CAAC,WAAX,EAAD,EAA2B,KAAK,CAAC,WAAN,EAA3B,EAAgD;AAC/D,MAAA,QAAQ,EAAE;AACT,QAAA,MAAM,EAAE,KADC;AAET,QAAA,WAAW,EAAE,aAFJ;AAGT,QAAA,KAAK,EAAE,GAHE;AAIT,QAAA,OAAO,EAAE,GAJA;AAKT,QAAA,OAAO,EAAE;AALA,OADqD;AAQ/D,MAAA,OAAO,EAAE,EARsD;AAS/D,MAAA,UAAU,EAAE;AACX,QAAA,IAAI,EAAE;AADK,OATmD;AAY/D,MAAA,UAAU,EAAE;AAZmD,KAAhD,CAAhB;AAcA,GAfM;;AAiBP,EAAA,aAAA,CAAA,SAAA,CAAA,OAAA,GAAA,UAAQ,IAAR,EAA0C,IAA1C,EAAqD;AACpD,QAAM,OAAO,GAAG,KAAK,SAAL,CAAe,IAAf,CAAhB;AACA,QAAM,KAAK,GAAG,KAAK,WAAL,CAAiB,IAAI,YAAY,cAAhB,GAAiC,IAAI,CAAC,WAAL,EAAjC,GAAsD,IAAvE,CAAd;AACA,QAAM,OAAO,GAAG,KAAK,GAAG,KAAK,OAA7B;AACA,SAAK,UAAL,CAAgB,SAAhB,CAA0B,cAA1B,CAAyC,OAAzC,EAAkD,OAAlD;AACA,SAAK,UAAL,CAAgB,SAAhB,CAA0B,4BAA1B,CAAuD,KAAvD,EAA8D,OAAO,GAAG,KAAK,SAAL,CAAe,KAAK,UAApB,CAAxE;AACA,WAAO,IAAP;AACA,GAPD;;AASA,EAAA,aAAA,CAAA,SAAA,CAAA,OAAA,GAAA,YAAA;AACC,IAAA,MAAA,CAAA,SAAA,CAAM,OAAN,CAAa,IAAb,CAAa,IAAb;;AACA,WAAO,IAAP;AACA,GAHD;;AAvDA,EAAA,OAAA,CAAA,UAAA,CAAA,CADC,KAAK,CAAC,CAAD,CACN,CAAA,E,uBAAA,E,SAAA,E,KAAkB,CAAlB;;AAQA,EAAA,OAAA,CAAA,UAAA,CAAA,CADC,SAAS,CAAC,CAAD,CACV,CAAA,E,uBAAA,E,YAAA,E,KAAiB,CAAjB;;AAmDD,SAAA,aAAA;AAAC,CArED,CAAmC,KAAnC,CAAA;;SAAa,a","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { deepMerge, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Monophonic } from \"./Monophonic\";\nimport { Synth } from \"./Synth\";\nimport { range, timeRange } from \"../core/util/Decorator\";\n/**\n * MembraneSynth makes kick and tom sounds using a single oscillator\n * with an amplitude envelope and frequency ramp. A Tone.OmniOscillator\n * is routed through a Tone.AmplitudeEnvelope to the output. The drum\n * quality of the sound comes from the frequency envelope applied\n * during MembraneSynth.triggerAttack(note). The frequency envelope\n * starts at <code>note * .octaves</code> and ramps to <code>note</code>\n * over the duration of <code>.pitchDecay</code>.\n * @example\n * import { MembraneSynth } from \"tone\";\n * const synth = new MembraneSynth().toDestination();\n * synth.triggerAttackRelease(\"C2\", \"8n\");\n * @category Instrument\n */\nvar MembraneSynth = /** @class */ (function (_super) {\n    tslib_1.__extends(MembraneSynth, _super);\n    function MembraneSynth() {\n        var _this = _super.call(this, optionsFromArguments(MembraneSynth.getDefaults(), arguments)) || this;\n        _this.name = \"MembraneSynth\";\n        /**\n         * Portamento is ignored in this synth. use pitch decay instead.\n         */\n        _this.portamento = 0;\n        var options = optionsFromArguments(MembraneSynth.getDefaults(), arguments);\n        _this.pitchDecay = options.pitchDecay;\n        _this.octaves = options.octaves;\n        readOnly(_this, [\"oscillator\", \"envelope\"]);\n        return _this;\n    }\n    MembraneSynth.getDefaults = function () {\n        return deepMerge(Monophonic.getDefaults(), Synth.getDefaults(), {\n            envelope: {\n                attack: 0.001,\n                attackCurve: \"exponential\",\n                decay: 0.4,\n                release: 1.4,\n                sustain: 0.01,\n            },\n            octaves: 10,\n            oscillator: {\n                type: \"sine\",\n            },\n            pitchDecay: 0.05,\n        });\n    };\n    MembraneSynth.prototype.setNote = function (note, time) {\n        var seconds = this.toSeconds(time);\n        var hertz = this.toFrequency(note instanceof FrequencyClass ? note.toFrequency() : note);\n        var maxNote = hertz * this.octaves;\n        this.oscillator.frequency.setValueAtTime(maxNote, seconds);\n        this.oscillator.frequency.exponentialRampToValueAtTime(hertz, seconds + this.toSeconds(this.pitchDecay));\n        return this;\n    };\n    MembraneSynth.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        return this;\n    };\n    tslib_1.__decorate([\n        range(0)\n    ], MembraneSynth.prototype, \"octaves\", void 0);\n    tslib_1.__decorate([\n        timeRange(0)\n    ], MembraneSynth.prototype, \"pitchDecay\", void 0);\n    return MembraneSynth;\n}(Synth));\nexport { MembraneSynth };\n//# sourceMappingURL=MembraneSynth.js.map"]},"metadata":{},"sourceType":"module"}