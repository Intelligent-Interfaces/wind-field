{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { Source } from \"../source/Source\";\nimport { ToneBufferSource } from \"./buffer/ToneBufferSource\";\n/**\n * Noise is a noise generator. It uses looped noise buffers to save on performance.\n * Noise supports the noise types: \"pink\", \"white\", and \"brown\". Read more about\n * colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).\n *\n * @example\n * import { AutoFilter, Noise } from \"tone\";\n * // initialize the noise and start\n * const noise = new Noise(\"pink\").start();\n * // make an autofilter to shape the noise\n * const autoFilter = new AutoFilter({\n * \tfrequency: \"8n\",\n * \tbaseFrequency: 200,\n * \toctaves: 8\n * }).toDestination().start();\n * // connect the noise\n * noise.connect(autoFilter);\n * // start the autofilter LFO\n * autoFilter.start();\n * @category Source\n */\n\nvar Noise =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Noise, _super);\n\n  function Noise() {\n    var _this = _super.call(this, optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"])) || this;\n\n    _this.name = \"Noise\";\n    /**\n     * Private reference to the source\n     */\n\n    _this._source = null;\n    var options = optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]);\n    _this._playbackRate = options.playbackRate;\n    _this.type = options.type;\n    _this._fadeIn = options.fadeIn;\n    _this._fadeOut = options.fadeOut;\n    return _this;\n  }\n\n  Noise.getDefaults = function () {\n    return Object.assign(Source.getDefaults(), {\n      fadeIn: 0,\n      fadeOut: 0,\n      playbackRate: 1,\n      type: \"white\"\n    });\n  };\n\n  Object.defineProperty(Noise.prototype, \"type\", {\n    /**\n     * The type of the noise. Can be \"white\", \"brown\", or \"pink\".\n     * @example\n     * import { Noise } from \"tone\";\n     * const noise = new Noise().toDestination().start();\n     * noise.type = \"brown\";\n     */\n    get: function () {\n      return this._type;\n    },\n    set: function (type) {\n      assert(type in _noiseBuffers, \"Noise: invalid type: \" + type);\n\n      if (this._type !== type) {\n        this._type = type; // if it's playing, stop and restart it\n\n        if (this.state === \"started\") {\n          var now = this.now();\n\n          this._stop(now);\n\n          this._start(now);\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Noise.prototype, \"playbackRate\", {\n    /**\n     * The playback rate of the noise. Affects\n     * the \"frequency\" of the noise.\n     */\n    get: function () {\n      return this._playbackRate;\n    },\n    set: function (rate) {\n      this._playbackRate = rate;\n\n      if (this._source) {\n        this._source.playbackRate.value = rate;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * internal start method\n   */\n\n  Noise.prototype._start = function (time) {\n    var _this = this;\n\n    var buffer = _noiseBuffers[this._type];\n    this._source = new ToneBufferSource({\n      buffer: buffer,\n      context: this.context,\n      fadeIn: this._fadeIn,\n      fadeOut: this._fadeOut,\n      loop: true,\n      onended: function () {\n        return _this.onstop(_this);\n      },\n      playbackRate: this._playbackRate\n    }).connect(this.output);\n\n    this._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));\n  };\n  /**\n   * internal stop method\n   */\n\n\n  Noise.prototype._stop = function (time) {\n    if (this._source) {\n      this._source.stop(this.toSeconds(time));\n\n      this._source = null;\n    }\n  };\n\n  Object.defineProperty(Noise.prototype, \"fadeIn\", {\n    /**\n     * The fadeIn time of the amplitude envelope.\n     */\n    get: function () {\n      return this._fadeIn;\n    },\n    set: function (time) {\n      this._fadeIn = time;\n\n      if (this._source) {\n        this._source.fadeIn = this._fadeIn;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Noise.prototype, \"fadeOut\", {\n    /**\n     * The fadeOut time of the amplitude envelope.\n     */\n    get: function () {\n      return this._fadeOut;\n    },\n    set: function (time) {\n      this._fadeOut = time;\n\n      if (this._source) {\n        this._source.fadeOut = this._fadeOut;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Noise.prototype._restart = function (time) {\n    // TODO could be optimized by cancelling the buffer source 'stop'\n    this._stop(time);\n\n    this._start(time);\n  };\n  /**\n   * Clean up.\n   */\n\n\n  Noise.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    if (this._source) {\n      this._source.disconnect();\n    }\n\n    return this;\n  };\n\n  return Noise;\n}(Source);\n\nexport { Noise }; //--------------------\n// THE NOISE BUFFERS\n//--------------------\n// Noise buffer stats\n\nvar BUFFER_LENGTH = 44100 * 5;\nvar NUM_CHANNELS = 2;\n/**\n * Cache the noise buffers\n */\n\nvar _noiseCache = {\n  brown: null,\n  pink: null,\n  white: null\n};\n/**\n * The noise arrays. Generated on initialization.\n * borrowed heavily from https://github.com/zacharydenton/noise.js\n * (c) 2013 Zach Denton (MIT)\n */\n\nvar _noiseBuffers = {\n  get brown() {\n    if (!_noiseCache.brown) {\n      var buffer = [];\n\n      for (var channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n        var channel = new Float32Array(BUFFER_LENGTH);\n        buffer[channelNum] = channel;\n        var lastOut = 0.0;\n\n        for (var i = 0; i < BUFFER_LENGTH; i++) {\n          var white = Math.random() * 2 - 1;\n          channel[i] = (lastOut + 0.02 * white) / 1.02;\n          lastOut = channel[i];\n          channel[i] *= 3.5; // (roughly) compensate for gain\n        }\n      }\n\n      _noiseCache.brown = new ToneAudioBuffer().fromArray(buffer);\n    }\n\n    return _noiseCache.brown;\n  },\n\n  get pink() {\n    if (!_noiseCache.pink) {\n      var buffer = [];\n\n      for (var channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n        var channel = new Float32Array(BUFFER_LENGTH);\n        buffer[channelNum] = channel;\n        var b0 = void 0,\n            b1 = void 0,\n            b2 = void 0,\n            b3 = void 0,\n            b4 = void 0,\n            b5 = void 0,\n            b6 = void 0;\n        b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;\n\n        for (var i = 0; i < BUFFER_LENGTH; i++) {\n          var white = Math.random() * 2 - 1;\n          b0 = 0.99886 * b0 + white * 0.0555179;\n          b1 = 0.99332 * b1 + white * 0.0750759;\n          b2 = 0.96900 * b2 + white * 0.1538520;\n          b3 = 0.86650 * b3 + white * 0.3104856;\n          b4 = 0.55000 * b4 + white * 0.5329522;\n          b5 = -0.7616 * b5 - white * 0.0168980;\n          channel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n          channel[i] *= 0.11; // (roughly) compensate for gain\n\n          b6 = white * 0.115926;\n        }\n      }\n\n      _noiseCache.pink = new ToneAudioBuffer().fromArray(buffer);\n    }\n\n    return _noiseCache.pink;\n  },\n\n  get white() {\n    if (!_noiseCache.white) {\n      var buffer = [];\n\n      for (var channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n        var channel = new Float32Array(BUFFER_LENGTH);\n        buffer[channelNum] = channel;\n\n        for (var i = 0; i < BUFFER_LENGTH; i++) {\n          channel[i] = Math.random() * 2 - 1;\n        }\n      }\n\n      _noiseCache.white = new ToneAudioBuffer().fromArray(buffer);\n    }\n\n    return _noiseCache.white;\n  }\n\n};","map":{"version":3,"sources":["../../../Tone/source/Noise.ts"],"names":[],"mappings":";AAAA,SAAS,eAAT,QAAgC,iCAAhC;AAEA,SAAS,oBAAT,QAAqC,uBAArC;AACA,SAAS,MAAT,QAAuB,oBAAvB;AACA,SAAS,MAAT,QAAsC,kBAAtC;AACA,SAAS,gBAAT,QAAiC,2BAAjC;AAWA;;;;;;;;;;;;;;;;;;;;;;AAqBA,IAAA,KAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAA2B,EAAA,OAAA,CAAA,SAAA,CAAA,KAAA,EAAA,MAAA;;AAmC1B,WAAA,KAAA,GAAA;AAAA,QAAA,KAAA,GACC,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,oBAAoB,CAAC,KAAK,CAAC,WAAN,EAAD,EAAsB,SAAtB,EAAiC,CAAC,MAAD,CAAjC,CAA1B,KAAqE,IADtE;;AAjCS,IAAA,KAAA,CAAA,IAAA,GAAe,OAAf;AAET;;;;AAGQ,IAAA,KAAA,CAAA,OAAA,GAAmC,IAAnC;AA8BP,QAAM,OAAO,GAAG,oBAAoB,CAAC,KAAK,CAAC,WAAN,EAAD,EAAsB,SAAtB,EAAiC,CAAC,MAAD,CAAjC,CAApC;AAEA,IAAA,KAAI,CAAC,aAAL,GAAqB,OAAO,CAAC,YAA7B;AACA,IAAA,KAAI,CAAC,IAAL,GAAY,OAAO,CAAC,IAApB;AACA,IAAA,KAAI,CAAC,OAAL,GAAe,OAAO,CAAC,MAAvB;AACA,IAAA,KAAI,CAAC,QAAL,GAAgB,OAAO,CAAC,OAAxB;;AACA;;AAEM,EAAA,KAAA,CAAA,WAAA,GAAP,YAAA;AACC,WAAO,MAAM,CAAC,MAAP,CAAc,MAAM,CAAC,WAAP,EAAd,EAAoC;AAC1C,MAAA,MAAM,EAAE,CADkC;AAE1C,MAAA,OAAO,EAAE,CAFiC;AAG1C,MAAA,YAAY,EAAE,CAH4B;AAI1C,MAAA,IAAI,EAAE;AAJoC,KAApC,CAAP;AAMA,GAPM;;AAgBP,EAAA,MAAA,CAAA,cAAA,CAAI,KAAA,CAAA,SAAJ,EAAI,MAAJ,EAAQ;AAPR;;;;;;;SAOA,YAAA;AACC,aAAO,KAAK,KAAZ;AACA,KAFO;SAGR,UAAS,IAAT,EAAwB;AACvB,MAAA,MAAM,CAAC,IAAI,IAAI,aAAT,EAAwB,0BAA0B,IAAlD,CAAN;;AACA,UAAI,KAAK,KAAL,KAAe,IAAnB,EAAyB;AACxB,aAAK,KAAL,GAAa,IAAb,CADwB,CAExB;;AACA,YAAI,KAAK,KAAL,KAAe,SAAnB,EAA8B;AAC7B,cAAM,GAAG,GAAG,KAAK,GAAL,EAAZ;;AACA,eAAK,KAAL,CAAW,GAAX;;AACA,eAAK,MAAL,CAAY,GAAZ;AACA;AACD;AACD,KAdO;oBAAA;;AAAA,GAAR;AAoBA,EAAA,MAAA,CAAA,cAAA,CAAI,KAAA,CAAA,SAAJ,EAAI,cAAJ,EAAgB;AAJhB;;;;SAIA,YAAA;AACC,aAAO,KAAK,aAAZ;AACA,KAFe;SAGhB,UAAiB,IAAjB,EAA+B;AAC9B,WAAK,aAAL,GAAqB,IAArB;;AACA,UAAI,KAAK,OAAT,EAAkB;AACjB,aAAK,OAAL,CAAa,YAAb,CAA0B,KAA1B,GAAkC,IAAlC;AACA;AACD,KARe;oBAAA;;AAAA,GAAhB;AAUA;;;;AAGU,EAAA,KAAA,CAAA,SAAA,CAAA,MAAA,GAAV,UAAiB,IAAjB,EAA4B;AAA5B,QAAA,KAAA,GAAA,IAAA;;AACC,QAAM,MAAM,GAAG,aAAa,CAAC,KAAK,KAAN,CAA5B;AACA,SAAK,OAAL,GAAe,IAAI,gBAAJ,CAAqB;AACnC,MAAA,MAAM,EAAA,MAD6B;AAEnC,MAAA,OAAO,EAAE,KAAK,OAFqB;AAGnC,MAAA,MAAM,EAAE,KAAK,OAHsB;AAInC,MAAA,OAAO,EAAE,KAAK,QAJqB;AAKnC,MAAA,IAAI,EAAE,IAL6B;AAMnC,MAAA,OAAO,EAAE,YAAA;AAAM,eAAA,KAAI,CAAC,MAAL,CAAA,KAAA,CAAA;AAAiB,OANG;AAOnC,MAAA,YAAY,EAAE,KAAK;AAPgB,KAArB,EAQZ,OARY,CAQJ,KAAK,MARD,CAAf;;AASA,SAAK,OAAL,CAAa,KAAb,CAAmB,KAAK,SAAL,CAAe,IAAf,CAAnB,EAAyC,IAAI,CAAC,MAAL,MAAiB,MAAM,CAAC,QAAP,GAAkB,KAAnC,CAAzC;AACA,GAZS;AAcV;;;;;AAGU,EAAA,KAAA,CAAA,SAAA,CAAA,KAAA,GAAV,UAAgB,IAAhB,EAA2B;AAC1B,QAAI,KAAK,OAAT,EAAkB;AACjB,WAAK,OAAL,CAAa,IAAb,CAAkB,KAAK,SAAL,CAAe,IAAf,CAAlB;;AACA,WAAK,OAAL,GAAe,IAAf;AACA;AACD,GALS;;AAUV,EAAA,MAAA,CAAA,cAAA,CAAI,KAAA,CAAA,SAAJ,EAAI,QAAJ,EAAU;AAHV;;;SAGA,YAAA;AACC,aAAO,KAAK,OAAZ;AACA,KAFS;SAGV,UAAW,IAAX,EAAe;AACd,WAAK,OAAL,GAAe,IAAf;;AACA,UAAI,KAAK,OAAT,EAAkB;AACjB,aAAK,OAAL,CAAa,MAAb,GAAsB,KAAK,OAA3B;AACA;AACD,KARS;oBAAA;;AAAA,GAAV;AAaA,EAAA,MAAA,CAAA,cAAA,CAAI,KAAA,CAAA,SAAJ,EAAI,SAAJ,EAAW;AAHX;;;SAGA,YAAA;AACC,aAAO,KAAK,QAAZ;AACA,KAFU;SAGX,UAAY,IAAZ,EAAgB;AACf,WAAK,QAAL,GAAgB,IAAhB;;AACA,UAAI,KAAK,OAAT,EAAkB;AACjB,aAAK,OAAL,CAAa,OAAb,GAAuB,KAAK,QAA5B;AACA;AACD,KARU;oBAAA;;AAAA,GAAX;;AAUU,EAAA,KAAA,CAAA,SAAA,CAAA,QAAA,GAAV,UAAmB,IAAnB,EAA8B;AAC7B;AACA,SAAK,KAAL,CAAW,IAAX;;AACA,SAAK,MAAL,CAAY,IAAZ;AACA,GAJS;AAMV;;;;;AAGA,EAAA,KAAA,CAAA,SAAA,CAAA,OAAA,GAAA,YAAA;AACC,IAAA,MAAA,CAAA,SAAA,CAAM,OAAN,CAAa,IAAb,CAAa,IAAb;;AACA,QAAI,KAAK,OAAT,EAAkB;AACjB,WAAK,OAAL,CAAa,UAAb;AACA;;AACD,WAAO,IAAP;AACA,GAND;;AAOD,SAAA,KAAA;AAAC,CAhKD,CAA2B,MAA3B,CAAA;;kBAkKA;AACA;AACA;AAEA;;AACA,IAAM,aAAa,GAAG,QAAQ,CAA9B;AACA,IAAM,YAAY,GAAG,CAArB;AASA;;;;AAGA,IAAM,WAAW,GAAe;AAC/B,EAAA,KAAK,EAAE,IADwB;AAE/B,EAAA,IAAI,EAAE,IAFyB;AAG/B,EAAA,KAAK,EAAE;AAHwB,CAAhC;AAMA;;;;;;AAKA,IAAM,aAAa,GAAG;AACrB,MAAI,KAAJ,GAAS;AACR,QAAI,CAAC,WAAW,CAAC,KAAjB,EAAwB;AACvB,UAAM,MAAM,GAAmB,EAA/B;;AACA,WAAK,IAAI,UAAU,GAAG,CAAtB,EAAyB,UAAU,GAAG,YAAtC,EAAoD,UAAU,EAA9D,EAAkE;AACjE,YAAM,OAAO,GAAG,IAAI,YAAJ,CAAiB,aAAjB,CAAhB;AACA,QAAA,MAAM,CAAC,UAAD,CAAN,GAAqB,OAArB;AACA,YAAI,OAAO,GAAG,GAAd;;AACA,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,aAApB,EAAmC,CAAC,EAApC,EAAwC;AACvC,cAAM,KAAK,GAAG,IAAI,CAAC,MAAL,KAAgB,CAAhB,GAAoB,CAAlC;AACA,UAAA,OAAO,CAAC,CAAD,CAAP,GAAa,CAAC,OAAO,GAAI,OAAO,KAAnB,IAA6B,IAA1C;AACA,UAAA,OAAO,GAAG,OAAO,CAAC,CAAD,CAAjB;AACA,UAAA,OAAO,CAAC,CAAD,CAAP,IAAc,GAAd,CAJuC,CAIpB;AACnB;AACD;;AACD,MAAA,WAAW,CAAC,KAAZ,GAAoB,IAAI,eAAJ,GAAsB,SAAtB,CAAgC,MAAhC,CAApB;AACA;;AACD,WAAO,WAAW,CAAC,KAAnB;AACA,GAlBoB;;AAoBrB,MAAI,IAAJ,GAAQ;AACP,QAAI,CAAC,WAAW,CAAC,IAAjB,EAAuB;AACtB,UAAM,MAAM,GAAmB,EAA/B;;AACA,WAAK,IAAI,UAAU,GAAG,CAAtB,EAAyB,UAAU,GAAG,YAAtC,EAAoD,UAAU,EAA9D,EAAkE;AACjE,YAAM,OAAO,GAAG,IAAI,YAAJ,CAAiB,aAAjB,CAAhB;AACA,QAAA,MAAM,CAAC,UAAD,CAAN,GAAqB,OAArB;AACA,YAAI,EAAE,GAAA,KAAA,CAAN;AAAA,YAAQ,EAAE,GAAA,KAAA,CAAV;AAAA,YAAY,EAAE,GAAA,KAAA,CAAd;AAAA,YAAgB,EAAE,GAAA,KAAA,CAAlB;AAAA,YAAoB,EAAE,GAAA,KAAA,CAAtB;AAAA,YAAwB,EAAE,GAAA,KAAA,CAA1B;AAAA,YAA4B,EAAE,GAAA,KAAA,CAA9B;AACA,QAAA,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,GAAnC;;AACA,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,aAApB,EAAmC,CAAC,EAApC,EAAwC;AACvC,cAAM,KAAK,GAAG,IAAI,CAAC,MAAL,KAAgB,CAAhB,GAAoB,CAAlC;AACA,UAAA,EAAE,GAAG,UAAU,EAAV,GAAe,KAAK,GAAG,SAA5B;AACA,UAAA,EAAE,GAAG,UAAU,EAAV,GAAe,KAAK,GAAG,SAA5B;AACA,UAAA,EAAE,GAAG,UAAU,EAAV,GAAe,KAAK,GAAG,SAA5B;AACA,UAAA,EAAE,GAAG,UAAU,EAAV,GAAe,KAAK,GAAG,SAA5B;AACA,UAAA,EAAE,GAAG,UAAU,EAAV,GAAe,KAAK,GAAG,SAA5B;AACA,UAAA,EAAE,GAAG,CAAC,MAAD,GAAU,EAAV,GAAe,KAAK,GAAG,SAA5B;AACA,UAAA,OAAO,CAAC,CAAD,CAAP,GAAa,EAAE,GAAG,EAAL,GAAU,EAAV,GAAe,EAAf,GAAoB,EAApB,GAAyB,EAAzB,GAA8B,EAA9B,GAAmC,KAAK,GAAG,MAAxD;AACA,UAAA,OAAO,CAAC,CAAD,CAAP,IAAc,IAAd,CATuC,CASnB;;AACpB,UAAA,EAAE,GAAG,KAAK,GAAG,QAAb;AACA;AACD;;AACD,MAAA,WAAW,CAAC,IAAZ,GAAmB,IAAI,eAAJ,GAAsB,SAAtB,CAAgC,MAAhC,CAAnB;AACA;;AACD,WAAO,WAAW,CAAC,IAAnB;AACA,GA5CoB;;AA8CrB,MAAI,KAAJ,GAAS;AACR,QAAI,CAAC,WAAW,CAAC,KAAjB,EAAwB;AACvB,UAAM,MAAM,GAAmB,EAA/B;;AACA,WAAK,IAAI,UAAU,GAAG,CAAtB,EAAyB,UAAU,GAAG,YAAtC,EAAoD,UAAU,EAA9D,EAAkE;AACjE,YAAM,OAAO,GAAG,IAAI,YAAJ,CAAiB,aAAjB,CAAhB;AACA,QAAA,MAAM,CAAC,UAAD,CAAN,GAAqB,OAArB;;AACA,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,aAApB,EAAmC,CAAC,EAApC,EAAwC;AACvC,UAAA,OAAO,CAAC,CAAD,CAAP,GAAa,IAAI,CAAC,MAAL,KAAgB,CAAhB,GAAoB,CAAjC;AACA;AACD;;AACD,MAAA,WAAW,CAAC,KAAZ,GAAoB,IAAI,eAAJ,GAAsB,SAAtB,CAAgC,MAAhC,CAApB;AACA;;AACD,WAAO,WAAW,CAAC,KAAnB;AACA;;AA3DoB,CAAtB","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { Source } from \"../source/Source\";\nimport { ToneBufferSource } from \"./buffer/ToneBufferSource\";\n/**\n * Noise is a noise generator. It uses looped noise buffers to save on performance.\n * Noise supports the noise types: \"pink\", \"white\", and \"brown\". Read more about\n * colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).\n *\n * @example\n * import { AutoFilter, Noise } from \"tone\";\n * // initialize the noise and start\n * const noise = new Noise(\"pink\").start();\n * // make an autofilter to shape the noise\n * const autoFilter = new AutoFilter({\n * \tfrequency: \"8n\",\n * \tbaseFrequency: 200,\n * \toctaves: 8\n * }).toDestination().start();\n * // connect the noise\n * noise.connect(autoFilter);\n * // start the autofilter LFO\n * autoFilter.start();\n * @category Source\n */\nvar Noise = /** @class */ (function (_super) {\n    tslib_1.__extends(Noise, _super);\n    function Noise() {\n        var _this = _super.call(this, optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"])) || this;\n        _this.name = \"Noise\";\n        /**\n         * Private reference to the source\n         */\n        _this._source = null;\n        var options = optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]);\n        _this._playbackRate = options.playbackRate;\n        _this.type = options.type;\n        _this._fadeIn = options.fadeIn;\n        _this._fadeOut = options.fadeOut;\n        return _this;\n    }\n    Noise.getDefaults = function () {\n        return Object.assign(Source.getDefaults(), {\n            fadeIn: 0,\n            fadeOut: 0,\n            playbackRate: 1,\n            type: \"white\",\n        });\n    };\n    Object.defineProperty(Noise.prototype, \"type\", {\n        /**\n         * The type of the noise. Can be \"white\", \"brown\", or \"pink\".\n         * @example\n         * import { Noise } from \"tone\";\n         * const noise = new Noise().toDestination().start();\n         * noise.type = \"brown\";\n         */\n        get: function () {\n            return this._type;\n        },\n        set: function (type) {\n            assert(type in _noiseBuffers, \"Noise: invalid type: \" + type);\n            if (this._type !== type) {\n                this._type = type;\n                // if it's playing, stop and restart it\n                if (this.state === \"started\") {\n                    var now = this.now();\n                    this._stop(now);\n                    this._start(now);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Noise.prototype, \"playbackRate\", {\n        /**\n         * The playback rate of the noise. Affects\n         * the \"frequency\" of the noise.\n         */\n        get: function () {\n            return this._playbackRate;\n        },\n        set: function (rate) {\n            this._playbackRate = rate;\n            if (this._source) {\n                this._source.playbackRate.value = rate;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * internal start method\n     */\n    Noise.prototype._start = function (time) {\n        var _this = this;\n        var buffer = _noiseBuffers[this._type];\n        this._source = new ToneBufferSource({\n            buffer: buffer,\n            context: this.context,\n            fadeIn: this._fadeIn,\n            fadeOut: this._fadeOut,\n            loop: true,\n            onended: function () { return _this.onstop(_this); },\n            playbackRate: this._playbackRate,\n        }).connect(this.output);\n        this._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));\n    };\n    /**\n     * internal stop method\n     */\n    Noise.prototype._stop = function (time) {\n        if (this._source) {\n            this._source.stop(this.toSeconds(time));\n            this._source = null;\n        }\n    };\n    Object.defineProperty(Noise.prototype, \"fadeIn\", {\n        /**\n         * The fadeIn time of the amplitude envelope.\n         */\n        get: function () {\n            return this._fadeIn;\n        },\n        set: function (time) {\n            this._fadeIn = time;\n            if (this._source) {\n                this._source.fadeIn = this._fadeIn;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Noise.prototype, \"fadeOut\", {\n        /**\n         * The fadeOut time of the amplitude envelope.\n         */\n        get: function () {\n            return this._fadeOut;\n        },\n        set: function (time) {\n            this._fadeOut = time;\n            if (this._source) {\n                this._source.fadeOut = this._fadeOut;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Noise.prototype._restart = function (time) {\n        // TODO could be optimized by cancelling the buffer source 'stop'\n        this._stop(time);\n        this._start(time);\n    };\n    /**\n     * Clean up.\n     */\n    Noise.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        if (this._source) {\n            this._source.disconnect();\n        }\n        return this;\n    };\n    return Noise;\n}(Source));\nexport { Noise };\n//--------------------\n// THE NOISE BUFFERS\n//--------------------\n// Noise buffer stats\nvar BUFFER_LENGTH = 44100 * 5;\nvar NUM_CHANNELS = 2;\n/**\n * Cache the noise buffers\n */\nvar _noiseCache = {\n    brown: null,\n    pink: null,\n    white: null,\n};\n/**\n * The noise arrays. Generated on initialization.\n * borrowed heavily from https://github.com/zacharydenton/noise.js\n * (c) 2013 Zach Denton (MIT)\n */\nvar _noiseBuffers = {\n    get brown() {\n        if (!_noiseCache.brown) {\n            var buffer = [];\n            for (var channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n                var channel = new Float32Array(BUFFER_LENGTH);\n                buffer[channelNum] = channel;\n                var lastOut = 0.0;\n                for (var i = 0; i < BUFFER_LENGTH; i++) {\n                    var white = Math.random() * 2 - 1;\n                    channel[i] = (lastOut + (0.02 * white)) / 1.02;\n                    lastOut = channel[i];\n                    channel[i] *= 3.5; // (roughly) compensate for gain\n                }\n            }\n            _noiseCache.brown = new ToneAudioBuffer().fromArray(buffer);\n        }\n        return _noiseCache.brown;\n    },\n    get pink() {\n        if (!_noiseCache.pink) {\n            var buffer = [];\n            for (var channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n                var channel = new Float32Array(BUFFER_LENGTH);\n                buffer[channelNum] = channel;\n                var b0 = void 0, b1 = void 0, b2 = void 0, b3 = void 0, b4 = void 0, b5 = void 0, b6 = void 0;\n                b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;\n                for (var i = 0; i < BUFFER_LENGTH; i++) {\n                    var white = Math.random() * 2 - 1;\n                    b0 = 0.99886 * b0 + white * 0.0555179;\n                    b1 = 0.99332 * b1 + white * 0.0750759;\n                    b2 = 0.96900 * b2 + white * 0.1538520;\n                    b3 = 0.86650 * b3 + white * 0.3104856;\n                    b4 = 0.55000 * b4 + white * 0.5329522;\n                    b5 = -0.7616 * b5 - white * 0.0168980;\n                    channel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n                    channel[i] *= 0.11; // (roughly) compensate for gain\n                    b6 = white * 0.115926;\n                }\n            }\n            _noiseCache.pink = new ToneAudioBuffer().fromArray(buffer);\n        }\n        return _noiseCache.pink;\n    },\n    get white() {\n        if (!_noiseCache.white) {\n            var buffer = [];\n            for (var channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n                var channel = new Float32Array(BUFFER_LENGTH);\n                buffer[channelNum] = channel;\n                for (var i = 0; i < BUFFER_LENGTH; i++) {\n                    channel[i] = Math.random() * 2 - 1;\n                }\n            }\n            _noiseCache.white = new ToneAudioBuffer().fromArray(buffer);\n        }\n        return _noiseCache.white;\n    },\n};\n//# sourceMappingURL=Noise.js.map"]},"metadata":{},"sourceType":"module"}