{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { connect } from \"../../core/context/ToneAudioNode\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { assert } from \"../../core/util/Debug\";\nimport { OneShotSource } from \"../OneShotSource\";\nimport { EQ, GTE, LT } from \"../../core/util/Math\";\n/**\n * Wrapper around the native BufferSourceNode.\n * @category Source\n */\n\nvar ToneBufferSource =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ToneBufferSource, _super);\n\n  function ToneBufferSource() {\n    var _this = _super.call(this, optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"buffer\", \"onload\"])) || this;\n\n    _this.name = \"ToneBufferSource\";\n    /**\n     * The oscillator\n     */\n\n    _this._source = _this.context.createBufferSource();\n    _this._internalChannels = [_this._source];\n    /**\n     * indicators if the source has started/stopped\n     */\n\n    _this._sourceStarted = false;\n    _this._sourceStopped = false;\n    var options = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"buffer\", \"onload\"]);\n    connect(_this._source, _this._gainNode);\n\n    _this._source.onended = function () {\n      return _this._stopSource();\n    };\n    /**\n     * The playbackRate of the buffer\n     */\n\n\n    _this.playbackRate = new Param({\n      context: _this.context,\n      param: _this._source.playbackRate,\n      units: \"positive\",\n      value: options.playbackRate\n    }); // set some values initially\n\n    _this.loop = options.loop;\n    _this.loopStart = options.loopStart;\n    _this.loopEnd = options.loopEnd;\n    _this._buffer = new ToneAudioBuffer(options.buffer, options.onload);\n\n    _this._internalChannels.push(_this._source);\n\n    return _this;\n  }\n\n  ToneBufferSource.getDefaults = function () {\n    return Object.assign(OneShotSource.getDefaults(), {\n      buffer: new ToneAudioBuffer(),\n      loop: false,\n      loopEnd: 0,\n      loopStart: 0,\n      onload: noOp,\n      playbackRate: 1\n    });\n  };\n\n  Object.defineProperty(ToneBufferSource.prototype, \"fadeIn\", {\n    /**\n     * The fadeIn time of the amplitude envelope.\n     */\n    get: function () {\n      return this._fadeIn;\n    },\n    set: function (t) {\n      this._fadeIn = t;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ToneBufferSource.prototype, \"fadeOut\", {\n    /**\n     * The fadeOut time of the amplitude envelope.\n     */\n    get: function () {\n      return this._fadeOut;\n    },\n    set: function (t) {\n      this._fadeOut = t;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ToneBufferSource.prototype, \"curve\", {\n    /**\n     * The curve applied to the fades, either \"linear\" or \"exponential\"\n     */\n    get: function () {\n      return this._curve;\n    },\n    set: function (t) {\n      this._curve = t;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Start the buffer\n   * @param  time When the player should start.\n   * @param  offset The offset from the beginning of the sample to start at.\n   * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n   * @param  gain  The gain to play the buffer back at.\n   */\n\n  ToneBufferSource.prototype.start = function (time, offset, duration, gain) {\n    if (gain === void 0) {\n      gain = 1;\n    }\n\n    assert(this.buffer.loaded, \"buffer is either not set or not loaded\");\n    var computedTime = this.toSeconds(time); // apply the gain envelope\n\n    this._startGain(computedTime, gain); // if it's a loop the default offset is the loopstart point\n\n\n    if (this.loop) {\n      offset = defaultArg(offset, this.loopStart);\n    } else {\n      // otherwise the default offset is 0\n      offset = defaultArg(offset, 0);\n    } // make sure the offset is not less than 0\n\n\n    var computedOffset = Math.max(this.toSeconds(offset), 0); // start the buffer source\n\n    if (this.loop) {\n      // modify the offset if it's greater than the loop time\n      var loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n      var loopStart = this.toSeconds(this.loopStart);\n      var loopDuration = loopEnd - loopStart; // move the offset back\n\n      if (GTE(computedOffset, loopEnd)) {\n        computedOffset = (computedOffset - loopStart) % loopDuration + loopStart;\n      } // when the offset is very close to the duration, set it to 0\n\n\n      if (EQ(computedOffset, this.buffer.duration)) {\n        computedOffset = 0;\n      }\n    } // this.buffer.loaded would have return false if the AudioBuffer was undefined\n\n\n    this._source.buffer = this.buffer.get();\n    this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\n    if (LT(computedOffset, this.buffer.duration)) {\n      this._sourceStarted = true;\n\n      this._source.start(computedTime, computedOffset);\n    } // if a duration is given, schedule a stop\n\n\n    if (isDefined(duration)) {\n      var computedDur = this.toSeconds(duration); // make sure it's never negative\n\n      computedDur = Math.max(computedDur, 0);\n      this.stop(computedTime + computedDur);\n    }\n\n    return this;\n  };\n\n  ToneBufferSource.prototype._stopSource = function (time) {\n    if (!this._sourceStopped && this._sourceStarted) {\n      this._sourceStopped = true;\n\n      this._source.stop(this.toSeconds(time));\n\n      this._onended();\n    }\n  };\n\n  Object.defineProperty(ToneBufferSource.prototype, \"loopStart\", {\n    /**\n     * If loop is true, the loop will start at this position.\n     */\n    get: function () {\n      return this._source.loopStart;\n    },\n    set: function (loopStart) {\n      this._source.loopStart = this.toSeconds(loopStart);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ToneBufferSource.prototype, \"loopEnd\", {\n    /**\n     * If loop is true, the loop will end at this position.\n     */\n    get: function () {\n      return this._source.loopEnd;\n    },\n    set: function (loopEnd) {\n      this._source.loopEnd = this.toSeconds(loopEnd);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ToneBufferSource.prototype, \"buffer\", {\n    /**\n     * The audio buffer belonging to the player.\n     */\n    get: function () {\n      return this._buffer;\n    },\n    set: function (buffer) {\n      this._buffer.set(buffer);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ToneBufferSource.prototype, \"loop\", {\n    /**\n     * If the buffer should loop once it's over.\n     */\n    get: function () {\n      return this._source.loop;\n    },\n    set: function (loop) {\n      this._source.loop = loop;\n\n      if (this._sourceStarted) {\n        this.cancelStop();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Clean up.\n   */\n\n  ToneBufferSource.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._source.onended = null;\n\n    this._source.disconnect();\n\n    this._buffer.dispose();\n\n    this.playbackRate.dispose();\n    return this;\n  };\n\n  return ToneBufferSource;\n}(OneShotSource);\n\nexport { ToneBufferSource };","map":{"version":3,"sources":["../../../../Tone/source/buffer/ToneBufferSource.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { connect } from \"../../core/context/ToneAudioNode\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { assert } from \"../../core/util/Debug\";\nimport { OneShotSource } from \"../OneShotSource\";\nimport { EQ, GTE, LT } from \"../../core/util/Math\";\n/**\n * Wrapper around the native BufferSourceNode.\n * @category Source\n */\nvar ToneBufferSource = /** @class */ (function (_super) {\n    tslib_1.__extends(ToneBufferSource, _super);\n    function ToneBufferSource() {\n        var _this = _super.call(this, optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"buffer\", \"onload\"])) || this;\n        _this.name = \"ToneBufferSource\";\n        /**\n         * The oscillator\n         */\n        _this._source = _this.context.createBufferSource();\n        _this._internalChannels = [_this._source];\n        /**\n         * indicators if the source has started/stopped\n         */\n        _this._sourceStarted = false;\n        _this._sourceStopped = false;\n        var options = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"buffer\", \"onload\"]);\n        connect(_this._source, _this._gainNode);\n        _this._source.onended = function () { return _this._stopSource(); };\n        /**\n         * The playbackRate of the buffer\n         */\n        _this.playbackRate = new Param({\n            context: _this.context,\n            param: _this._source.playbackRate,\n            units: \"positive\",\n            value: options.playbackRate,\n        });\n        // set some values initially\n        _this.loop = options.loop;\n        _this.loopStart = options.loopStart;\n        _this.loopEnd = options.loopEnd;\n        _this._buffer = new ToneAudioBuffer(options.buffer, options.onload);\n        _this._internalChannels.push(_this._source);\n        return _this;\n    }\n    ToneBufferSource.getDefaults = function () {\n        return Object.assign(OneShotSource.getDefaults(), {\n            buffer: new ToneAudioBuffer(),\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            onload: noOp,\n            playbackRate: 1,\n        });\n    };\n    Object.defineProperty(ToneBufferSource.prototype, \"fadeIn\", {\n        /**\n         * The fadeIn time of the amplitude envelope.\n         */\n        get: function () {\n            return this._fadeIn;\n        },\n        set: function (t) {\n            this._fadeIn = t;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ToneBufferSource.prototype, \"fadeOut\", {\n        /**\n         * The fadeOut time of the amplitude envelope.\n         */\n        get: function () {\n            return this._fadeOut;\n        },\n        set: function (t) {\n            this._fadeOut = t;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ToneBufferSource.prototype, \"curve\", {\n        /**\n         * The curve applied to the fades, either \"linear\" or \"exponential\"\n         */\n        get: function () {\n            return this._curve;\n        },\n        set: function (t) {\n            this._curve = t;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Start the buffer\n     * @param  time When the player should start.\n     * @param  offset The offset from the beginning of the sample to start at.\n     * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n     * @param  gain  The gain to play the buffer back at.\n     */\n    ToneBufferSource.prototype.start = function (time, offset, duration, gain) {\n        if (gain === void 0) { gain = 1; }\n        assert(this.buffer.loaded, \"buffer is either not set or not loaded\");\n        var computedTime = this.toSeconds(time);\n        // apply the gain envelope\n        this._startGain(computedTime, gain);\n        // if it's a loop the default offset is the loopstart point\n        if (this.loop) {\n            offset = defaultArg(offset, this.loopStart);\n        }\n        else {\n            // otherwise the default offset is 0\n            offset = defaultArg(offset, 0);\n        }\n        // make sure the offset is not less than 0\n        var computedOffset = Math.max(this.toSeconds(offset), 0);\n        // start the buffer source\n        if (this.loop) {\n            // modify the offset if it's greater than the loop time\n            var loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n            var loopStart = this.toSeconds(this.loopStart);\n            var loopDuration = loopEnd - loopStart;\n            // move the offset back\n            if (GTE(computedOffset, loopEnd)) {\n                computedOffset = ((computedOffset - loopStart) % loopDuration) + loopStart;\n            }\n            // when the offset is very close to the duration, set it to 0\n            if (EQ(computedOffset, this.buffer.duration)) {\n                computedOffset = 0;\n            }\n        }\n        // this.buffer.loaded would have return false if the AudioBuffer was undefined\n        this._source.buffer = this.buffer.get();\n        this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n        if (LT(computedOffset, this.buffer.duration)) {\n            this._sourceStarted = true;\n            this._source.start(computedTime, computedOffset);\n        }\n        // if a duration is given, schedule a stop\n        if (isDefined(duration)) {\n            var computedDur = this.toSeconds(duration);\n            // make sure it's never negative\n            computedDur = Math.max(computedDur, 0);\n            this.stop(computedTime + computedDur);\n        }\n        return this;\n    };\n    ToneBufferSource.prototype._stopSource = function (time) {\n        if (!this._sourceStopped && this._sourceStarted) {\n            this._sourceStopped = true;\n            this._source.stop(this.toSeconds(time));\n            this._onended();\n        }\n    };\n    Object.defineProperty(ToneBufferSource.prototype, \"loopStart\", {\n        /**\n         * If loop is true, the loop will start at this position.\n         */\n        get: function () {\n            return this._source.loopStart;\n        },\n        set: function (loopStart) {\n            this._source.loopStart = this.toSeconds(loopStart);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ToneBufferSource.prototype, \"loopEnd\", {\n        /**\n         * If loop is true, the loop will end at this position.\n         */\n        get: function () {\n            return this._source.loopEnd;\n        },\n        set: function (loopEnd) {\n            this._source.loopEnd = this.toSeconds(loopEnd);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ToneBufferSource.prototype, \"buffer\", {\n        /**\n         * The audio buffer belonging to the player.\n         */\n        get: function () {\n            return this._buffer;\n        },\n        set: function (buffer) {\n            this._buffer.set(buffer);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ToneBufferSource.prototype, \"loop\", {\n        /**\n         * If the buffer should loop once it's over.\n         */\n        get: function () {\n            return this._source.loop;\n        },\n        set: function (loop) {\n            this._source.loop = loop;\n            if (this._sourceStarted) {\n                this.cancelStop();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Clean up.\n     */\n    ToneBufferSource.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this._source.onended = null;\n        this._source.disconnect();\n        this._buffer.dispose();\n        this.playbackRate.dispose();\n        return this;\n    };\n    return ToneBufferSource;\n}(OneShotSource));\nexport { ToneBufferSource };\n//# sourceMappingURL=ToneBufferSource.js.map"]},"metadata":{},"sourceType":"module"}