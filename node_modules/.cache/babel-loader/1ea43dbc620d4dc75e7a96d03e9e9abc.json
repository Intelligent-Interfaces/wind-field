{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { connectSeries, ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { ToneAudioWorklet } from \"../../core/context/ToneAudioWorklet\";\n/**\n * Comb filters are basic building blocks for physical modeling. Read more\n * about comb filters on [CCRMA's website](https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html).\n *\n * This comb filter is implemented with the AudioWorkletNode which allows it to have feedback delays less than the\n * Web Audio processing block of 128 samples. There is a polyfill for browsers that don't yet support the\n * AudioWorkletNode, but it will add some latency and have slower performance than the AudioWorkletNode.\n * @category Component\n */\n\nvar FeedbackCombFilter =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(FeedbackCombFilter, _super);\n\n  function FeedbackCombFilter() {\n    var _this = _super.call(this, optionsFromArguments(FeedbackCombFilter.getDefaults(), arguments, [\"delayTime\", \"resonance\"])) || this;\n\n    _this.name = \"FeedbackCombFilter\";\n    /**\n     * Default constructor options for the filter\n     */\n\n    _this.workletOptions = {\n      numberOfInputs: 1,\n      numberOfOutputs: 1,\n      channelCount: 1\n    };\n    var options = optionsFromArguments(FeedbackCombFilter.getDefaults(), arguments, [\"delayTime\", \"resonance\"]);\n    _this.input = new Gain({\n      context: _this.context\n    });\n    _this.output = new Gain({\n      context: _this.context\n    });\n\n    var dummyGain = _this.context.createGain();\n\n    _this.delayTime = new Param({\n      context: _this.context,\n      value: options.delayTime,\n      units: \"time\",\n      minValue: 0,\n      maxValue: 1,\n      param: dummyGain.gain,\n      swappable: true\n    });\n    _this.resonance = new Param({\n      context: _this.context,\n      value: options.resonance,\n      units: \"normalRange\",\n      param: dummyGain.gain,\n      swappable: true\n    });\n    readOnly(_this, [\"resonance\", \"delayTime\"]);\n    return _this;\n  }\n\n  FeedbackCombFilter.prototype._audioWorkletName = function () {\n    return \"feedback-comb-filter\";\n  };\n\n  FeedbackCombFilter.prototype._audioWorklet = function () {\n    return (\n      /* javascript */\n      \" \\n\\t\\t\\tregisterProcessor(\\\"\" + this._audioWorkletName() + \"\\\", class extends AudioWorkletProcessor {\\n\\t\\t\\t\\tstatic get parameterDescriptors() {\\n\\t\\t\\t\\t\\treturn [{\\n\\t\\t\\t\\t\\t\\tname: \\\"delayTime\\\",\\n\\t\\t\\t\\t\\t\\tdefaultValue: 0.1,\\n\\t\\t\\t\\t\\t\\tminValue: 0,\\n\\t\\t\\t\\t\\t\\tmaxValue: 1,\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tname: \\\"feedback\\\",\\n\\t\\t\\t\\t\\t\\tdefaultValue: 0.5,\\n\\t\\t\\t\\t\\t\\tminValue: 0,\\n\\t\\t\\t\\t\\t\\tmaxValue: 0.9999,\\n\\t\\t\\t\\t\\t}];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t\\tconstructor(options) {\\n\\t\\t\\t\\t\\tsuper(options);\\n\\t\\t\\t\\t\\tthis.delayBuffer = new Float32Array(sampleRate);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t\\tgetParameter(parameter, index) {\\n\\t\\t\\t\\t\\tif (parameter.length > 1) {\\n\\t\\t\\t\\t\\t\\treturn parameter[index];\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\treturn parameter[0];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t\\tprocess(inputs, outputs, parameters) {\\n\\t\\t\\t\\t\\tconst input = inputs[0];\\n\\t\\t\\t\\t\\tconst output = outputs[0];\\n\\t\\t\\t\\t\\tconst delayLength = this.delayBuffer.length;\\n\\t\\t\\t\\t\\tconst inputChannel = input[0];\\n\\t\\t\\t\\t\\tconst outputChannel = output[0];\\n\\t\\t\\t\\t\\tconst delayTimeParam = parameters.delayTime;\\n\\t\\t\\t\\t\\tconst feedbackParam = parameters.feedback;\\n\\t\\t\\t\\t\\tinputChannel.forEach((value, index) => {\\n\\t\\t\\t\\t\\t\\tconst delayTime = this.getParameter(delayTimeParam, index);\\n\\t\\t\\t\\t\\t\\tconst feedback = this.getParameter(feedbackParam, index);\\n\\t\\t\\t\\t\\t\\tconst delaySamples = Math.floor(delayTime * sampleRate);\\n\\t\\t\\t\\t\\t\\tconst currentIndex = (currentFrame + index) % delayLength;\\n\\t\\t\\t\\t\\t\\tconst delayedIndex = (currentFrame + index + delaySamples) % delayLength;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t// the current value to output\\n\\t\\t\\t\\t\\t\\tconst currentValue = this.delayBuffer[currentIndex];\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t// write the current value to the delayBuffer in the future\\n\\t\\t\\t\\t\\t\\tthis.delayBuffer[delayedIndex] = value + currentValue * feedback;\\n\\n\\t\\t\\t\\t\\t\\t// set all of the output channels to the same value\\n\\t\\t\\t\\t\\t\\toutputChannel[index] = delaySamples > 0 ? currentValue : value;\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t// keep the processing alive\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t\"\n    );\n  };\n  /**\n   * The default parameters\n   */\n\n\n  FeedbackCombFilter.getDefaults = function () {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      delayTime: 0.1,\n      resonance: 0.5\n    });\n  };\n\n  FeedbackCombFilter.prototype.onReady = function (node) {\n    connectSeries(this.input, node, this.output); // @ts-ignore\n\n    var delayTime = node.parameters.get(\"delayTime\");\n    this.delayTime.setParam(delayTime); // @ts-ignore\n\n    var feedback = node.parameters.get(\"feedback\");\n    this.resonance.setParam(feedback);\n  };\n\n  FeedbackCombFilter.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.input.dispose();\n    this.output.dispose();\n    this.delayTime.dispose();\n    this.resonance.dispose();\n    return this;\n  };\n\n  return FeedbackCombFilter;\n}(ToneAudioWorklet);\n\nexport { FeedbackCombFilter };","map":{"version":3,"sources":["../../../../Tone/component/filter/FeedbackCombFilter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { connectSeries, ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { ToneAudioWorklet } from \"../../core/context/ToneAudioWorklet\";\n/**\n * Comb filters are basic building blocks for physical modeling. Read more\n * about comb filters on [CCRMA's website](https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html).\n *\n * This comb filter is implemented with the AudioWorkletNode which allows it to have feedback delays less than the\n * Web Audio processing block of 128 samples. There is a polyfill for browsers that don't yet support the\n * AudioWorkletNode, but it will add some latency and have slower performance than the AudioWorkletNode.\n * @category Component\n */\nvar FeedbackCombFilter = /** @class */ (function (_super) {\n    tslib_1.__extends(FeedbackCombFilter, _super);\n    function FeedbackCombFilter() {\n        var _this = _super.call(this, optionsFromArguments(FeedbackCombFilter.getDefaults(), arguments, [\"delayTime\", \"resonance\"])) || this;\n        _this.name = \"FeedbackCombFilter\";\n        /**\n         * Default constructor options for the filter\n         */\n        _this.workletOptions = {\n            numberOfInputs: 1,\n            numberOfOutputs: 1,\n            channelCount: 1,\n        };\n        var options = optionsFromArguments(FeedbackCombFilter.getDefaults(), arguments, [\"delayTime\", \"resonance\"]);\n        _this.input = new Gain({ context: _this.context });\n        _this.output = new Gain({ context: _this.context });\n        var dummyGain = _this.context.createGain();\n        _this.delayTime = new Param({\n            context: _this.context,\n            value: options.delayTime,\n            units: \"time\",\n            minValue: 0,\n            maxValue: 1,\n            param: dummyGain.gain,\n            swappable: true,\n        });\n        _this.resonance = new Param({\n            context: _this.context,\n            value: options.resonance,\n            units: \"normalRange\",\n            param: dummyGain.gain,\n            swappable: true,\n        });\n        readOnly(_this, [\"resonance\", \"delayTime\"]);\n        return _this;\n    }\n    FeedbackCombFilter.prototype._audioWorkletName = function () {\n        return \"feedback-comb-filter\";\n    };\n    FeedbackCombFilter.prototype._audioWorklet = function () {\n        return /* javascript */ \" \\n\\t\\t\\tregisterProcessor(\\\"\" + this._audioWorkletName() + \"\\\", class extends AudioWorkletProcessor {\\n\\t\\t\\t\\tstatic get parameterDescriptors() {\\n\\t\\t\\t\\t\\treturn [{\\n\\t\\t\\t\\t\\t\\tname: \\\"delayTime\\\",\\n\\t\\t\\t\\t\\t\\tdefaultValue: 0.1,\\n\\t\\t\\t\\t\\t\\tminValue: 0,\\n\\t\\t\\t\\t\\t\\tmaxValue: 1,\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tname: \\\"feedback\\\",\\n\\t\\t\\t\\t\\t\\tdefaultValue: 0.5,\\n\\t\\t\\t\\t\\t\\tminValue: 0,\\n\\t\\t\\t\\t\\t\\tmaxValue: 0.9999,\\n\\t\\t\\t\\t\\t}];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t\\tconstructor(options) {\\n\\t\\t\\t\\t\\tsuper(options);\\n\\t\\t\\t\\t\\tthis.delayBuffer = new Float32Array(sampleRate);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t\\tgetParameter(parameter, index) {\\n\\t\\t\\t\\t\\tif (parameter.length > 1) {\\n\\t\\t\\t\\t\\t\\treturn parameter[index];\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\treturn parameter[0];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t\\tprocess(inputs, outputs, parameters) {\\n\\t\\t\\t\\t\\tconst input = inputs[0];\\n\\t\\t\\t\\t\\tconst output = outputs[0];\\n\\t\\t\\t\\t\\tconst delayLength = this.delayBuffer.length;\\n\\t\\t\\t\\t\\tconst inputChannel = input[0];\\n\\t\\t\\t\\t\\tconst outputChannel = output[0];\\n\\t\\t\\t\\t\\tconst delayTimeParam = parameters.delayTime;\\n\\t\\t\\t\\t\\tconst feedbackParam = parameters.feedback;\\n\\t\\t\\t\\t\\tinputChannel.forEach((value, index) => {\\n\\t\\t\\t\\t\\t\\tconst delayTime = this.getParameter(delayTimeParam, index);\\n\\t\\t\\t\\t\\t\\tconst feedback = this.getParameter(feedbackParam, index);\\n\\t\\t\\t\\t\\t\\tconst delaySamples = Math.floor(delayTime * sampleRate);\\n\\t\\t\\t\\t\\t\\tconst currentIndex = (currentFrame + index) % delayLength;\\n\\t\\t\\t\\t\\t\\tconst delayedIndex = (currentFrame + index + delaySamples) % delayLength;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t// the current value to output\\n\\t\\t\\t\\t\\t\\tconst currentValue = this.delayBuffer[currentIndex];\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t// write the current value to the delayBuffer in the future\\n\\t\\t\\t\\t\\t\\tthis.delayBuffer[delayedIndex] = value + currentValue * feedback;\\n\\n\\t\\t\\t\\t\\t\\t// set all of the output channels to the same value\\n\\t\\t\\t\\t\\t\\toutputChannel[index] = delaySamples > 0 ? currentValue : value;\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t// keep the processing alive\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t\";\n    };\n    /**\n     * The default parameters\n     */\n    FeedbackCombFilter.getDefaults = function () {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            delayTime: 0.1,\n            resonance: 0.5,\n        });\n    };\n    FeedbackCombFilter.prototype.onReady = function (node) {\n        connectSeries(this.input, node, this.output);\n        // @ts-ignore\n        var delayTime = node.parameters.get(\"delayTime\");\n        this.delayTime.setParam(delayTime);\n        // @ts-ignore\n        var feedback = node.parameters.get(\"feedback\");\n        this.resonance.setParam(feedback);\n    };\n    FeedbackCombFilter.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this.input.dispose();\n        this.output.dispose();\n        this.delayTime.dispose();\n        this.resonance.dispose();\n        return this;\n    };\n    return FeedbackCombFilter;\n}(ToneAudioWorklet));\nexport { FeedbackCombFilter };\n//# sourceMappingURL=FeedbackCombFilter.js.map"]},"metadata":{},"sourceType":"module"}