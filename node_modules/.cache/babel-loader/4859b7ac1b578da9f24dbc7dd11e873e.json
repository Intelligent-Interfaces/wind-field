{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { ToneAudioBuffers } from \"../core/context/ToneAudioBuffers\";\nimport { intervalToFrequencyRatio } from \"../core/type/Conversions\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { isArray, isNote, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument } from \"../instrument/Instrument\";\nimport { ToneBufferSource } from \"../source/buffer/ToneBufferSource\";\nimport { timeRange } from \"../core/util/Decorator\";\nimport { assert } from \"../core/util/Debug\";\n/**\n * Pass in an object which maps the note's pitch or midi value to the url,\n * then you can trigger the attack and release of that note like other instruments.\n * By automatically repitching the samples, it is possible to play pitches which\n * were not explicitly included which can save loading time.\n *\n * For sample or buffer playback where repitching is not necessary,\n * use [[Player]].\n * @example\n * import { Sampler } from \"tone\";\n * const sampler = new Sampler({\n * \turls: {\n * \t\tC1: \"C1.mp3\",\n * \t\tC2: \"C2.mp3\",\n * \t},\n * \tbaseUrl: \"https://tonejs.github.io/examples/audio/casio/\",\n * \tonload: () => {\n * \t\tsampler.triggerAttackRelease([\"C1\", \"E1\", \"G1\", \"B1\"], 0.5);\n * \t},\n * });\n * @category Instrument\n */\n\nvar Sampler =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Sampler, _super);\n\n  function Sampler() {\n    var _this = _super.call(this, optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\")) || this;\n\n    _this.name = \"Sampler\";\n    /**\n     * The object of all currently playing BufferSources\n     */\n\n    _this._activeSources = new Map();\n    var options = optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\");\n    var urlMap = {};\n    Object.keys(options.urls).forEach(function (note) {\n      var noteNumber = parseInt(note, 10);\n      assert(isNote(note) || isNumber(noteNumber) && isFinite(noteNumber), \"url key is neither a note or midi pitch: \" + note);\n\n      if (isNote(note)) {\n        // convert the note name to MIDI\n        var mid = new FrequencyClass(_this.context, note).toMidi();\n        urlMap[mid] = options.urls[note];\n      } else if (isNumber(noteNumber) && isFinite(noteNumber)) {\n        // otherwise if it's numbers assume it's midi\n        urlMap[noteNumber] = options.urls[noteNumber];\n      }\n    });\n    _this._buffers = new ToneAudioBuffers(urlMap, options.onload, options.baseUrl);\n    _this.attack = options.attack;\n    _this.release = options.release;\n    _this.curve = options.curve; // invoke the callback if it's already loaded\n\n    if (_this._buffers.loaded) {\n      // invoke onload deferred\n      Promise.resolve().then(options.onload);\n    }\n\n    return _this;\n  }\n\n  Sampler.getDefaults = function () {\n    return Object.assign(Instrument.getDefaults(), {\n      attack: 0,\n      baseUrl: \"\",\n      curve: \"exponential\",\n      onload: noOp,\n      release: 0.1,\n      urls: {}\n    });\n  };\n  /**\n   * Returns the difference in steps between the given midi note at the closets sample.\n   */\n\n\n  Sampler.prototype._findClosest = function (midi) {\n    // searches within 8 octaves of the given midi note\n    var MAX_INTERVAL = 96;\n    var interval = 0;\n\n    while (interval < MAX_INTERVAL) {\n      // check above and below\n      if (this._buffers.has(midi + interval)) {\n        return -interval;\n      } else if (this._buffers.has(midi - interval)) {\n        return interval;\n      }\n\n      interval++;\n    }\n\n    throw new Error(\"No available buffers for note: \" + midi);\n  };\n  /**\n   * @param  notes\tThe note to play, or an array of notes.\n   * @param  time     When to play the note\n   * @param  velocity The velocity to play the sample back.\n   */\n\n\n  Sampler.prototype.triggerAttack = function (notes, time, velocity) {\n    var _this = this;\n\n    if (velocity === void 0) {\n      velocity = 1;\n    }\n\n    this.log(\"triggerAttack\", notes, time, velocity);\n\n    if (!Array.isArray(notes)) {\n      notes = [notes];\n    }\n\n    notes.forEach(function (note) {\n      var midi = new FrequencyClass(_this.context, note).toMidi(); // find the closest note pitch\n\n      var difference = _this._findClosest(midi);\n\n      var closestNote = midi - difference;\n\n      var buffer = _this._buffers.get(closestNote);\n\n      var playbackRate = intervalToFrequencyRatio(difference); // play that note\n\n      var source = new ToneBufferSource({\n        buffer: buffer,\n        context: _this.context,\n        curve: _this.curve,\n        fadeIn: _this.attack,\n        fadeOut: _this.release,\n        playbackRate: playbackRate\n      }).connect(_this.output);\n      source.start(time, 0, buffer.duration / playbackRate, velocity); // add it to the active sources\n\n      if (!isArray(_this._activeSources.get(midi))) {\n        _this._activeSources.set(midi, []);\n      }\n\n      _this._activeSources.get(midi).push(source); // remove it when it's done\n\n\n      source.onended = function () {\n        if (_this._activeSources && _this._activeSources.has(midi)) {\n          var sources = _this._activeSources.get(midi);\n\n          var index = sources.indexOf(source);\n\n          if (index !== -1) {\n            sources.splice(index, 1);\n          }\n        }\n      };\n    });\n    return this;\n  };\n  /**\n   * @param  notes\tThe note to release, or an array of notes.\n   * @param  time     \tWhen to release the note.\n   */\n\n\n  Sampler.prototype.triggerRelease = function (notes, time) {\n    var _this = this;\n\n    this.log(\"triggerRelease\", notes, time);\n\n    if (!Array.isArray(notes)) {\n      notes = [notes];\n    }\n\n    notes.forEach(function (note) {\n      var midi = new FrequencyClass(_this.context, note).toMidi(); // find the note\n\n      if (_this._activeSources.has(midi) && _this._activeSources.get(midi).length) {\n        var sources = _this._activeSources.get(midi);\n\n        time = _this.toSeconds(time);\n        sources.forEach(function (source) {\n          source.stop(time);\n        });\n\n        _this._activeSources.set(midi, []);\n      }\n    });\n    return this;\n  };\n  /**\n   * Release all currently active notes.\n   * @param  time     \tWhen to release the notes.\n   */\n\n\n  Sampler.prototype.releaseAll = function (time) {\n    var computedTime = this.toSeconds(time);\n\n    this._activeSources.forEach(function (sources) {\n      while (sources.length) {\n        var source = sources.shift();\n        source.stop(computedTime);\n      }\n    });\n\n    return this;\n  };\n\n  Sampler.prototype.sync = function () {\n    this._syncMethod(\"triggerAttack\", 1);\n\n    this._syncMethod(\"triggerRelease\", 1);\n\n    return this;\n  };\n  /**\n   * Invoke the attack phase, then after the duration, invoke the release.\n   * @param  notes\tThe note to play and release, or an array of notes.\n   * @param  duration The time the note should be held\n   * @param  time     When to start the attack\n   * @param  velocity The velocity of the attack\n   */\n\n\n  Sampler.prototype.triggerAttackRelease = function (notes, duration, time, velocity) {\n    var _this = this;\n\n    if (velocity === void 0) {\n      velocity = 1;\n    }\n\n    var computedTime = this.toSeconds(time);\n    this.triggerAttack(notes, computedTime, velocity);\n\n    if (isArray(duration)) {\n      assert(isArray(notes), \"notes must be an array when duration is array\");\n      notes.forEach(function (note, index) {\n        var d = duration[Math.min(index, duration.length - 1)];\n\n        _this.triggerRelease(note, computedTime + _this.toSeconds(d));\n      });\n    } else {\n      this.triggerRelease(notes, computedTime + this.toSeconds(duration));\n    }\n\n    return this;\n  };\n  /**\n   * Add a note to the sampler.\n   * @param  note      The buffer's pitch.\n   * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.\n   * @param  callback  The callback to invoke when the url is loaded.\n   */\n\n\n  Sampler.prototype.add = function (note, url, callback) {\n    assert(isNote(note) || isFinite(note), \"note must be a pitch or midi: \" + note);\n\n    if (isNote(note)) {\n      // convert the note name to MIDI\n      var mid = new FrequencyClass(this.context, note).toMidi();\n\n      this._buffers.add(mid, url, callback);\n    } else {\n      // otherwise if it's numbers assume it's midi\n      this._buffers.add(note, url, callback);\n    }\n\n    return this;\n  };\n\n  Object.defineProperty(Sampler.prototype, \"loaded\", {\n    /**\n     * If the buffers are loaded or not\n     */\n    get: function () {\n      return this._buffers.loaded;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Clean up\n   */\n\n  Sampler.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._buffers.dispose();\n\n    this._activeSources.forEach(function (sources) {\n      sources.forEach(function (source) {\n        return source.dispose();\n      });\n    });\n\n    this._activeSources.clear();\n\n    return this;\n  };\n\n  tslib_1.__decorate([timeRange(0)], Sampler.prototype, \"attack\", void 0);\n\n  tslib_1.__decorate([timeRange(0)], Sampler.prototype, \"release\", void 0);\n\n  return Sampler;\n}(Instrument);\n\nexport { Sampler };","map":{"version":3,"sources":["../../../Tone/instrument/Sampler.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { ToneAudioBuffers } from \"../core/context/ToneAudioBuffers\";\nimport { intervalToFrequencyRatio } from \"../core/type/Conversions\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { isArray, isNote, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument } from \"../instrument/Instrument\";\nimport { ToneBufferSource } from \"../source/buffer/ToneBufferSource\";\nimport { timeRange } from \"../core/util/Decorator\";\nimport { assert } from \"../core/util/Debug\";\n/**\n * Pass in an object which maps the note's pitch or midi value to the url,\n * then you can trigger the attack and release of that note like other instruments.\n * By automatically repitching the samples, it is possible to play pitches which\n * were not explicitly included which can save loading time.\n *\n * For sample or buffer playback where repitching is not necessary,\n * use [[Player]].\n * @example\n * import { Sampler } from \"tone\";\n * const sampler = new Sampler({\n * \turls: {\n * \t\tC1: \"C1.mp3\",\n * \t\tC2: \"C2.mp3\",\n * \t},\n * \tbaseUrl: \"https://tonejs.github.io/examples/audio/casio/\",\n * \tonload: () => {\n * \t\tsampler.triggerAttackRelease([\"C1\", \"E1\", \"G1\", \"B1\"], 0.5);\n * \t},\n * });\n * @category Instrument\n */\nvar Sampler = /** @class */ (function (_super) {\n    tslib_1.__extends(Sampler, _super);\n    function Sampler() {\n        var _this = _super.call(this, optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\")) || this;\n        _this.name = \"Sampler\";\n        /**\n         * The object of all currently playing BufferSources\n         */\n        _this._activeSources = new Map();\n        var options = optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\");\n        var urlMap = {};\n        Object.keys(options.urls).forEach(function (note) {\n            var noteNumber = parseInt(note, 10);\n            assert(isNote(note)\n                || (isNumber(noteNumber) && isFinite(noteNumber)), \"url key is neither a note or midi pitch: \" + note);\n            if (isNote(note)) {\n                // convert the note name to MIDI\n                var mid = new FrequencyClass(_this.context, note).toMidi();\n                urlMap[mid] = options.urls[note];\n            }\n            else if (isNumber(noteNumber) && isFinite(noteNumber)) {\n                // otherwise if it's numbers assume it's midi\n                urlMap[noteNumber] = options.urls[noteNumber];\n            }\n        });\n        _this._buffers = new ToneAudioBuffers(urlMap, options.onload, options.baseUrl);\n        _this.attack = options.attack;\n        _this.release = options.release;\n        _this.curve = options.curve;\n        // invoke the callback if it's already loaded\n        if (_this._buffers.loaded) {\n            // invoke onload deferred\n            Promise.resolve().then(options.onload);\n        }\n        return _this;\n    }\n    Sampler.getDefaults = function () {\n        return Object.assign(Instrument.getDefaults(), {\n            attack: 0,\n            baseUrl: \"\",\n            curve: \"exponential\",\n            onload: noOp,\n            release: 0.1,\n            urls: {},\n        });\n    };\n    /**\n     * Returns the difference in steps between the given midi note at the closets sample.\n     */\n    Sampler.prototype._findClosest = function (midi) {\n        // searches within 8 octaves of the given midi note\n        var MAX_INTERVAL = 96;\n        var interval = 0;\n        while (interval < MAX_INTERVAL) {\n            // check above and below\n            if (this._buffers.has(midi + interval)) {\n                return -interval;\n            }\n            else if (this._buffers.has(midi - interval)) {\n                return interval;\n            }\n            interval++;\n        }\n        throw new Error(\"No available buffers for note: \" + midi);\n    };\n    /**\n     * @param  notes\tThe note to play, or an array of notes.\n     * @param  time     When to play the note\n     * @param  velocity The velocity to play the sample back.\n     */\n    Sampler.prototype.triggerAttack = function (notes, time, velocity) {\n        var _this = this;\n        if (velocity === void 0) { velocity = 1; }\n        this.log(\"triggerAttack\", notes, time, velocity);\n        if (!Array.isArray(notes)) {\n            notes = [notes];\n        }\n        notes.forEach(function (note) {\n            var midi = new FrequencyClass(_this.context, note).toMidi();\n            // find the closest note pitch\n            var difference = _this._findClosest(midi);\n            var closestNote = midi - difference;\n            var buffer = _this._buffers.get(closestNote);\n            var playbackRate = intervalToFrequencyRatio(difference);\n            // play that note\n            var source = new ToneBufferSource({\n                buffer: buffer,\n                context: _this.context,\n                curve: _this.curve,\n                fadeIn: _this.attack,\n                fadeOut: _this.release,\n                playbackRate: playbackRate,\n            }).connect(_this.output);\n            source.start(time, 0, buffer.duration / playbackRate, velocity);\n            // add it to the active sources\n            if (!isArray(_this._activeSources.get(midi))) {\n                _this._activeSources.set(midi, []);\n            }\n            _this._activeSources.get(midi).push(source);\n            // remove it when it's done\n            source.onended = function () {\n                if (_this._activeSources && _this._activeSources.has(midi)) {\n                    var sources = _this._activeSources.get(midi);\n                    var index = sources.indexOf(source);\n                    if (index !== -1) {\n                        sources.splice(index, 1);\n                    }\n                }\n            };\n        });\n        return this;\n    };\n    /**\n     * @param  notes\tThe note to release, or an array of notes.\n     * @param  time     \tWhen to release the note.\n     */\n    Sampler.prototype.triggerRelease = function (notes, time) {\n        var _this = this;\n        this.log(\"triggerRelease\", notes, time);\n        if (!Array.isArray(notes)) {\n            notes = [notes];\n        }\n        notes.forEach(function (note) {\n            var midi = new FrequencyClass(_this.context, note).toMidi();\n            // find the note\n            if (_this._activeSources.has(midi) && _this._activeSources.get(midi).length) {\n                var sources = _this._activeSources.get(midi);\n                time = _this.toSeconds(time);\n                sources.forEach(function (source) {\n                    source.stop(time);\n                });\n                _this._activeSources.set(midi, []);\n            }\n        });\n        return this;\n    };\n    /**\n     * Release all currently active notes.\n     * @param  time     \tWhen to release the notes.\n     */\n    Sampler.prototype.releaseAll = function (time) {\n        var computedTime = this.toSeconds(time);\n        this._activeSources.forEach(function (sources) {\n            while (sources.length) {\n                var source = sources.shift();\n                source.stop(computedTime);\n            }\n        });\n        return this;\n    };\n    Sampler.prototype.sync = function () {\n        this._syncMethod(\"triggerAttack\", 1);\n        this._syncMethod(\"triggerRelease\", 1);\n        return this;\n    };\n    /**\n     * Invoke the attack phase, then after the duration, invoke the release.\n     * @param  notes\tThe note to play and release, or an array of notes.\n     * @param  duration The time the note should be held\n     * @param  time     When to start the attack\n     * @param  velocity The velocity of the attack\n     */\n    Sampler.prototype.triggerAttackRelease = function (notes, duration, time, velocity) {\n        var _this = this;\n        if (velocity === void 0) { velocity = 1; }\n        var computedTime = this.toSeconds(time);\n        this.triggerAttack(notes, computedTime, velocity);\n        if (isArray(duration)) {\n            assert(isArray(notes), \"notes must be an array when duration is array\");\n            notes.forEach(function (note, index) {\n                var d = duration[Math.min(index, duration.length - 1)];\n                _this.triggerRelease(note, computedTime + _this.toSeconds(d));\n            });\n        }\n        else {\n            this.triggerRelease(notes, computedTime + this.toSeconds(duration));\n        }\n        return this;\n    };\n    /**\n     * Add a note to the sampler.\n     * @param  note      The buffer's pitch.\n     * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.\n     * @param  callback  The callback to invoke when the url is loaded.\n     */\n    Sampler.prototype.add = function (note, url, callback) {\n        assert(isNote(note) || isFinite(note), \"note must be a pitch or midi: \" + note);\n        if (isNote(note)) {\n            // convert the note name to MIDI\n            var mid = new FrequencyClass(this.context, note).toMidi();\n            this._buffers.add(mid, url, callback);\n        }\n        else {\n            // otherwise if it's numbers assume it's midi\n            this._buffers.add(note, url, callback);\n        }\n        return this;\n    };\n    Object.defineProperty(Sampler.prototype, \"loaded\", {\n        /**\n         * If the buffers are loaded or not\n         */\n        get: function () {\n            return this._buffers.loaded;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Clean up\n     */\n    Sampler.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this._buffers.dispose();\n        this._activeSources.forEach(function (sources) {\n            sources.forEach(function (source) { return source.dispose(); });\n        });\n        this._activeSources.clear();\n        return this;\n    };\n    tslib_1.__decorate([\n        timeRange(0)\n    ], Sampler.prototype, \"attack\", void 0);\n    tslib_1.__decorate([\n        timeRange(0)\n    ], Sampler.prototype, \"release\", void 0);\n    return Sampler;\n}(Instrument));\nexport { Sampler };\n//# sourceMappingURL=Sampler.js.map"]},"metadata":{},"sourceType":"module"}