{"ast":null,"code":"import _slicedToArray from \"/Users/erickoduniyi/Desktop/Work/multi_media_signal_processing/skeuomorphic-synth-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/*! Source code licensed under Apache License 2.0. Copyright Â© 2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { Util } from \"./Util\";\nimport { Geom, Num } from \"./Num\";\nimport { Pt, Group } from \"./Pt\";\nimport { Mat } from \"./LinearAlgebra\";\n\nlet _errorLength = (obj, param = \"expected\") => Util.warn(\"Group's length is less than \" + param, obj);\n\nlet _errorOutofBound = (obj, param = \"\") => Util.warn(`Index ${param} is out of bound in Group`, obj);\n\nexport class Line {\n  static fromAngle(anchor, angle, magnitude) {\n    let g = new Group(new Pt(anchor), new Pt(anchor));\n    g[1].toAngle(angle, magnitude, true);\n    return g;\n  }\n\n  static slope(p1, p2) {\n    return p2[0] - p1[0] === 0 ? undefined : (p2[1] - p1[1]) / (p2[0] - p1[0]);\n  }\n\n  static intercept(p1, p2) {\n    if (p2[0] - p1[0] === 0) {\n      return undefined;\n    } else {\n      let m = (p2[1] - p1[1]) / (p2[0] - p1[0]);\n      let c = p1[1] - m * p1[0];\n      return {\n        slope: m,\n        yi: c,\n        xi: m === 0 ? undefined : -c / m\n      };\n    }\n  }\n\n  static sideOfPt2D(line, pt) {\n    return (line[1][0] - line[0][0]) * (pt[1] - line[0][1]) - (pt[0] - line[0][0]) * (line[1][1] - line[0][1]);\n  }\n\n  static collinear(p1, p2, p3, threshold = 0.01) {\n    let a = new Pt(0, 0, 0).to(p1).$subtract(p2);\n    let b = new Pt(0, 0, 0).to(p1).$subtract(p3);\n    return a.$cross(b).divide(1000).equals(new Pt(0, 0, 0), threshold);\n  }\n\n  static magnitude(line) {\n    return line.length >= 2 ? line[1].$subtract(line[0]).magnitude() : 0;\n  }\n\n  static magnitudeSq(line) {\n    return line.length >= 2 ? line[1].$subtract(line[0]).magnitudeSq() : 0;\n  }\n\n  static perpendicularFromPt(line, pt, asProjection = false) {\n    if (line[0].equals(line[1])) return undefined;\n    let a = line[0].$subtract(line[1]);\n    let b = line[1].$subtract(pt);\n    let proj = b.$subtract(a.$project(b));\n    return asProjection ? proj : proj.$add(pt);\n  }\n\n  static distanceFromPt(line, pt) {\n    return Line.perpendicularFromPt(line, pt, true).magnitude();\n  }\n\n  static intersectRay2D(la, lb) {\n    let a = Line.intercept(la[0], la[1]);\n    let b = Line.intercept(lb[0], lb[1]);\n    let pa = la[0];\n    let pb = lb[0];\n\n    if (a == undefined) {\n      if (b == undefined) return undefined;\n      let y1 = -b.slope * (pb[0] - pa[0]) + pb[1];\n      return new Pt(pa[0], y1);\n    } else {\n      if (b == undefined) {\n        let y1 = -a.slope * (pa[0] - pb[0]) + pa[1];\n        return new Pt(pb[0], y1);\n      } else if (b.slope != a.slope) {\n        let px = (a.slope * pa[0] - b.slope * pb[0] + pb[1] - pa[1]) / (a.slope - b.slope);\n        let py = a.slope * (px - pa[0]) + pa[1];\n        return new Pt(px, py);\n      } else {\n        if (a.yi == b.yi) {\n          return new Pt(pa[0], pa[1]);\n        } else {\n          return undefined;\n        }\n      }\n    }\n  }\n\n  static intersectLine2D(la, lb) {\n    let pt = Line.intersectRay2D(la, lb);\n    return pt && Geom.withinBound(pt, la[0], la[1]) && Geom.withinBound(pt, lb[0], lb[1]) ? pt : undefined;\n  }\n\n  static intersectLineWithRay2D(line, ray) {\n    let pt = Line.intersectRay2D(line, ray);\n    return pt && Geom.withinBound(pt, line[0], line[1]) ? pt : undefined;\n  }\n\n  static intersectPolygon2D(lineOrRay, poly, sourceIsRay = false) {\n    let fn = sourceIsRay ? Line.intersectLineWithRay2D : Line.intersectLine2D;\n    let pts = new Group();\n\n    for (let i = 0, len = poly.length; i < len; i++) {\n      let next = i === len - 1 ? 0 : i + 1;\n      let d = fn([poly[i], poly[next]], lineOrRay);\n      if (d) pts.push(d);\n    }\n\n    return pts.length > 0 ? pts : undefined;\n  }\n\n  static intersectLines2D(lines1, lines2, isRay = false) {\n    let group = new Group();\n    let fn = isRay ? Line.intersectLineWithRay2D : Line.intersectLine2D;\n\n    for (let i = 0, len = lines1.length; i < len; i++) {\n      for (let k = 0, lenk = lines2.length; k < lenk; k++) {\n        let _ip = fn(lines1[i], lines2[k]);\n\n        if (_ip) group.push(_ip);\n      }\n    }\n\n    return group;\n  }\n\n  static intersectGridWithRay2D(ray, gridPt) {\n    let t = Line.intercept(new Pt(ray[0]).subtract(gridPt), new Pt(ray[1]).subtract(gridPt));\n    let g = new Group();\n    if (t && t.xi) g.push(new Pt(gridPt[0] + t.xi, gridPt[1]));\n    if (t && t.yi) g.push(new Pt(gridPt[0], gridPt[1] + t.yi));\n    return g;\n  }\n\n  static intersectGridWithLine2D(line, gridPt) {\n    let g = Line.intersectGridWithRay2D(line, gridPt);\n    let gg = new Group();\n\n    for (let i = 0, len = g.length; i < len; i++) {\n      if (Geom.withinBound(g[i], line[0], line[1])) gg.push(g[i]);\n    }\n\n    return gg;\n  }\n\n  static intersectRect2D(line, rect) {\n    let box = Geom.boundingBox(Group.fromPtArray(line));\n    if (!Rectangle.hasIntersectRect2D(box, rect)) return new Group();\n    return Line.intersectLines2D([line], Rectangle.sides(rect));\n  }\n\n  static subpoints(line, num) {\n    let pts = new Group();\n\n    for (let i = 1; i <= num; i++) {\n      pts.push(Geom.interpolate(line[0], line[1], i / (num + 1)));\n    }\n\n    return pts;\n  }\n\n  static crop(line, size, index = 0, cropAsCircle = true) {\n    let tdx = index === 0 ? 1 : 0;\n    let ls = line[tdx].$subtract(line[index]);\n    if (ls[0] === 0 || size[0] === 0) return line[index];\n\n    if (cropAsCircle) {\n      let d = ls.unit().multiply(size[1]);\n      return line[index].$add(d);\n    } else {\n      let rect = Rectangle.fromCenter(line[index], size);\n      let sides = Rectangle.sides(rect);\n      let sideIdx = 0;\n\n      if (Math.abs(ls[1] / ls[0]) > Math.abs(size[1] / size[0])) {\n        sideIdx = ls[1] < 0 ? 0 : 2;\n      } else {\n        sideIdx = ls[0] < 0 ? 3 : 1;\n      }\n\n      return Line.intersectRay2D(sides[sideIdx], line);\n    }\n  }\n\n  static marker(line, size, graphic = \"arrow\" || \"line\", atTail = true) {\n    let h = atTail ? 0 : 1;\n    let t = atTail ? 1 : 0;\n    let unit = line[h].$subtract(line[t]);\n    if (unit.magnitudeSq() === 0) return new Group();\n    unit.unit();\n    let ps = Geom.perpendicular(unit).multiply(size[0]).add(line[t]);\n\n    if (graphic == \"arrow\") {\n      ps.add(unit.$multiply(size[1]));\n      return new Group(line[t], ps[0], ps[1]);\n    } else {\n      return new Group(ps[0], ps[1]);\n    }\n  }\n\n  static toRect(line) {\n    return new Group(line[0].$min(line[1]), line[0].$max(line[1]));\n  }\n\n}\nexport class Rectangle {\n  static from(topLeft, widthOrSize, height) {\n    return Rectangle.fromTopLeft(topLeft, widthOrSize, height);\n  }\n\n  static fromTopLeft(topLeft, widthOrSize, height) {\n    let size = typeof widthOrSize == \"number\" ? [widthOrSize, height || widthOrSize] : widthOrSize;\n    return new Group(new Pt(topLeft), new Pt(topLeft).add(size));\n  }\n\n  static fromCenter(center, widthOrSize, height) {\n    let half = typeof widthOrSize == \"number\" ? [widthOrSize / 2, (height || widthOrSize) / 2] : new Pt(widthOrSize).divide(2);\n    return new Group(new Pt(center).subtract(half), new Pt(center).add(half));\n  }\n\n  static toCircle(pts, within = true) {\n    return Circle.fromRect(pts, within);\n  }\n\n  static toSquare(pts, enclose = false) {\n    let s = Rectangle.size(pts);\n    let m = enclose ? s.maxValue().value : s.minValue().value;\n    return Rectangle.fromCenter(Rectangle.center(pts), m, m);\n  }\n\n  static size(pts) {\n    return pts[0].$max(pts[1]).subtract(pts[0].$min(pts[1]));\n  }\n\n  static center(pts) {\n    let min = pts[0].$min(pts[1]);\n    let max = pts[0].$max(pts[1]);\n    return min.add(max.$subtract(min).divide(2));\n  }\n\n  static corners(rect) {\n    let p0 = rect[0].$min(rect[1]);\n    let p2 = rect[0].$max(rect[1]);\n    return new Group(p0, new Pt(p2.x, p0.y), p2, new Pt(p0.x, p2.y));\n  }\n\n  static sides(rect) {\n    let _Rectangle$corners = Rectangle.corners(rect),\n        _Rectangle$corners2 = _slicedToArray(_Rectangle$corners, 4),\n        p0 = _Rectangle$corners2[0],\n        p1 = _Rectangle$corners2[1],\n        p2 = _Rectangle$corners2[2],\n        p3 = _Rectangle$corners2[3];\n\n    return [new Group(p0, p1), new Group(p1, p2), new Group(p2, p3), new Group(p3, p0)];\n  }\n\n  static boundingBox(rects) {\n    let merged = Util.flatten(rects, false);\n    let min = Pt.make(2, Number.MAX_VALUE);\n    let max = Pt.make(2, Number.MIN_VALUE);\n\n    for (let i = 0, len = merged.length; i < len; i++) {\n      for (let k = 0; k < 2; k++) {\n        min[k] = Math.min(min[k], merged[i][k]);\n        max[k] = Math.max(max[k], merged[i][k]);\n      }\n    }\n\n    return new Group(min, max);\n  }\n\n  static polygon(rect) {\n    return Rectangle.corners(rect);\n  }\n\n  static quadrants(rect, center) {\n    let corners = Rectangle.corners(rect);\n\n    let _center = center != undefined ? new Pt(center) : Rectangle.center(rect);\n\n    return corners.map(c => new Group(c, _center).boundingBox());\n  }\n\n  static halves(rect, ratio = 0.5, asRows = false) {\n    let min = rect[0].$min(rect[1]);\n    let max = rect[0].$max(rect[1]);\n    let mid = asRows ? Num.lerp(min[1], max[1], ratio) : Num.lerp(min[0], max[0], ratio);\n    return asRows ? [new Group(min, new Pt(max[0], mid)), new Group(new Pt(min[0], mid), max)] : [new Group(min, new Pt(mid, max[1])), new Group(new Pt(mid, min[1]), max)];\n  }\n\n  static withinBound(rect, pt) {\n    return Geom.withinBound(pt, rect[0], rect[1]);\n  }\n\n  static hasIntersectRect2D(rect1, rect2, resetBoundingBox = false) {\n    if (resetBoundingBox) {\n      rect1 = Geom.boundingBox(rect1);\n      rect2 = Geom.boundingBox(rect2);\n    }\n\n    if (rect1[0][0] > rect2[1][0] || rect2[0][0] > rect1[1][0]) return false;\n    if (rect1[0][1] > rect2[1][1] || rect2[0][1] > rect1[1][1]) return false;\n    return true;\n  }\n\n  static intersectRect2D(rect1, rect2) {\n    if (!Rectangle.hasIntersectRect2D(rect1, rect2)) return new Group();\n    return Line.intersectLines2D(Rectangle.sides(rect1), Rectangle.sides(rect2));\n  }\n\n}\nexport class Circle {\n  static fromRect(pts, enclose = false) {\n    let r = 0;\n    let min = r = Rectangle.size(pts).minValue().value / 2;\n\n    if (enclose) {\n      let max = Rectangle.size(pts).maxValue().value / 2;\n      r = Math.sqrt(min * min + max * max);\n    } else {\n      r = min;\n    }\n\n    return new Group(Rectangle.center(pts), new Pt(r, r));\n  }\n\n  static fromTriangle(pts, enclose = false) {\n    if (enclose) {\n      return Triangle.circumcircle(pts);\n    } else {\n      return Triangle.incircle(pts);\n    }\n  }\n\n  static fromCenter(pt, radius) {\n    return new Group(new Pt(pt), new Pt(radius, radius));\n  }\n\n  static withinBound(pts, pt, threshold = 0) {\n    let d = pts[0].$subtract(pt);\n    return d.dot(d) + threshold < pts[1].x * pts[1].x;\n  }\n\n  static intersectRay2D(pts, ray) {\n    let d = ray[0].$subtract(ray[1]);\n    let f = pts[0].$subtract(ray[0]);\n    let a = d.dot(d);\n    let b = f.dot(d);\n    let c = f.dot(f) - pts[1].x * pts[1].x;\n    let p = b / a;\n    let q = c / a;\n    let disc = p * p - q;\n\n    if (disc < 0) {\n      return new Group();\n    } else {\n      let discSqrt = Math.sqrt(disc);\n      let t1 = -p + discSqrt;\n      let p1 = ray[0].$subtract(d.$multiply(t1));\n      if (disc === 0) return new Group(p1);\n      let t2 = -p - discSqrt;\n      let p2 = ray[0].$subtract(d.$multiply(t2));\n      return new Group(p1, p2);\n    }\n  }\n\n  static intersectLine2D(pts, line) {\n    let ps = Circle.intersectRay2D(pts, line);\n    let g = new Group();\n\n    if (ps.length > 0) {\n      for (let i = 0, len = ps.length; i < len; i++) {\n        if (Rectangle.withinBound(line, ps[i])) g.push(ps[i]);\n      }\n    }\n\n    return g;\n  }\n\n  static intersectCircle2D(pts, circle) {\n    let dv = circle[0].$subtract(pts[0]);\n    let dr2 = dv.magnitudeSq();\n    let dr = Math.sqrt(dr2);\n    let ar = pts[1].x;\n    let br = circle[1].x;\n    let ar2 = ar * ar;\n    let br2 = br * br;\n\n    if (dr > ar + br) {\n      return new Group();\n    } else if (dr < Math.abs(ar - br)) {\n      return new Group(pts[0].clone());\n    } else {\n      let a = (ar2 - br2 + dr2) / (2 * dr);\n      let h = Math.sqrt(ar2 - a * a);\n      let p = dv.$multiply(a / dr).add(pts[0]);\n      return new Group(new Pt(p.x + h * dv.y / dr, p.y - h * dv.x / dr), new Pt(p.x - h * dv.y / dr, p.y + h * dv.x / dr));\n    }\n  }\n\n  static intersectRect2D(pts, rect) {\n    let sides = Rectangle.sides(rect);\n    let g = [];\n\n    for (let i = 0, len = sides.length; i < len; i++) {\n      let ps = Circle.intersectLine2D(pts, sides[i]);\n      if (ps.length > 0) g.push(ps);\n    }\n\n    return Util.flatten(g);\n  }\n\n  static toRect(pts, within = false) {\n    let r = pts[1][0];\n\n    if (within) {\n      let half = Math.sqrt(r * r) / 2;\n      return new Group(pts[0].$subtract(half), pts[0].$add(half));\n    } else {\n      return new Group(pts[0].$subtract(r), pts[0].$add(r));\n    }\n  }\n\n  static toTriangle(pts, within = true) {\n    if (within) {\n      let ang = -Math.PI / 2;\n      let inc = Math.PI * 2 / 3;\n      let g = new Group();\n\n      for (let i = 0; i < 3; i++) {\n        g.push(pts[0].clone().toAngle(ang, pts[1][0], true));\n        ang += inc;\n      }\n\n      return g;\n    } else {\n      return Triangle.fromCenter(pts[0], pts[1][0]);\n    }\n  }\n\n}\nexport class Triangle {\n  static fromRect(rect) {\n    let top = rect[0].$add(rect[1]).divide(2);\n    top.y = rect[0][1];\n    let left = rect[1].clone();\n    left.x = rect[0][0];\n    return new Group(top, rect[1].clone(), left);\n  }\n\n  static fromCircle(circle) {\n    return Circle.toTriangle(circle, true);\n  }\n\n  static fromCenter(pt, size) {\n    return Triangle.fromCircle(Circle.fromCenter(pt, size));\n  }\n\n  static medial(pts) {\n    if (pts.length < 3) return _errorLength(new Group(), 3);\n    return Polygon.midpoints(pts, true);\n  }\n\n  static oppositeSide(pts, index) {\n    if (pts.length < 3) return _errorLength(new Group(), 3);\n\n    if (index === 0) {\n      return Group.fromPtArray([pts[1], pts[2]]);\n    } else if (index === 1) {\n      return Group.fromPtArray([pts[0], pts[2]]);\n    } else {\n      return Group.fromPtArray([pts[0], pts[1]]);\n    }\n  }\n\n  static altitude(pts, index) {\n    let opp = Triangle.oppositeSide(pts, index);\n\n    if (opp.length > 1) {\n      return new Group(pts[index], Line.perpendicularFromPt(opp, pts[index]));\n    } else {\n      return new Group();\n    }\n  }\n\n  static orthocenter(pts) {\n    if (pts.length < 3) return _errorLength(undefined, 3);\n    let a = Triangle.altitude(pts, 0);\n    let b = Triangle.altitude(pts, 1);\n    return Line.intersectRay2D(a, b);\n  }\n\n  static incenter(pts) {\n    if (pts.length < 3) return _errorLength(undefined, 3);\n    let a = Polygon.bisector(pts, 0).add(pts[0]);\n    let b = Polygon.bisector(pts, 1).add(pts[1]);\n    return Line.intersectRay2D(new Group(pts[0], a), new Group(pts[1], b));\n  }\n\n  static incircle(pts, center) {\n    let c = center ? center : Triangle.incenter(pts);\n    let area = Polygon.area(pts);\n    let perim = Polygon.perimeter(pts, true);\n    let r = 2 * area / perim.total;\n    return Circle.fromCenter(c, r);\n  }\n\n  static circumcenter(pts) {\n    let md = Triangle.medial(pts);\n    let a = [md[0], Geom.perpendicular(pts[0].$subtract(md[0])).p1.$add(md[0])];\n    let b = [md[1], Geom.perpendicular(pts[1].$subtract(md[1])).p1.$add(md[1])];\n    return Line.intersectRay2D(a, b);\n  }\n\n  static circumcircle(pts, center) {\n    let c = center ? center : Triangle.circumcenter(pts);\n    let r = pts[0].$subtract(c).magnitude();\n    return Circle.fromCenter(c, r);\n  }\n\n}\nexport class Polygon {\n  static centroid(pts) {\n    return Geom.centroid(pts);\n  }\n\n  static rectangle(center, widthOrSize, height) {\n    return Rectangle.corners(Rectangle.fromCenter(center, widthOrSize, height));\n  }\n\n  static fromCenter(center, radius, sides) {\n    let g = new Group();\n\n    for (let i = 0; i < sides; i++) {\n      let ang = Math.PI * 2 * i / sides;\n      g.push(new Pt(Math.cos(ang) * radius, Math.sin(ang) * radius).add(center));\n    }\n\n    return g;\n  }\n\n  static lineAt(pts, idx) {\n    if (idx < 0 || idx >= pts.length) throw new Error(\"index out of the Polygon's range\");\n    return new Group(pts[idx], idx === pts.length - 1 ? pts[0] : pts[idx + 1]);\n  }\n\n  static lines(pts, closePath = true) {\n    if (pts.length < 2) return _errorLength(new Group(), 2);\n    let sp = Util.split(pts, 2, 1);\n    if (closePath) sp.push(new Group(pts[pts.length - 1], pts[0]));\n    return sp.map(g => g);\n  }\n\n  static midpoints(pts, closePath = false, t = 0.5) {\n    if (pts.length < 2) return _errorLength(new Group(), 2);\n    let sides = Polygon.lines(pts, closePath);\n    let mids = sides.map(s => Geom.interpolate(s[0], s[1], t));\n    return mids;\n  }\n\n  static adjacentSides(pts, index, closePath = false) {\n    if (pts.length < 2) return _errorLength(new Group(), 2);\n    if (index < 0 || index >= pts.length) return _errorOutofBound(new Group(), index);\n    let gs = [];\n    let left = index - 1;\n    if (closePath && left < 0) left = pts.length - 1;\n    if (left >= 0) gs.push(new Group(pts[index], pts[left]));\n    let right = index + 1;\n    if (closePath && right > pts.length - 1) right = 0;\n    if (right <= pts.length - 1) gs.push(new Group(pts[index], pts[right]));\n    return gs;\n  }\n\n  static bisector(pts, index) {\n    let sides = Polygon.adjacentSides(pts, index, true);\n\n    if (sides.length >= 2) {\n      let a = sides[0][1].$subtract(sides[0][0]).unit();\n      let b = sides[1][1].$subtract(sides[1][0]).unit();\n      return a.add(b).divide(2);\n    } else {\n      return undefined;\n    }\n  }\n\n  static perimeter(pts, closePath = false) {\n    if (pts.length < 2) return _errorLength(new Group(), 2);\n    let lines = Polygon.lines(pts, closePath);\n    let mag = 0;\n    let p = Pt.make(lines.length, 0);\n\n    for (let i = 0, len = lines.length; i < len; i++) {\n      let m = Line.magnitude(lines[i]);\n      mag += m;\n      p[i] = m;\n    }\n\n    return {\n      total: mag,\n      segments: p\n    };\n  }\n\n  static area(pts) {\n    if (pts.length < 3) return _errorLength(new Group(), 3);\n\n    let det = (a, b) => a[0] * b[1] - a[1] * b[0];\n\n    let area = 0;\n\n    for (let i = 0, len = pts.length; i < len; i++) {\n      if (i < pts.length - 1) {\n        area += det(pts[i], pts[i + 1]);\n      } else {\n        area += det(pts[i], pts[0]);\n      }\n    }\n\n    return Math.abs(area / 2);\n  }\n\n  static convexHull(pts, sorted = false) {\n    if (pts.length < 3) return _errorLength(new Group(), 3);\n\n    if (!sorted) {\n      pts = pts.slice();\n      pts.sort((a, b) => a[0] - b[0]);\n    }\n\n    let left = (a, b, c) => {\n      return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]) > 0;\n    };\n\n    let dq = [];\n    let bot = pts.length - 2;\n    let top = bot + 3;\n    dq[bot] = pts[2];\n    dq[top] = pts[2];\n\n    if (left(pts[0], pts[1], pts[2])) {\n      dq[bot + 1] = pts[0];\n      dq[bot + 2] = pts[1];\n    } else {\n      dq[bot + 1] = pts[1];\n      dq[bot + 2] = pts[0];\n    }\n\n    for (let i = 3, len = pts.length; i < len; i++) {\n      let pt = pts[i];\n\n      if (left(dq[bot], dq[bot + 1], pt) && left(dq[top - 1], dq[top], pt)) {\n        continue;\n      }\n\n      while (!left(dq[bot], dq[bot + 1], pt)) {\n        bot += 1;\n      }\n\n      bot -= 1;\n      dq[bot] = pt;\n\n      while (!left(dq[top - 1], dq[top], pt)) {\n        top -= 1;\n      }\n\n      top += 1;\n      dq[top] = pt;\n    }\n\n    let hull = new Group();\n\n    for (let h = 0; h < top - bot; h++) {\n      hull.push(dq[bot + h]);\n    }\n\n    return hull;\n  }\n\n  static network(pts, originIndex = 0) {\n    let g = [];\n\n    for (let i = 0, len = pts.length; i < len; i++) {\n      if (i != originIndex) g.push(new Group(pts[originIndex], pts[i]));\n    }\n\n    return g;\n  }\n\n  static nearestPt(pts, pt) {\n    let _near = Number.MAX_VALUE;\n\n    let _item = -1;\n\n    for (let i = 0, len = pts.length; i < len; i++) {\n      let d = pts[i].$subtract(pt).magnitudeSq();\n\n      if (d < _near) {\n        _near = d;\n        _item = i;\n      }\n    }\n\n    return _item;\n  }\n\n  static projectAxis(poly, unitAxis) {\n    let dot = unitAxis.dot(poly[0]);\n    let d = new Pt(dot, dot);\n\n    for (let n = 1, len = poly.length; n < len; n++) {\n      dot = unitAxis.dot(poly[n]);\n      d = new Pt(Math.min(dot, d[0]), Math.max(dot, d[1]));\n    }\n\n    return d;\n  }\n\n  static _axisOverlap(poly1, poly2, unitAxis) {\n    let pa = Polygon.projectAxis(poly1, unitAxis);\n    let pb = Polygon.projectAxis(poly2, unitAxis);\n    return pa[0] < pb[0] ? pb[0] - pa[1] : pa[0] - pb[1];\n  }\n\n  static hasIntersectPoint(poly, pt) {\n    let c = false;\n\n    for (let i = 0, len = poly.length; i < len; i++) {\n      let ln = Polygon.lineAt(poly, i);\n\n      if (ln[0][1] > pt[1] != ln[1][1] > pt[1] && pt[0] < (ln[1][0] - ln[0][0]) * (pt[1] - ln[0][1]) / (ln[1][1] - ln[0][1]) + ln[0][0]) {\n        c = !c;\n      }\n    }\n\n    return c;\n  }\n\n  static hasIntersectCircle(poly, circle) {\n    let info = {\n      which: -1,\n      dist: 0,\n      normal: null,\n      edge: null,\n      vertex: null\n    };\n    let c = circle[0];\n    let r = circle[1][0];\n    let minDist = Number.MAX_SAFE_INTEGER;\n\n    for (let i = 0, len = poly.length; i < len; i++) {\n      let edge = Polygon.lineAt(poly, i);\n      let axis = new Pt(edge[0].y - edge[1].y, edge[1].x - edge[0].x).unit();\n      let poly2 = new Group(c.$add(axis.$multiply(r)), c.$subtract(axis.$multiply(r)));\n\n      let dist = Polygon._axisOverlap(poly, poly2, axis);\n\n      if (dist > 0) {\n        return null;\n      } else if (Math.abs(dist) < minDist) {\n        let check = Rectangle.withinBound(edge, Line.perpendicularFromPt(edge, c)) || Circle.intersectLine2D(circle, edge).length > 0;\n\n        if (check) {\n          info.edge = edge;\n          info.normal = axis;\n          minDist = Math.abs(dist);\n          info.which = i;\n        }\n      }\n    }\n\n    if (!info.edge) return null;\n    let dir = c.$subtract(Polygon.centroid(poly)).dot(info.normal);\n    if (dir < 0) info.normal.multiply(-1);\n    info.dist = minDist;\n    info.vertex = c;\n    return info;\n  }\n\n  static hasIntersectPolygon(poly1, poly2) {\n    let info = {\n      which: -1,\n      dist: 0,\n      normal: new Pt(),\n      edge: new Group(),\n      vertex: new Pt()\n    };\n    let minDist = Number.MAX_SAFE_INTEGER;\n\n    for (let i = 0, plen = poly1.length + poly2.length; i < plen; i++) {\n      let edge = i < poly1.length ? Polygon.lineAt(poly1, i) : Polygon.lineAt(poly2, i - poly1.length);\n      let axis = new Pt(edge[0].y - edge[1].y, edge[1].x - edge[0].x).unit();\n\n      let dist = Polygon._axisOverlap(poly1, poly2, axis);\n\n      if (dist > 0) {\n        return null;\n      } else if (Math.abs(dist) < minDist) {\n        info.edge = edge;\n        info.normal = axis;\n        minDist = Math.abs(dist);\n        info.which = i < poly1.length ? 0 : 1;\n      }\n    }\n\n    info.dist = minDist;\n    let b1 = info.which === 0 ? poly2 : poly1;\n    let b2 = info.which === 0 ? poly1 : poly2;\n    let c1 = Polygon.centroid(b1);\n    let c2 = Polygon.centroid(b2);\n    let dir = c1.$subtract(c2).dot(info.normal);\n    if (dir < 0) info.normal.multiply(-1);\n    let smallest = Number.MAX_SAFE_INTEGER;\n\n    for (let i = 0, len = b1.length; i < len; i++) {\n      let d = info.normal.dot(b1[i].$subtract(c2));\n\n      if (d < smallest) {\n        smallest = d;\n        info.vertex = b1[i];\n      }\n    }\n\n    return info;\n  }\n\n  static intersectPolygon2D(poly1, poly2) {\n    let lp = Polygon.lines(poly1);\n    let g = [];\n\n    for (let i = 0, len = lp.length; i < len; i++) {\n      let ins = Line.intersectPolygon2D(lp[i], poly2, false);\n      if (ins) g.push(ins);\n    }\n\n    return Util.flatten(g, true);\n  }\n\n  static toRects(polys) {\n    let boxes = polys.map(g => Geom.boundingBox(g));\n    let merged = Util.flatten(boxes, false);\n    boxes.unshift(Geom.boundingBox(merged));\n    return boxes;\n  }\n\n}\nexport class Curve {\n  static getSteps(steps) {\n    let ts = new Group();\n\n    for (let i = 0; i <= steps; i++) {\n      let t = i / steps;\n      ts.push(new Pt(t * t * t, t * t, t, 1));\n    }\n\n    return ts;\n  }\n\n  static controlPoints(pts, index = 0, copyStart = false) {\n    if (index > pts.length - 1) return new Group();\n\n    let _index = i => i < pts.length - 1 ? i : pts.length - 1;\n\n    let p0 = pts[index];\n    index = copyStart ? index : index + 1;\n    return new Group(p0, pts[_index(index++)], pts[_index(index++)], pts[_index(index++)]);\n  }\n\n  static _calcPt(ctrls, params) {\n    let x = ctrls.reduce((a, c, i) => a + c.x * params[i], 0);\n    let y = ctrls.reduce((a, c, i) => a + c.y * params[i], 0);\n\n    if (ctrls[0].length > 2) {\n      let z = ctrls.reduce((a, c, i) => a + c.z * params[i], 0);\n      return new Pt(x, y, z);\n    }\n\n    return new Pt(x, y);\n  }\n\n  static catmullRom(pts, steps = 10) {\n    if (pts.length < 2) return new Group();\n    let ps = new Group();\n    let ts = Curve.getSteps(steps);\n    let c = Curve.controlPoints(pts, 0, true);\n\n    for (let i = 0; i <= steps; i++) {\n      ps.push(Curve.catmullRomStep(ts[i], c));\n    }\n\n    let k = 0;\n\n    while (k < pts.length - 2) {\n      let cp = Curve.controlPoints(pts, k);\n\n      if (cp.length > 0) {\n        for (let i = 0; i <= steps; i++) {\n          ps.push(Curve.catmullRomStep(ts[i], cp));\n        }\n\n        k++;\n      }\n    }\n\n    return ps;\n  }\n\n  static catmullRomStep(step, ctrls) {\n    let m = new Group(new Pt(-0.5, 1, -0.5, 0), new Pt(1.5, -2.5, 0, 1), new Pt(-1.5, 2, 0.5, 0), new Pt(0.5, -0.5, 0, 0));\n    return Curve._calcPt(ctrls, Mat.multiply([step], m, true)[0]);\n  }\n\n  static cardinal(pts, steps = 10, tension = 0.5) {\n    if (pts.length < 2) return new Group();\n    let ps = new Group();\n    let ts = Curve.getSteps(steps);\n    let c = Curve.controlPoints(pts, 0, true);\n\n    for (let i = 0; i <= steps; i++) {\n      ps.push(Curve.cardinalStep(ts[i], c, tension));\n    }\n\n    let k = 0;\n\n    while (k < pts.length - 2) {\n      let cp = Curve.controlPoints(pts, k);\n\n      if (cp.length > 0) {\n        for (let i = 0; i <= steps; i++) {\n          ps.push(Curve.cardinalStep(ts[i], cp, tension));\n        }\n\n        k++;\n      }\n    }\n\n    return ps;\n  }\n\n  static cardinalStep(step, ctrls, tension = 0.5) {\n    let m = new Group(new Pt(-1, 2, -1, 0), new Pt(-1, 1, 0, 0), new Pt(1, -2, 1, 0), new Pt(1, -1, 0, 0));\n    let h = Mat.multiply([step], m, true)[0].multiply(tension);\n    let h2 = 2 * step[0] - 3 * step[1] + 1;\n    let h3 = -2 * step[0] + 3 * step[1];\n\n    let pt = Curve._calcPt(ctrls, h);\n\n    pt.x += h2 * ctrls[1].x + h3 * ctrls[2].x;\n    pt.y += h2 * ctrls[1].y + h3 * ctrls[2].y;\n    if (pt.length > 2) pt.z += h2 * ctrls[1].z + h3 * ctrls[2].z;\n    return pt;\n  }\n\n  static bezier(pts, steps = 10) {\n    if (pts.length < 4) return new Group();\n    let ps = new Group();\n    let ts = Curve.getSteps(steps);\n    let k = 0;\n\n    while (k < pts.length - 3) {\n      let c = Curve.controlPoints(pts, k);\n\n      if (c.length > 0) {\n        for (let i = 0; i <= steps; i++) {\n          ps.push(Curve.bezierStep(ts[i], c));\n        }\n\n        k += 3;\n      }\n    }\n\n    return ps;\n  }\n\n  static bezierStep(step, ctrls) {\n    let m = new Group(new Pt(-1, 3, -3, 1), new Pt(3, -6, 3, 0), new Pt(-3, 3, 0, 0), new Pt(1, 0, 0, 0));\n    return Curve._calcPt(ctrls, Mat.multiply([step], m, true)[0]);\n  }\n\n  static bspline(pts, steps = 10, tension = 1) {\n    if (pts.length < 2) return new Group();\n    let ps = new Group();\n    let ts = Curve.getSteps(steps);\n    let k = 0;\n\n    while (k < pts.length - 3) {\n      let c = Curve.controlPoints(pts, k);\n\n      if (c.length > 0) {\n        if (tension !== 1) {\n          for (let i = 0; i <= steps; i++) {\n            ps.push(Curve.bsplineTensionStep(ts[i], c, tension));\n          }\n        } else {\n          for (let i = 0; i <= steps; i++) {\n            ps.push(Curve.bsplineStep(ts[i], c));\n          }\n        }\n\n        k++;\n      }\n    }\n\n    return ps;\n  }\n\n  static bsplineStep(step, ctrls) {\n    let m = new Group(new Pt(-0.16666666666666666, 0.5, -0.5, 0.16666666666666666), new Pt(0.5, -1, 0, 0.6666666666666666), new Pt(-0.5, 0.5, 0.5, 0.16666666666666666), new Pt(0.16666666666666666, 0, 0, 0));\n    return Curve._calcPt(ctrls, Mat.multiply([step], m, true)[0]);\n  }\n\n  static bsplineTensionStep(step, ctrls, tension = 1) {\n    let m = new Group(new Pt(-0.16666666666666666, 0.5, -0.5, 0.16666666666666666), new Pt(-1.5, 2, 0, -0.3333333333333333), new Pt(1.5, -2.5, 0.5, 0.16666666666666666), new Pt(0.16666666666666666, 0, 0, 0));\n    let h = Mat.multiply([step], m, true)[0].multiply(tension);\n    let h2 = 2 * step[0] - 3 * step[1] + 1;\n    let h3 = -2 * step[0] + 3 * step[1];\n\n    let pt = Curve._calcPt(ctrls, h);\n\n    pt.x += h2 * ctrls[1].x + h3 * ctrls[2].x;\n    pt.y += h2 * ctrls[1].y + h3 * ctrls[2].y;\n    if (pt.length > 2) pt.z += h2 * ctrls[1].z + h3 * ctrls[2].z;\n    return pt;\n  }\n\n}","map":{"version":3,"sources":["/Users/erickoduniyi/Desktop/Work/multi_media_signal_processing/skeuomorphic-synth-master/node_modules/pts/dist/es2015/Op.js"],"names":["Util","Geom","Num","Pt","Group","Mat","_errorLength","obj","param","warn","_errorOutofBound","Line","fromAngle","anchor","angle","magnitude","g","toAngle","slope","p1","p2","undefined","intercept","m","c","yi","xi","sideOfPt2D","line","pt","collinear","p3","threshold","a","to","$subtract","b","$cross","divide","equals","length","magnitudeSq","perpendicularFromPt","asProjection","proj","$project","$add","distanceFromPt","intersectRay2D","la","lb","pa","pb","y1","px","py","intersectLine2D","withinBound","intersectLineWithRay2D","ray","intersectPolygon2D","lineOrRay","poly","sourceIsRay","fn","pts","i","len","next","d","push","intersectLines2D","lines1","lines2","isRay","group","k","lenk","_ip","intersectGridWithRay2D","gridPt","t","subtract","intersectGridWithLine2D","gg","intersectRect2D","rect","box","boundingBox","fromPtArray","Rectangle","hasIntersectRect2D","sides","subpoints","num","interpolate","crop","size","index","cropAsCircle","tdx","ls","unit","multiply","fromCenter","sideIdx","Math","abs","marker","graphic","atTail","h","ps","perpendicular","add","$multiply","toRect","$min","$max","from","topLeft","widthOrSize","height","fromTopLeft","center","half","toCircle","within","Circle","fromRect","toSquare","enclose","s","maxValue","value","minValue","min","max","corners","p0","x","y","rects","merged","flatten","make","Number","MAX_VALUE","MIN_VALUE","polygon","quadrants","_center","map","halves","ratio","asRows","mid","lerp","rect1","rect2","resetBoundingBox","r","sqrt","fromTriangle","Triangle","circumcircle","incircle","radius","dot","f","p","q","disc","discSqrt","t1","t2","intersectCircle2D","circle","dv","dr2","dr","ar","br","ar2","br2","clone","toTriangle","ang","PI","inc","top","left","fromCircle","medial","Polygon","midpoints","oppositeSide","altitude","opp","orthocenter","incenter","bisector","area","perim","perimeter","total","circumcenter","md","centroid","rectangle","cos","sin","lineAt","idx","Error","lines","closePath","sp","split","mids","adjacentSides","gs","right","mag","segments","det","convexHull","sorted","slice","sort","dq","bot","hull","network","originIndex","nearestPt","_near","_item","projectAxis","unitAxis","n","_axisOverlap","poly1","poly2","hasIntersectPoint","ln","hasIntersectCircle","info","which","dist","normal","edge","vertex","minDist","MAX_SAFE_INTEGER","axis","check","dir","hasIntersectPolygon","plen","b1","b2","c1","c2","smallest","lp","ins","toRects","polys","boxes","unshift","Curve","getSteps","steps","ts","controlPoints","copyStart","_index","_calcPt","ctrls","params","reduce","z","catmullRom","catmullRomStep","cp","step","cardinal","tension","cardinalStep","h2","h3","bezier","bezierStep","bspline","bsplineTensionStep","bsplineStep"],"mappings":"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","sourcesContent":["/*! Source code licensed under Apache License 2.0. Copyright Â© 2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { Util } from \"./Util\";\nimport { Geom, Num } from \"./Num\";\nimport { Pt, Group } from \"./Pt\";\nimport { Mat } from \"./LinearAlgebra\";\nlet _errorLength = (obj, param = \"expected\") => Util.warn(\"Group's length is less than \" + param, obj);\nlet _errorOutofBound = (obj, param = \"\") => Util.warn(`Index ${param} is out of bound in Group`, obj);\nexport class Line {\n    static fromAngle(anchor, angle, magnitude) {\n        let g = new Group(new Pt(anchor), new Pt(anchor));\n        g[1].toAngle(angle, magnitude, true);\n        return g;\n    }\n    static slope(p1, p2) {\n        return (p2[0] - p1[0] === 0) ? undefined : (p2[1] - p1[1]) / (p2[0] - p1[0]);\n    }\n    static intercept(p1, p2) {\n        if (p2[0] - p1[0] === 0) {\n            return undefined;\n        }\n        else {\n            let m = (p2[1] - p1[1]) / (p2[0] - p1[0]);\n            let c = p1[1] - m * p1[0];\n            return { slope: m, yi: c, xi: (m === 0) ? undefined : -c / m };\n        }\n    }\n    static sideOfPt2D(line, pt) {\n        return (line[1][0] - line[0][0]) * (pt[1] - line[0][1]) - (pt[0] - line[0][0]) * (line[1][1] - line[0][1]);\n    }\n    static collinear(p1, p2, p3, threshold = 0.01) {\n        let a = new Pt(0, 0, 0).to(p1).$subtract(p2);\n        let b = new Pt(0, 0, 0).to(p1).$subtract(p3);\n        return a.$cross(b).divide(1000).equals(new Pt(0, 0, 0), threshold);\n    }\n    static magnitude(line) {\n        return (line.length >= 2) ? line[1].$subtract(line[0]).magnitude() : 0;\n    }\n    static magnitudeSq(line) {\n        return (line.length >= 2) ? line[1].$subtract(line[0]).magnitudeSq() : 0;\n    }\n    static perpendicularFromPt(line, pt, asProjection = false) {\n        if (line[0].equals(line[1]))\n            return undefined;\n        let a = line[0].$subtract(line[1]);\n        let b = line[1].$subtract(pt);\n        let proj = b.$subtract(a.$project(b));\n        return (asProjection) ? proj : proj.$add(pt);\n    }\n    static distanceFromPt(line, pt) {\n        return Line.perpendicularFromPt(line, pt, true).magnitude();\n    }\n    static intersectRay2D(la, lb) {\n        let a = Line.intercept(la[0], la[1]);\n        let b = Line.intercept(lb[0], lb[1]);\n        let pa = la[0];\n        let pb = lb[0];\n        if (a == undefined) {\n            if (b == undefined)\n                return undefined;\n            let y1 = -b.slope * (pb[0] - pa[0]) + pb[1];\n            return new Pt(pa[0], y1);\n        }\n        else {\n            if (b == undefined) {\n                let y1 = -a.slope * (pa[0] - pb[0]) + pa[1];\n                return new Pt(pb[0], y1);\n            }\n            else if (b.slope != a.slope) {\n                let px = (a.slope * pa[0] - b.slope * pb[0] + pb[1] - pa[1]) / (a.slope - b.slope);\n                let py = a.slope * (px - pa[0]) + pa[1];\n                return new Pt(px, py);\n            }\n            else {\n                if (a.yi == b.yi) {\n                    return new Pt(pa[0], pa[1]);\n                }\n                else {\n                    return undefined;\n                }\n            }\n        }\n    }\n    static intersectLine2D(la, lb) {\n        let pt = Line.intersectRay2D(la, lb);\n        return (pt && Geom.withinBound(pt, la[0], la[1]) && Geom.withinBound(pt, lb[0], lb[1])) ? pt : undefined;\n    }\n    static intersectLineWithRay2D(line, ray) {\n        let pt = Line.intersectRay2D(line, ray);\n        return (pt && Geom.withinBound(pt, line[0], line[1])) ? pt : undefined;\n    }\n    static intersectPolygon2D(lineOrRay, poly, sourceIsRay = false) {\n        let fn = sourceIsRay ? Line.intersectLineWithRay2D : Line.intersectLine2D;\n        let pts = new Group();\n        for (let i = 0, len = poly.length; i < len; i++) {\n            let next = (i === len - 1) ? 0 : i + 1;\n            let d = fn([poly[i], poly[next]], lineOrRay);\n            if (d)\n                pts.push(d);\n        }\n        return (pts.length > 0) ? pts : undefined;\n    }\n    static intersectLines2D(lines1, lines2, isRay = false) {\n        let group = new Group();\n        let fn = isRay ? Line.intersectLineWithRay2D : Line.intersectLine2D;\n        for (let i = 0, len = lines1.length; i < len; i++) {\n            for (let k = 0, lenk = lines2.length; k < lenk; k++) {\n                let _ip = fn(lines1[i], lines2[k]);\n                if (_ip)\n                    group.push(_ip);\n            }\n        }\n        return group;\n    }\n    static intersectGridWithRay2D(ray, gridPt) {\n        let t = Line.intercept(new Pt(ray[0]).subtract(gridPt), new Pt(ray[1]).subtract(gridPt));\n        let g = new Group();\n        if (t && t.xi)\n            g.push(new Pt(gridPt[0] + t.xi, gridPt[1]));\n        if (t && t.yi)\n            g.push(new Pt(gridPt[0], gridPt[1] + t.yi));\n        return g;\n    }\n    static intersectGridWithLine2D(line, gridPt) {\n        let g = Line.intersectGridWithRay2D(line, gridPt);\n        let gg = new Group();\n        for (let i = 0, len = g.length; i < len; i++) {\n            if (Geom.withinBound(g[i], line[0], line[1]))\n                gg.push(g[i]);\n        }\n        return gg;\n    }\n    static intersectRect2D(line, rect) {\n        let box = Geom.boundingBox(Group.fromPtArray(line));\n        if (!Rectangle.hasIntersectRect2D(box, rect))\n            return new Group();\n        return Line.intersectLines2D([line], Rectangle.sides(rect));\n    }\n    static subpoints(line, num) {\n        let pts = new Group();\n        for (let i = 1; i <= num; i++) {\n            pts.push(Geom.interpolate(line[0], line[1], i / (num + 1)));\n        }\n        return pts;\n    }\n    static crop(line, size, index = 0, cropAsCircle = true) {\n        let tdx = (index === 0) ? 1 : 0;\n        let ls = line[tdx].$subtract(line[index]);\n        if (ls[0] === 0 || size[0] === 0)\n            return line[index];\n        if (cropAsCircle) {\n            let d = ls.unit().multiply(size[1]);\n            return line[index].$add(d);\n        }\n        else {\n            let rect = Rectangle.fromCenter(line[index], size);\n            let sides = Rectangle.sides(rect);\n            let sideIdx = 0;\n            if (Math.abs(ls[1] / ls[0]) > Math.abs(size[1] / size[0])) {\n                sideIdx = (ls[1] < 0) ? 0 : 2;\n            }\n            else {\n                sideIdx = (ls[0] < 0) ? 3 : 1;\n            }\n            return Line.intersectRay2D(sides[sideIdx], line);\n        }\n    }\n    static marker(line, size, graphic = (\"arrow\" || \"line\"), atTail = true) {\n        let h = atTail ? 0 : 1;\n        let t = atTail ? 1 : 0;\n        let unit = line[h].$subtract(line[t]);\n        if (unit.magnitudeSq() === 0)\n            return new Group();\n        unit.unit();\n        let ps = Geom.perpendicular(unit).multiply(size[0]).add(line[t]);\n        if (graphic == \"arrow\") {\n            ps.add(unit.$multiply(size[1]));\n            return new Group(line[t], ps[0], ps[1]);\n        }\n        else {\n            return new Group(ps[0], ps[1]);\n        }\n    }\n    static toRect(line) {\n        return new Group(line[0].$min(line[1]), line[0].$max(line[1]));\n    }\n}\nexport class Rectangle {\n    static from(topLeft, widthOrSize, height) {\n        return Rectangle.fromTopLeft(topLeft, widthOrSize, height);\n    }\n    static fromTopLeft(topLeft, widthOrSize, height) {\n        let size = (typeof widthOrSize == \"number\") ? [widthOrSize, (height || widthOrSize)] : widthOrSize;\n        return new Group(new Pt(topLeft), new Pt(topLeft).add(size));\n    }\n    static fromCenter(center, widthOrSize, height) {\n        let half = (typeof widthOrSize == \"number\") ? [widthOrSize / 2, (height || widthOrSize) / 2] : new Pt(widthOrSize).divide(2);\n        return new Group(new Pt(center).subtract(half), new Pt(center).add(half));\n    }\n    static toCircle(pts, within = true) {\n        return Circle.fromRect(pts, within);\n    }\n    static toSquare(pts, enclose = false) {\n        let s = Rectangle.size(pts);\n        let m = (enclose) ? s.maxValue().value : s.minValue().value;\n        return Rectangle.fromCenter(Rectangle.center(pts), m, m);\n    }\n    static size(pts) {\n        return pts[0].$max(pts[1]).subtract(pts[0].$min(pts[1]));\n    }\n    static center(pts) {\n        let min = pts[0].$min(pts[1]);\n        let max = pts[0].$max(pts[1]);\n        return min.add(max.$subtract(min).divide(2));\n    }\n    static corners(rect) {\n        let p0 = rect[0].$min(rect[1]);\n        let p2 = rect[0].$max(rect[1]);\n        return new Group(p0, new Pt(p2.x, p0.y), p2, new Pt(p0.x, p2.y));\n    }\n    static sides(rect) {\n        let [p0, p1, p2, p3] = Rectangle.corners(rect);\n        return [\n            new Group(p0, p1), new Group(p1, p2),\n            new Group(p2, p3), new Group(p3, p0)\n        ];\n    }\n    static boundingBox(rects) {\n        let merged = Util.flatten(rects, false);\n        let min = Pt.make(2, Number.MAX_VALUE);\n        let max = Pt.make(2, Number.MIN_VALUE);\n        for (let i = 0, len = merged.length; i < len; i++) {\n            for (let k = 0; k < 2; k++) {\n                min[k] = Math.min(min[k], merged[i][k]);\n                max[k] = Math.max(max[k], merged[i][k]);\n            }\n        }\n        return new Group(min, max);\n    }\n    static polygon(rect) {\n        return Rectangle.corners(rect);\n    }\n    static quadrants(rect, center) {\n        let corners = Rectangle.corners(rect);\n        let _center = (center != undefined) ? new Pt(center) : Rectangle.center(rect);\n        return corners.map((c) => new Group(c, _center).boundingBox());\n    }\n    static halves(rect, ratio = 0.5, asRows = false) {\n        let min = rect[0].$min(rect[1]);\n        let max = rect[0].$max(rect[1]);\n        let mid = (asRows) ? Num.lerp(min[1], max[1], ratio) : Num.lerp(min[0], max[0], ratio);\n        return (asRows)\n            ? [new Group(min, new Pt(max[0], mid)), new Group(new Pt(min[0], mid), max)]\n            : [new Group(min, new Pt(mid, max[1])), new Group(new Pt(mid, min[1]), max)];\n    }\n    static withinBound(rect, pt) {\n        return Geom.withinBound(pt, rect[0], rect[1]);\n    }\n    static hasIntersectRect2D(rect1, rect2, resetBoundingBox = false) {\n        if (resetBoundingBox) {\n            rect1 = Geom.boundingBox(rect1);\n            rect2 = Geom.boundingBox(rect2);\n        }\n        if (rect1[0][0] > rect2[1][0] || rect2[0][0] > rect1[1][0])\n            return false;\n        if (rect1[0][1] > rect2[1][1] || rect2[0][1] > rect1[1][1])\n            return false;\n        return true;\n    }\n    static intersectRect2D(rect1, rect2) {\n        if (!Rectangle.hasIntersectRect2D(rect1, rect2))\n            return new Group();\n        return Line.intersectLines2D(Rectangle.sides(rect1), Rectangle.sides(rect2));\n    }\n}\nexport class Circle {\n    static fromRect(pts, enclose = false) {\n        let r = 0;\n        let min = r = Rectangle.size(pts).minValue().value / 2;\n        if (enclose) {\n            let max = Rectangle.size(pts).maxValue().value / 2;\n            r = Math.sqrt(min * min + max * max);\n        }\n        else {\n            r = min;\n        }\n        return new Group(Rectangle.center(pts), new Pt(r, r));\n    }\n    static fromTriangle(pts, enclose = false) {\n        if (enclose) {\n            return Triangle.circumcircle(pts);\n        }\n        else {\n            return Triangle.incircle(pts);\n        }\n    }\n    static fromCenter(pt, radius) {\n        return new Group(new Pt(pt), new Pt(radius, radius));\n    }\n    static withinBound(pts, pt, threshold = 0) {\n        let d = pts[0].$subtract(pt);\n        return d.dot(d) + threshold < pts[1].x * pts[1].x;\n    }\n    static intersectRay2D(pts, ray) {\n        let d = ray[0].$subtract(ray[1]);\n        let f = pts[0].$subtract(ray[0]);\n        let a = d.dot(d);\n        let b = f.dot(d);\n        let c = f.dot(f) - pts[1].x * pts[1].x;\n        let p = b / a;\n        let q = c / a;\n        let disc = p * p - q;\n        if (disc < 0) {\n            return new Group();\n        }\n        else {\n            let discSqrt = Math.sqrt(disc);\n            let t1 = -p + discSqrt;\n            let p1 = ray[0].$subtract(d.$multiply(t1));\n            if (disc === 0)\n                return new Group(p1);\n            let t2 = -p - discSqrt;\n            let p2 = ray[0].$subtract(d.$multiply(t2));\n            return new Group(p1, p2);\n        }\n    }\n    static intersectLine2D(pts, line) {\n        let ps = Circle.intersectRay2D(pts, line);\n        let g = new Group();\n        if (ps.length > 0) {\n            for (let i = 0, len = ps.length; i < len; i++) {\n                if (Rectangle.withinBound(line, ps[i]))\n                    g.push(ps[i]);\n            }\n        }\n        return g;\n    }\n    static intersectCircle2D(pts, circle) {\n        let dv = circle[0].$subtract(pts[0]);\n        let dr2 = dv.magnitudeSq();\n        let dr = Math.sqrt(dr2);\n        let ar = pts[1].x;\n        let br = circle[1].x;\n        let ar2 = ar * ar;\n        let br2 = br * br;\n        if (dr > ar + br) {\n            return new Group();\n        }\n        else if (dr < Math.abs(ar - br)) {\n            return new Group(pts[0].clone());\n        }\n        else {\n            let a = (ar2 - br2 + dr2) / (2 * dr);\n            let h = Math.sqrt(ar2 - a * a);\n            let p = dv.$multiply(a / dr).add(pts[0]);\n            return new Group(new Pt(p.x + h * dv.y / dr, p.y - h * dv.x / dr), new Pt(p.x - h * dv.y / dr, p.y + h * dv.x / dr));\n        }\n    }\n    static intersectRect2D(pts, rect) {\n        let sides = Rectangle.sides(rect);\n        let g = [];\n        for (let i = 0, len = sides.length; i < len; i++) {\n            let ps = Circle.intersectLine2D(pts, sides[i]);\n            if (ps.length > 0)\n                g.push(ps);\n        }\n        return Util.flatten(g);\n    }\n    static toRect(pts, within = false) {\n        let r = pts[1][0];\n        if (within) {\n            let half = Math.sqrt(r * r) / 2;\n            return new Group(pts[0].$subtract(half), pts[0].$add(half));\n        }\n        else {\n            return new Group(pts[0].$subtract(r), pts[0].$add(r));\n        }\n    }\n    static toTriangle(pts, within = true) {\n        if (within) {\n            let ang = -Math.PI / 2;\n            let inc = Math.PI * 2 / 3;\n            let g = new Group();\n            for (let i = 0; i < 3; i++) {\n                g.push(pts[0].clone().toAngle(ang, pts[1][0], true));\n                ang += inc;\n            }\n            return g;\n        }\n        else {\n            return Triangle.fromCenter(pts[0], pts[1][0]);\n        }\n    }\n}\nexport class Triangle {\n    static fromRect(rect) {\n        let top = rect[0].$add(rect[1]).divide(2);\n        top.y = rect[0][1];\n        let left = rect[1].clone();\n        left.x = rect[0][0];\n        return new Group(top, rect[1].clone(), left);\n    }\n    static fromCircle(circle) {\n        return Circle.toTriangle(circle, true);\n    }\n    static fromCenter(pt, size) {\n        return Triangle.fromCircle(Circle.fromCenter(pt, size));\n    }\n    static medial(pts) {\n        if (pts.length < 3)\n            return _errorLength(new Group(), 3);\n        return Polygon.midpoints(pts, true);\n    }\n    static oppositeSide(pts, index) {\n        if (pts.length < 3)\n            return _errorLength(new Group(), 3);\n        if (index === 0) {\n            return Group.fromPtArray([pts[1], pts[2]]);\n        }\n        else if (index === 1) {\n            return Group.fromPtArray([pts[0], pts[2]]);\n        }\n        else {\n            return Group.fromPtArray([pts[0], pts[1]]);\n        }\n    }\n    static altitude(pts, index) {\n        let opp = Triangle.oppositeSide(pts, index);\n        if (opp.length > 1) {\n            return new Group(pts[index], Line.perpendicularFromPt(opp, pts[index]));\n        }\n        else {\n            return new Group();\n        }\n    }\n    static orthocenter(pts) {\n        if (pts.length < 3)\n            return _errorLength(undefined, 3);\n        let a = Triangle.altitude(pts, 0);\n        let b = Triangle.altitude(pts, 1);\n        return Line.intersectRay2D(a, b);\n    }\n    static incenter(pts) {\n        if (pts.length < 3)\n            return _errorLength(undefined, 3);\n        let a = Polygon.bisector(pts, 0).add(pts[0]);\n        let b = Polygon.bisector(pts, 1).add(pts[1]);\n        return Line.intersectRay2D(new Group(pts[0], a), new Group(pts[1], b));\n    }\n    static incircle(pts, center) {\n        let c = (center) ? center : Triangle.incenter(pts);\n        let area = Polygon.area(pts);\n        let perim = Polygon.perimeter(pts, true);\n        let r = 2 * area / perim.total;\n        return Circle.fromCenter(c, r);\n    }\n    static circumcenter(pts) {\n        let md = Triangle.medial(pts);\n        let a = [md[0], Geom.perpendicular(pts[0].$subtract(md[0])).p1.$add(md[0])];\n        let b = [md[1], Geom.perpendicular(pts[1].$subtract(md[1])).p1.$add(md[1])];\n        return Line.intersectRay2D(a, b);\n    }\n    static circumcircle(pts, center) {\n        let c = (center) ? center : Triangle.circumcenter(pts);\n        let r = pts[0].$subtract(c).magnitude();\n        return Circle.fromCenter(c, r);\n    }\n}\nexport class Polygon {\n    static centroid(pts) {\n        return Geom.centroid(pts);\n    }\n    static rectangle(center, widthOrSize, height) {\n        return Rectangle.corners(Rectangle.fromCenter(center, widthOrSize, height));\n    }\n    static fromCenter(center, radius, sides) {\n        let g = new Group();\n        for (let i = 0; i < sides; i++) {\n            let ang = Math.PI * 2 * i / sides;\n            g.push(new Pt(Math.cos(ang) * radius, Math.sin(ang) * radius).add(center));\n        }\n        return g;\n    }\n    static lineAt(pts, idx) {\n        if (idx < 0 || idx >= pts.length)\n            throw new Error(\"index out of the Polygon's range\");\n        return new Group(pts[idx], (idx === pts.length - 1) ? pts[0] : pts[idx + 1]);\n    }\n    static lines(pts, closePath = true) {\n        if (pts.length < 2)\n            return _errorLength(new Group(), 2);\n        let sp = Util.split(pts, 2, 1);\n        if (closePath)\n            sp.push(new Group(pts[pts.length - 1], pts[0]));\n        return sp.map((g) => g);\n    }\n    static midpoints(pts, closePath = false, t = 0.5) {\n        if (pts.length < 2)\n            return _errorLength(new Group(), 2);\n        let sides = Polygon.lines(pts, closePath);\n        let mids = sides.map((s) => Geom.interpolate(s[0], s[1], t));\n        return mids;\n    }\n    static adjacentSides(pts, index, closePath = false) {\n        if (pts.length < 2)\n            return _errorLength(new Group(), 2);\n        if (index < 0 || index >= pts.length)\n            return _errorOutofBound(new Group(), index);\n        let gs = [];\n        let left = index - 1;\n        if (closePath && left < 0)\n            left = pts.length - 1;\n        if (left >= 0)\n            gs.push(new Group(pts[index], pts[left]));\n        let right = index + 1;\n        if (closePath && right > pts.length - 1)\n            right = 0;\n        if (right <= pts.length - 1)\n            gs.push(new Group(pts[index], pts[right]));\n        return gs;\n    }\n    static bisector(pts, index) {\n        let sides = Polygon.adjacentSides(pts, index, true);\n        if (sides.length >= 2) {\n            let a = sides[0][1].$subtract(sides[0][0]).unit();\n            let b = sides[1][1].$subtract(sides[1][0]).unit();\n            return a.add(b).divide(2);\n        }\n        else {\n            return undefined;\n        }\n    }\n    static perimeter(pts, closePath = false) {\n        if (pts.length < 2)\n            return _errorLength(new Group(), 2);\n        let lines = Polygon.lines(pts, closePath);\n        let mag = 0;\n        let p = Pt.make(lines.length, 0);\n        for (let i = 0, len = lines.length; i < len; i++) {\n            let m = Line.magnitude(lines[i]);\n            mag += m;\n            p[i] = m;\n        }\n        return {\n            total: mag,\n            segments: p\n        };\n    }\n    static area(pts) {\n        if (pts.length < 3)\n            return _errorLength(new Group(), 3);\n        let det = (a, b) => a[0] * b[1] - a[1] * b[0];\n        let area = 0;\n        for (let i = 0, len = pts.length; i < len; i++) {\n            if (i < pts.length - 1) {\n                area += det(pts[i], pts[i + 1]);\n            }\n            else {\n                area += det(pts[i], pts[0]);\n            }\n        }\n        return Math.abs(area / 2);\n    }\n    static convexHull(pts, sorted = false) {\n        if (pts.length < 3)\n            return _errorLength(new Group(), 3);\n        if (!sorted) {\n            pts = pts.slice();\n            pts.sort((a, b) => a[0] - b[0]);\n        }\n        let left = (a, b, c) => {\n            return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]) > 0;\n        };\n        let dq = [];\n        let bot = pts.length - 2;\n        let top = bot + 3;\n        dq[bot] = pts[2];\n        dq[top] = pts[2];\n        if (left(pts[0], pts[1], pts[2])) {\n            dq[bot + 1] = pts[0];\n            dq[bot + 2] = pts[1];\n        }\n        else {\n            dq[bot + 1] = pts[1];\n            dq[bot + 2] = pts[0];\n        }\n        for (let i = 3, len = pts.length; i < len; i++) {\n            let pt = pts[i];\n            if (left(dq[bot], dq[bot + 1], pt) && left(dq[top - 1], dq[top], pt)) {\n                continue;\n            }\n            while (!left(dq[bot], dq[bot + 1], pt)) {\n                bot += 1;\n            }\n            bot -= 1;\n            dq[bot] = pt;\n            while (!left(dq[top - 1], dq[top], pt)) {\n                top -= 1;\n            }\n            top += 1;\n            dq[top] = pt;\n        }\n        let hull = new Group();\n        for (let h = 0; h < (top - bot); h++) {\n            hull.push(dq[bot + h]);\n        }\n        return hull;\n    }\n    static network(pts, originIndex = 0) {\n        let g = [];\n        for (let i = 0, len = pts.length; i < len; i++) {\n            if (i != originIndex)\n                g.push(new Group(pts[originIndex], pts[i]));\n        }\n        return g;\n    }\n    static nearestPt(pts, pt) {\n        let _near = Number.MAX_VALUE;\n        let _item = -1;\n        for (let i = 0, len = pts.length; i < len; i++) {\n            let d = pts[i].$subtract(pt).magnitudeSq();\n            if (d < _near) {\n                _near = d;\n                _item = i;\n            }\n        }\n        return _item;\n    }\n    static projectAxis(poly, unitAxis) {\n        let dot = unitAxis.dot(poly[0]);\n        let d = new Pt(dot, dot);\n        for (let n = 1, len = poly.length; n < len; n++) {\n            dot = unitAxis.dot(poly[n]);\n            d = new Pt(Math.min(dot, d[0]), Math.max(dot, d[1]));\n        }\n        return d;\n    }\n    static _axisOverlap(poly1, poly2, unitAxis) {\n        let pa = Polygon.projectAxis(poly1, unitAxis);\n        let pb = Polygon.projectAxis(poly2, unitAxis);\n        return (pa[0] < pb[0]) ? pb[0] - pa[1] : pa[0] - pb[1];\n    }\n    static hasIntersectPoint(poly, pt) {\n        let c = false;\n        for (let i = 0, len = poly.length; i < len; i++) {\n            let ln = Polygon.lineAt(poly, i);\n            if (((ln[0][1] > pt[1]) != (ln[1][1] > pt[1])) &&\n                (pt[0] < (ln[1][0] - ln[0][0]) * (pt[1] - ln[0][1]) / (ln[1][1] - ln[0][1]) + ln[0][0])) {\n                c = !c;\n            }\n        }\n        return c;\n    }\n    static hasIntersectCircle(poly, circle) {\n        let info = {\n            which: -1,\n            dist: 0,\n            normal: null,\n            edge: null,\n            vertex: null,\n        };\n        let c = circle[0];\n        let r = circle[1][0];\n        let minDist = Number.MAX_SAFE_INTEGER;\n        for (let i = 0, len = poly.length; i < len; i++) {\n            let edge = Polygon.lineAt(poly, i);\n            let axis = new Pt(edge[0].y - edge[1].y, edge[1].x - edge[0].x).unit();\n            let poly2 = new Group(c.$add(axis.$multiply(r)), c.$subtract(axis.$multiply(r)));\n            let dist = Polygon._axisOverlap(poly, poly2, axis);\n            if (dist > 0) {\n                return null;\n            }\n            else if (Math.abs(dist) < minDist) {\n                let check = Rectangle.withinBound(edge, Line.perpendicularFromPt(edge, c)) || Circle.intersectLine2D(circle, edge).length > 0;\n                if (check) {\n                    info.edge = edge;\n                    info.normal = axis;\n                    minDist = Math.abs(dist);\n                    info.which = i;\n                }\n            }\n        }\n        if (!info.edge)\n            return null;\n        let dir = c.$subtract(Polygon.centroid(poly)).dot(info.normal);\n        if (dir < 0)\n            info.normal.multiply(-1);\n        info.dist = minDist;\n        info.vertex = c;\n        return info;\n    }\n    static hasIntersectPolygon(poly1, poly2) {\n        let info = {\n            which: -1,\n            dist: 0,\n            normal: new Pt(),\n            edge: new Group(),\n            vertex: new Pt()\n        };\n        let minDist = Number.MAX_SAFE_INTEGER;\n        for (let i = 0, plen = (poly1.length + poly2.length); i < plen; i++) {\n            let edge = (i < poly1.length) ? Polygon.lineAt(poly1, i) : Polygon.lineAt(poly2, i - poly1.length);\n            let axis = new Pt(edge[0].y - edge[1].y, edge[1].x - edge[0].x).unit();\n            let dist = Polygon._axisOverlap(poly1, poly2, axis);\n            if (dist > 0) {\n                return null;\n            }\n            else if (Math.abs(dist) < minDist) {\n                info.edge = edge;\n                info.normal = axis;\n                minDist = Math.abs(dist);\n                info.which = (i < poly1.length) ? 0 : 1;\n            }\n        }\n        info.dist = minDist;\n        let b1 = (info.which === 0) ? poly2 : poly1;\n        let b2 = (info.which === 0) ? poly1 : poly2;\n        let c1 = Polygon.centroid(b1);\n        let c2 = Polygon.centroid(b2);\n        let dir = c1.$subtract(c2).dot(info.normal);\n        if (dir < 0)\n            info.normal.multiply(-1);\n        let smallest = Number.MAX_SAFE_INTEGER;\n        for (let i = 0, len = b1.length; i < len; i++) {\n            let d = info.normal.dot(b1[i].$subtract(c2));\n            if (d < smallest) {\n                smallest = d;\n                info.vertex = b1[i];\n            }\n        }\n        return info;\n    }\n    static intersectPolygon2D(poly1, poly2) {\n        let lp = Polygon.lines(poly1);\n        let g = [];\n        for (let i = 0, len = lp.length; i < len; i++) {\n            let ins = Line.intersectPolygon2D(lp[i], poly2, false);\n            if (ins)\n                g.push(ins);\n        }\n        return Util.flatten(g, true);\n    }\n    static toRects(polys) {\n        let boxes = polys.map((g) => Geom.boundingBox(g));\n        let merged = Util.flatten(boxes, false);\n        boxes.unshift(Geom.boundingBox(merged));\n        return boxes;\n    }\n}\nexport class Curve {\n    static getSteps(steps) {\n        let ts = new Group();\n        for (let i = 0; i <= steps; i++) {\n            let t = i / steps;\n            ts.push(new Pt(t * t * t, t * t, t, 1));\n        }\n        return ts;\n    }\n    static controlPoints(pts, index = 0, copyStart = false) {\n        if (index > pts.length - 1)\n            return new Group();\n        let _index = (i) => (i < pts.length - 1) ? i : pts.length - 1;\n        let p0 = pts[index];\n        index = (copyStart) ? index : index + 1;\n        return new Group(p0, pts[_index(index++)], pts[_index(index++)], pts[_index(index++)]);\n    }\n    static _calcPt(ctrls, params) {\n        let x = ctrls.reduce((a, c, i) => a + c.x * params[i], 0);\n        let y = ctrls.reduce((a, c, i) => a + c.y * params[i], 0);\n        if (ctrls[0].length > 2) {\n            let z = ctrls.reduce((a, c, i) => a + c.z * params[i], 0);\n            return new Pt(x, y, z);\n        }\n        return new Pt(x, y);\n    }\n    static catmullRom(pts, steps = 10) {\n        if (pts.length < 2)\n            return new Group();\n        let ps = new Group();\n        let ts = Curve.getSteps(steps);\n        let c = Curve.controlPoints(pts, 0, true);\n        for (let i = 0; i <= steps; i++) {\n            ps.push(Curve.catmullRomStep(ts[i], c));\n        }\n        let k = 0;\n        while (k < pts.length - 2) {\n            let cp = Curve.controlPoints(pts, k);\n            if (cp.length > 0) {\n                for (let i = 0; i <= steps; i++) {\n                    ps.push(Curve.catmullRomStep(ts[i], cp));\n                }\n                k++;\n            }\n        }\n        return ps;\n    }\n    static catmullRomStep(step, ctrls) {\n        let m = new Group(new Pt(-0.5, 1, -0.5, 0), new Pt(1.5, -2.5, 0, 1), new Pt(-1.5, 2, 0.5, 0), new Pt(0.5, -0.5, 0, 0));\n        return Curve._calcPt(ctrls, Mat.multiply([step], m, true)[0]);\n    }\n    static cardinal(pts, steps = 10, tension = 0.5) {\n        if (pts.length < 2)\n            return new Group();\n        let ps = new Group();\n        let ts = Curve.getSteps(steps);\n        let c = Curve.controlPoints(pts, 0, true);\n        for (let i = 0; i <= steps; i++) {\n            ps.push(Curve.cardinalStep(ts[i], c, tension));\n        }\n        let k = 0;\n        while (k < pts.length - 2) {\n            let cp = Curve.controlPoints(pts, k);\n            if (cp.length > 0) {\n                for (let i = 0; i <= steps; i++) {\n                    ps.push(Curve.cardinalStep(ts[i], cp, tension));\n                }\n                k++;\n            }\n        }\n        return ps;\n    }\n    static cardinalStep(step, ctrls, tension = 0.5) {\n        let m = new Group(new Pt(-1, 2, -1, 0), new Pt(-1, 1, 0, 0), new Pt(1, -2, 1, 0), new Pt(1, -1, 0, 0));\n        let h = Mat.multiply([step], m, true)[0].multiply(tension);\n        let h2 = (2 * step[0] - 3 * step[1] + 1);\n        let h3 = -2 * step[0] + 3 * step[1];\n        let pt = Curve._calcPt(ctrls, h);\n        pt.x += h2 * ctrls[1].x + h3 * ctrls[2].x;\n        pt.y += h2 * ctrls[1].y + h3 * ctrls[2].y;\n        if (pt.length > 2)\n            pt.z += h2 * ctrls[1].z + h3 * ctrls[2].z;\n        return pt;\n    }\n    static bezier(pts, steps = 10) {\n        if (pts.length < 4)\n            return new Group();\n        let ps = new Group();\n        let ts = Curve.getSteps(steps);\n        let k = 0;\n        while (k < pts.length - 3) {\n            let c = Curve.controlPoints(pts, k);\n            if (c.length > 0) {\n                for (let i = 0; i <= steps; i++) {\n                    ps.push(Curve.bezierStep(ts[i], c));\n                }\n                k += 3;\n            }\n        }\n        return ps;\n    }\n    static bezierStep(step, ctrls) {\n        let m = new Group(new Pt(-1, 3, -3, 1), new Pt(3, -6, 3, 0), new Pt(-3, 3, 0, 0), new Pt(1, 0, 0, 0));\n        return Curve._calcPt(ctrls, Mat.multiply([step], m, true)[0]);\n    }\n    static bspline(pts, steps = 10, tension = 1) {\n        if (pts.length < 2)\n            return new Group();\n        let ps = new Group();\n        let ts = Curve.getSteps(steps);\n        let k = 0;\n        while (k < pts.length - 3) {\n            let c = Curve.controlPoints(pts, k);\n            if (c.length > 0) {\n                if (tension !== 1) {\n                    for (let i = 0; i <= steps; i++) {\n                        ps.push(Curve.bsplineTensionStep(ts[i], c, tension));\n                    }\n                }\n                else {\n                    for (let i = 0; i <= steps; i++) {\n                        ps.push(Curve.bsplineStep(ts[i], c));\n                    }\n                }\n                k++;\n            }\n        }\n        return ps;\n    }\n    static bsplineStep(step, ctrls) {\n        let m = new Group(new Pt(-0.16666666666666666, 0.5, -0.5, 0.16666666666666666), new Pt(0.5, -1, 0, 0.6666666666666666), new Pt(-0.5, 0.5, 0.5, 0.16666666666666666), new Pt(0.16666666666666666, 0, 0, 0));\n        return Curve._calcPt(ctrls, Mat.multiply([step], m, true)[0]);\n    }\n    static bsplineTensionStep(step, ctrls, tension = 1) {\n        let m = new Group(new Pt(-0.16666666666666666, 0.5, -0.5, 0.16666666666666666), new Pt(-1.5, 2, 0, -0.3333333333333333), new Pt(1.5, -2.5, 0.5, 0.16666666666666666), new Pt(0.16666666666666666, 0, 0, 0));\n        let h = Mat.multiply([step], m, true)[0].multiply(tension);\n        let h2 = (2 * step[0] - 3 * step[1] + 1);\n        let h3 = -2 * step[0] + 3 * step[1];\n        let pt = Curve._calcPt(ctrls, h);\n        pt.x += h2 * ctrls[1].x + h3 * ctrls[2].x;\n        pt.y += h2 * ctrls[1].y + h3 * ctrls[2].y;\n        if (pt.length > 2)\n            pt.z += h2 * ctrls[1].z + h3 * ctrls[2].z;\n        return pt;\n    }\n}\n//# sourceMappingURL=Op.js.map"]},"metadata":{},"sourceType":"module"}