{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { TickSource } from \"./TickSource\";\nimport { assertContextRunning } from \"../util/Debug\";\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n * @example\n * import { Clock } from \"tone\";\n * // the callback will be invoked approximately once a second\n * // and will print the time exactly once a second apart.\n * const clock = new Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n * clock.start();\n * @category Core\n */\n\nvar Clock =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Clock, _super);\n\n  function Clock() {\n    var _this = _super.call(this, optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"])) || this;\n\n    _this.name = \"Clock\";\n    /**\n     * The callback function to invoke at the scheduled tick.\n     */\n\n    _this.callback = noOp;\n    /**\n     * The last time the loop callback was invoked\n     */\n\n    _this._lastUpdate = 0;\n    /**\n     * Keep track of the playback state\n     */\n\n    _this._state = new StateTimeline(\"stopped\");\n    /**\n     * Context bound reference to the _loop method\n     * This is necessary to remove the event in the end.\n     */\n\n    _this._boundLoop = _this._loop.bind(_this);\n    var options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n    _this.callback = options.callback;\n    _this._tickSource = new TickSource({\n      context: _this.context,\n      frequency: options.frequency,\n      units: options.units\n    });\n    _this._lastUpdate = 0;\n    _this.frequency = _this._tickSource.frequency;\n    readOnly(_this, \"frequency\"); // add an initial state\n\n    _this._state.setStateAtTime(\"stopped\", 0); // bind a callback to the worker thread\n\n\n    _this.context.on(\"tick\", _this._boundLoop);\n\n    return _this;\n  }\n\n  Clock.getDefaults = function () {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      callback: noOp,\n      frequency: 1,\n      units: \"hertz\"\n    });\n  };\n\n  Object.defineProperty(Clock.prototype, \"state\", {\n    /**\n     * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n     */\n    get: function () {\n      return this._state.getValueAtTime(this.now());\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Start the clock at the given time. Optionally pass in an offset\n   * of where to start the tick counter from.\n   * @param  time    The time the clock should start\n   * @param offset  Where the tick counter starts counting from.\n   */\n\n  Clock.prototype.start = function (time, offset) {\n    // make sure the context is running\n    assertContextRunning(this.context); // start the loop\n\n    var computedTime = this.toSeconds(time);\n    this.log(\"start\", computedTime);\n\n    if (this._state.getValueAtTime(computedTime) !== \"started\") {\n      this._state.setStateAtTime(\"started\", computedTime);\n\n      this._tickSource.start(computedTime, offset);\n\n      if (computedTime < this._lastUpdate) {\n        this.emit(\"start\", computedTime, offset);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Stop the clock. Stopping the clock resets the tick counter to 0.\n   * @param time The time when the clock should stop.\n   * @example\n   * import { Clock } from \"tone\";\n   * const clock = new Clock(time => {\n   * \tconsole.log(time);\n   * }, 1);\n   * clock.start();\n   * // stop the clock after 10 seconds\n   * clock.stop(\"+10\");\n   */\n\n\n  Clock.prototype.stop = function (time) {\n    var computedTime = this.toSeconds(time);\n    this.log(\"stop\", computedTime);\n\n    this._state.cancel(computedTime);\n\n    this._state.setStateAtTime(\"stopped\", computedTime);\n\n    this._tickSource.stop(computedTime);\n\n    if (computedTime < this._lastUpdate) {\n      this.emit(\"stop\", computedTime);\n    }\n\n    return this;\n  };\n  /**\n   * Pause the clock. Pausing does not reset the tick counter.\n   * @param time The time when the clock should stop.\n   */\n\n\n  Clock.prototype.pause = function (time) {\n    var computedTime = this.toSeconds(time);\n\n    if (this._state.getValueAtTime(computedTime) === \"started\") {\n      this._state.setStateAtTime(\"paused\", computedTime);\n\n      this._tickSource.pause(computedTime);\n\n      if (computedTime < this._lastUpdate) {\n        this.emit(\"pause\", computedTime);\n      }\n    }\n\n    return this;\n  };\n\n  Object.defineProperty(Clock.prototype, \"ticks\", {\n    /**\n     * The number of times the callback was invoked. Starts counting at 0\n     * and increments after the callback was invoked.\n     */\n    get: function () {\n      return Math.ceil(this.getTicksAtTime(this.now()));\n    },\n    set: function (t) {\n      this._tickSource.ticks = t;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Clock.prototype, \"seconds\", {\n    /**\n     * The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n     */\n    get: function () {\n      return this._tickSource.seconds;\n    },\n    set: function (s) {\n      this._tickSource.seconds = s;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Return the elapsed seconds at the given time.\n   * @param  time  When to get the elapsed seconds\n   * @return  The number of elapsed seconds\n   */\n\n  Clock.prototype.getSecondsAtTime = function (time) {\n    return this._tickSource.getSecondsAtTime(time);\n  };\n  /**\n   * Set the clock's ticks at the given time.\n   * @param  ticks The tick value to set\n   * @param  time  When to set the tick value\n   */\n\n\n  Clock.prototype.setTicksAtTime = function (ticks, time) {\n    this._tickSource.setTicksAtTime(ticks, time);\n\n    return this;\n  };\n  /**\n   * Get the time of the given tick. The second argument\n   * is when to test before. Since ticks can be set (with setTicksAtTime)\n   * there may be multiple times for a given tick value.\n   * @param  tick The tick number.\n   * @param  before When to measure the tick value from.\n   * @return The time of the tick\n   */\n\n\n  Clock.prototype.getTimeOfTick = function (tick, before) {\n    if (before === void 0) {\n      before = this.now();\n    }\n\n    return this._tickSource.getTimeOfTick(tick, before);\n  };\n  /**\n   * Get the clock's ticks at the given time.\n   * @param  time  When to get the tick value\n   * @return The tick value at the given time.\n   */\n\n\n  Clock.prototype.getTicksAtTime = function (time) {\n    return this._tickSource.getTicksAtTime(time);\n  };\n  /**\n   * Get the time of the next tick\n   * @param  offset The tick number.\n   */\n\n\n  Clock.prototype.nextTickTime = function (offset, when) {\n    var computedTime = this.toSeconds(when);\n    var currentTick = this.getTicksAtTime(computedTime);\n    return this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n  };\n  /**\n   * The scheduling loop.\n   */\n\n\n  Clock.prototype._loop = function () {\n    var _this = this;\n\n    var startTime = this._lastUpdate;\n    var endTime = this.now();\n    this._lastUpdate = endTime;\n    this.log(\"loop\", startTime, endTime);\n\n    if (startTime !== endTime) {\n      // the state change events\n      this._state.forEachBetween(startTime, endTime, function (e) {\n        switch (e.state) {\n          case \"started\":\n            var offset = _this._tickSource.getTicksAtTime(e.time);\n\n            _this.emit(\"start\", e.time, offset);\n\n            break;\n\n          case \"stopped\":\n            if (e.time !== 0) {\n              _this.emit(\"stop\", e.time);\n            }\n\n            break;\n\n          case \"paused\":\n            _this.emit(\"pause\", e.time);\n\n            break;\n        }\n      }); // the tick callbacks\n\n\n      this._tickSource.forEachTickBetween(startTime, endTime, function (time, ticks) {\n        _this.callback(time, ticks);\n      });\n    }\n  };\n  /**\n   * Returns the scheduled state at the given time.\n   * @param  time  The time to query.\n   * @return  The name of the state input in setStateAtTime.\n   * @example\n   * import { Clock } from \"tone\";\n   * const clock = new Clock();\n   * clock.start(\"+0.1\");\n   * clock.getStateAtTime(\"+0.1\"); // returns \"started\"\n   */\n\n\n  Clock.prototype.getStateAtTime = function (time) {\n    var computedTime = this.toSeconds(time);\n    return this._state.getValueAtTime(computedTime);\n  };\n  /**\n   * Clean up\n   */\n\n\n  Clock.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.context.off(\"tick\", this._boundLoop);\n\n    this._tickSource.dispose();\n\n    this._state.dispose();\n\n    return this;\n  };\n\n  return Clock;\n}(ToneWithContext);\n\nexport { Clock };\nEmitter.mixin(Clock);","map":{"version":3,"sources":["../../../../Tone/core/clock/Clock.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { TickSource } from \"./TickSource\";\nimport { assertContextRunning } from \"../util/Debug\";\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n * @example\n * import { Clock } from \"tone\";\n * // the callback will be invoked approximately once a second\n * // and will print the time exactly once a second apart.\n * const clock = new Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n * clock.start();\n * @category Core\n */\nvar Clock = /** @class */ (function (_super) {\n    tslib_1.__extends(Clock, _super);\n    function Clock() {\n        var _this = _super.call(this, optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"])) || this;\n        _this.name = \"Clock\";\n        /**\n         * The callback function to invoke at the scheduled tick.\n         */\n        _this.callback = noOp;\n        /**\n         * The last time the loop callback was invoked\n         */\n        _this._lastUpdate = 0;\n        /**\n         * Keep track of the playback state\n         */\n        _this._state = new StateTimeline(\"stopped\");\n        /**\n         * Context bound reference to the _loop method\n         * This is necessary to remove the event in the end.\n         */\n        _this._boundLoop = _this._loop.bind(_this);\n        var options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n        _this.callback = options.callback;\n        _this._tickSource = new TickSource({\n            context: _this.context,\n            frequency: options.frequency,\n            units: options.units,\n        });\n        _this._lastUpdate = 0;\n        _this.frequency = _this._tickSource.frequency;\n        readOnly(_this, \"frequency\");\n        // add an initial state\n        _this._state.setStateAtTime(\"stopped\", 0);\n        // bind a callback to the worker thread\n        _this.context.on(\"tick\", _this._boundLoop);\n        return _this;\n    }\n    Clock.getDefaults = function () {\n        return Object.assign(ToneWithContext.getDefaults(), {\n            callback: noOp,\n            frequency: 1,\n            units: \"hertz\",\n        });\n    };\n    Object.defineProperty(Clock.prototype, \"state\", {\n        /**\n         * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n         */\n        get: function () {\n            return this._state.getValueAtTime(this.now());\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Start the clock at the given time. Optionally pass in an offset\n     * of where to start the tick counter from.\n     * @param  time    The time the clock should start\n     * @param offset  Where the tick counter starts counting from.\n     */\n    Clock.prototype.start = function (time, offset) {\n        // make sure the context is running\n        assertContextRunning(this.context);\n        // start the loop\n        var computedTime = this.toSeconds(time);\n        this.log(\"start\", computedTime);\n        if (this._state.getValueAtTime(computedTime) !== \"started\") {\n            this._state.setStateAtTime(\"started\", computedTime);\n            this._tickSource.start(computedTime, offset);\n            if (computedTime < this._lastUpdate) {\n                this.emit(\"start\", computedTime, offset);\n            }\n        }\n        return this;\n    };\n    /**\n     * Stop the clock. Stopping the clock resets the tick counter to 0.\n     * @param time The time when the clock should stop.\n     * @example\n     * import { Clock } from \"tone\";\n     * const clock = new Clock(time => {\n     * \tconsole.log(time);\n     * }, 1);\n     * clock.start();\n     * // stop the clock after 10 seconds\n     * clock.stop(\"+10\");\n     */\n    Clock.prototype.stop = function (time) {\n        var computedTime = this.toSeconds(time);\n        this.log(\"stop\", computedTime);\n        this._state.cancel(computedTime);\n        this._state.setStateAtTime(\"stopped\", computedTime);\n        this._tickSource.stop(computedTime);\n        if (computedTime < this._lastUpdate) {\n            this.emit(\"stop\", computedTime);\n        }\n        return this;\n    };\n    /**\n     * Pause the clock. Pausing does not reset the tick counter.\n     * @param time The time when the clock should stop.\n     */\n    Clock.prototype.pause = function (time) {\n        var computedTime = this.toSeconds(time);\n        if (this._state.getValueAtTime(computedTime) === \"started\") {\n            this._state.setStateAtTime(\"paused\", computedTime);\n            this._tickSource.pause(computedTime);\n            if (computedTime < this._lastUpdate) {\n                this.emit(\"pause\", computedTime);\n            }\n        }\n        return this;\n    };\n    Object.defineProperty(Clock.prototype, \"ticks\", {\n        /**\n         * The number of times the callback was invoked. Starts counting at 0\n         * and increments after the callback was invoked.\n         */\n        get: function () {\n            return Math.ceil(this.getTicksAtTime(this.now()));\n        },\n        set: function (t) {\n            this._tickSource.ticks = t;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Clock.prototype, \"seconds\", {\n        /**\n         * The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n         */\n        get: function () {\n            return this._tickSource.seconds;\n        },\n        set: function (s) {\n            this._tickSource.seconds = s;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Return the elapsed seconds at the given time.\n     * @param  time  When to get the elapsed seconds\n     * @return  The number of elapsed seconds\n     */\n    Clock.prototype.getSecondsAtTime = function (time) {\n        return this._tickSource.getSecondsAtTime(time);\n    };\n    /**\n     * Set the clock's ticks at the given time.\n     * @param  ticks The tick value to set\n     * @param  time  When to set the tick value\n     */\n    Clock.prototype.setTicksAtTime = function (ticks, time) {\n        this._tickSource.setTicksAtTime(ticks, time);\n        return this;\n    };\n    /**\n     * Get the time of the given tick. The second argument\n     * is when to test before. Since ticks can be set (with setTicksAtTime)\n     * there may be multiple times for a given tick value.\n     * @param  tick The tick number.\n     * @param  before When to measure the tick value from.\n     * @return The time of the tick\n     */\n    Clock.prototype.getTimeOfTick = function (tick, before) {\n        if (before === void 0) { before = this.now(); }\n        return this._tickSource.getTimeOfTick(tick, before);\n    };\n    /**\n     * Get the clock's ticks at the given time.\n     * @param  time  When to get the tick value\n     * @return The tick value at the given time.\n     */\n    Clock.prototype.getTicksAtTime = function (time) {\n        return this._tickSource.getTicksAtTime(time);\n    };\n    /**\n     * Get the time of the next tick\n     * @param  offset The tick number.\n     */\n    Clock.prototype.nextTickTime = function (offset, when) {\n        var computedTime = this.toSeconds(when);\n        var currentTick = this.getTicksAtTime(computedTime);\n        return this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n    };\n    /**\n     * The scheduling loop.\n     */\n    Clock.prototype._loop = function () {\n        var _this = this;\n        var startTime = this._lastUpdate;\n        var endTime = this.now();\n        this._lastUpdate = endTime;\n        this.log(\"loop\", startTime, endTime);\n        if (startTime !== endTime) {\n            // the state change events\n            this._state.forEachBetween(startTime, endTime, function (e) {\n                switch (e.state) {\n                    case \"started\":\n                        var offset = _this._tickSource.getTicksAtTime(e.time);\n                        _this.emit(\"start\", e.time, offset);\n                        break;\n                    case \"stopped\":\n                        if (e.time !== 0) {\n                            _this.emit(\"stop\", e.time);\n                        }\n                        break;\n                    case \"paused\":\n                        _this.emit(\"pause\", e.time);\n                        break;\n                }\n            });\n            // the tick callbacks\n            this._tickSource.forEachTickBetween(startTime, endTime, function (time, ticks) {\n                _this.callback(time, ticks);\n            });\n        }\n    };\n    /**\n     * Returns the scheduled state at the given time.\n     * @param  time  The time to query.\n     * @return  The name of the state input in setStateAtTime.\n     * @example\n     * import { Clock } from \"tone\";\n     * const clock = new Clock();\n     * clock.start(\"+0.1\");\n     * clock.getStateAtTime(\"+0.1\"); // returns \"started\"\n     */\n    Clock.prototype.getStateAtTime = function (time) {\n        var computedTime = this.toSeconds(time);\n        return this._state.getValueAtTime(computedTime);\n    };\n    /**\n     * Clean up\n     */\n    Clock.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this.context.off(\"tick\", this._boundLoop);\n        this._tickSource.dispose();\n        this._state.dispose();\n        return this;\n    };\n    return Clock;\n}(ToneWithContext));\nexport { Clock };\nEmitter.mixin(Clock);\n//# sourceMappingURL=Clock.js.map"]},"metadata":{},"sourceType":"module"}