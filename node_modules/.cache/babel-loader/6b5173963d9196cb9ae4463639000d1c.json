{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Pt, Group } from \"./Pt\";\nimport { Num } from \"./Num\";\nexport class Tempo {\n  constructor(bpm) {\n    this._listeners = {};\n    this._listenerInc = 0;\n    this.bpm = bpm;\n  }\n\n  static fromBeat(ms) {\n    return new Tempo(60000 / ms);\n  }\n\n  get bpm() {\n    return this._bpm;\n  }\n\n  set bpm(n) {\n    this._bpm = n;\n    this._ms = 60000 / this._bpm;\n  }\n\n  get ms() {\n    return this._ms;\n  }\n\n  set ms(n) {\n    this._bpm = Math.floor(60000 / n);\n    this._ms = 60000 / this._bpm;\n  }\n\n  _createID(listener) {\n    let id = '';\n\n    if (typeof listener === 'function') {\n      id = '_b' + this._listenerInc++;\n    } else {\n      id = listener.name || '_b' + this._listenerInc++;\n    }\n\n    return id;\n  }\n\n  every(beats) {\n    let self = this;\n    let p = Array.isArray(beats) ? beats[0] : beats;\n    return {\n      start: function (fn, offset = 0, name) {\n        let id = name || self._createID(fn);\n\n        self._listeners[id] = {\n          name: id,\n          beats: beats,\n          period: p,\n          index: 0,\n          offset: offset,\n          duration: -1,\n          continuous: false,\n          fn: fn\n        };\n        return this;\n      },\n      progress: function (fn, offset = 0, name) {\n        let id = name || self._createID(fn);\n\n        self._listeners[id] = {\n          name: id,\n          beats: beats,\n          period: p,\n          index: 0,\n          offset: offset,\n          duration: -1,\n          continuous: true,\n          fn: fn\n        };\n        return this;\n      }\n    };\n  }\n\n  track(time) {\n    for (let k in this._listeners) {\n      if (this._listeners.hasOwnProperty(k)) {\n        let li = this._listeners[k];\n\n        let _t = li.offset ? time + li.offset : time;\n\n        let ms = li.period * this._ms;\n        let isStart = false;\n\n        if (_t > li.duration + ms) {\n          li.duration = _t - _t % this._ms;\n\n          if (Array.isArray(li.beats)) {\n            li.index = (li.index + 1) % li.beats.length;\n            li.period = li.beats[li.index];\n          }\n\n          isStart = true;\n        }\n\n        let count = Math.max(0, Math.ceil(Math.floor(li.duration / this._ms) / li.period));\n        let params = li.continuous ? [count, Num.clamp((_t - li.duration) / ms, 0, 1), _t, isStart] : [count];\n\n        if (li.continuous || isStart) {\n          let done = li.fn.apply(li, params);\n          if (done) delete this._listeners[li.name];\n        }\n      }\n    }\n  }\n\n  stop(name) {\n    if (this._listeners[name]) delete this._listeners[name];\n  }\n\n  animate(time, ftime) {\n    this.track(time);\n  }\n\n}\nexport class Sound {\n  constructor(type) {\n    this._playing = false;\n    this._type = type;\n\n    let _ctx = window.AudioContext || window.webkitAudioContext || false;\n\n    if (!_ctx) throw new Error(\"Your browser doesn't support Web Audio. (No AudioContext)\");\n    this._ctx = _ctx ? new _ctx() : undefined;\n  }\n\n  static from(node, ctx, type = \"gen\", stream) {\n    let s = new Sound(type);\n    s._node = node;\n    s._ctx = ctx;\n    if (stream) s._stream = stream;\n    return s;\n  }\n\n  static load(source, crossOrigin = \"anonymous\") {\n    return new Promise((resolve, reject) => {\n      let s = new Sound(\"file\");\n      s._source = typeof source === 'string' ? new Audio(source) : source;\n      s._source.autoplay = false;\n      s._source.crossOrigin = crossOrigin;\n\n      s._source.addEventListener(\"ended\", function () {\n        s._playing = false;\n      });\n\n      s._source.addEventListener('error', function () {\n        reject(\"Error loading sound\");\n      });\n\n      s._source.addEventListener('canplaythrough', function () {\n        s._node = s._ctx.createMediaElementSource(s._source);\n        resolve(s);\n      });\n    });\n  }\n\n  static loadAsBuffer(url) {\n    return new Promise((resolve, reject) => {\n      let request = new XMLHttpRequest();\n      request.open('GET', url, true);\n      request.responseType = 'arraybuffer';\n      let s = new Sound(\"file\");\n\n      request.onload = function () {\n        s._ctx.decodeAudioData(request.response, function (buffer) {\n          s.createBuffer(buffer);\n          resolve(s);\n        }, err => reject(\"Error decoding audio\"));\n      };\n\n      request.send();\n    });\n  }\n\n  createBuffer(buf) {\n    this._node = this._ctx.createBufferSource();\n    if (buf !== undefined) this._buffer = buf;\n    this._node.buffer = this._buffer;\n\n    this._node.onended = () => {\n      this._playing = false;\n    };\n\n    return this;\n  }\n\n  static generate(type, val) {\n    let s = new Sound(\"gen\");\n    return s._gen(type, val);\n  }\n\n  _gen(type, val) {\n    this._node = this._ctx.createOscillator();\n    let osc = this._node;\n    osc.type = type;\n\n    if (type === 'custom') {\n      osc.setPeriodicWave(val);\n    } else {\n      osc.frequency.value = val;\n    }\n\n    return this;\n  }\n\n  static input(constraint) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        let s = new Sound(\"input\");\n        if (!s) return undefined;\n        const c = constraint ? constraint : {\n          audio: true,\n          video: false\n        };\n        s._stream = yield navigator.mediaDevices.getUserMedia(c);\n        s._node = s._ctx.createMediaStreamSource(s._stream);\n        return s;\n      } catch (e) {\n        console.error(\"Cannot get audio from input device.\");\n        return Promise.resolve(null);\n      }\n    });\n  }\n\n  get ctx() {\n    return this._ctx;\n  }\n\n  get node() {\n    return this._node;\n  }\n\n  get stream() {\n    return this._stream;\n  }\n\n  get source() {\n    return this._source;\n  }\n\n  get buffer() {\n    return this._buffer;\n  }\n\n  set buffer(b) {\n    this._buffer = b;\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  get playing() {\n    return this._playing;\n  }\n\n  get progress() {\n    let dur = 0;\n    let curr = 0;\n\n    if (!!this._buffer) {\n      dur = this._buffer.duration;\n      curr = this._timestamp ? this._ctx.currentTime - this._timestamp : 0;\n    } else {\n      dur = this._source.duration;\n      curr = this._source.currentTime;\n    }\n\n    return curr / dur;\n  }\n\n  get playable() {\n    return this._type === \"input\" ? this._node !== undefined : !!this._buffer || this._source.readyState === 4;\n  }\n\n  get binSize() {\n    return this.analyzer.size;\n  }\n\n  get sampleRate() {\n    return this._ctx.sampleRate;\n  }\n\n  get frequency() {\n    return this._type === \"gen\" ? this._node.frequency.value : 0;\n  }\n\n  set frequency(f) {\n    if (this._type === \"gen\") this._node.frequency.value = f;\n  }\n\n  connect(node) {\n    this._node.connect(node);\n\n    return this;\n  }\n\n  analyze(size = 256, minDb = -100, maxDb = -30, smooth = 0.8) {\n    let a = this._ctx.createAnalyser();\n\n    a.fftSize = size * 2;\n    a.minDecibels = minDb;\n    a.maxDecibels = maxDb;\n    a.smoothingTimeConstant = smooth;\n    this.analyzer = {\n      node: a,\n      size: a.frequencyBinCount,\n      data: new Uint8Array(a.frequencyBinCount)\n    };\n\n    this._node.connect(this.analyzer.node);\n\n    return this;\n  }\n\n  _domain(time) {\n    if (this.analyzer) {\n      if (time) {\n        this.analyzer.node.getByteTimeDomainData(this.analyzer.data);\n      } else {\n        this.analyzer.node.getByteFrequencyData(this.analyzer.data);\n      }\n\n      return this.analyzer.data;\n    }\n\n    return new Uint8Array(0);\n  }\n\n  _domainTo(time, size, position = [0, 0], trim = [0, 0]) {\n    let data = time ? this.timeDomain() : this.freqDomain();\n    let g = new Group();\n\n    for (let i = trim[0], len = data.length - trim[1]; i < len; i++) {\n      g.push(new Pt(position[0] + size[0] * i / len, position[1] + size[1] * data[i] / 255));\n    }\n\n    return g;\n  }\n\n  timeDomain() {\n    return this._domain(true);\n  }\n\n  timeDomainTo(size, position = [0, 0], trim = [0, 0]) {\n    return this._domainTo(true, size, position, trim);\n  }\n\n  freqDomain() {\n    return this._domain(false);\n  }\n\n  freqDomainTo(size, position = [0, 0], trim = [0, 0]) {\n    return this._domainTo(false, size, position, trim);\n  }\n\n  reset() {\n    this.stop();\n\n    this._node.disconnect();\n\n    return this;\n  }\n\n  start(timeAt = 0) {\n    if (this._ctx.state === 'suspended') this._ctx.resume();\n\n    if (this._type === \"file\") {\n      if (!!this._buffer) {\n        this._node.start(timeAt);\n\n        this._timestamp = this._ctx.currentTime + timeAt;\n      } else {\n        this._source.play();\n\n        if (timeAt > 0) this._source.currentTime = timeAt;\n      }\n    } else if (this._type === \"gen\") {\n      this._gen(this._node.type, this._node.frequency.value);\n\n      this._node.start();\n\n      if (this.analyzer) this._node.connect(this.analyzer.node);\n    }\n\n    this._node.connect(this._ctx.destination);\n\n    this._playing = true;\n    return this;\n  }\n\n  stop() {\n    if (this._playing) this._node.disconnect(this._ctx.destination);\n\n    if (this._type === \"file\") {\n      if (!!this._buffer) {\n        if (this.progress < 1) this._node.stop();\n      } else {\n        this._source.pause();\n      }\n    } else if (this._type === \"gen\") {\n      this._node.stop();\n    } else if (this._type === \"input\") {\n      this._stream.getAudioTracks().forEach(track => track.stop());\n    }\n\n    this._playing = false;\n    return this;\n  }\n\n  toggle() {\n    if (this._playing) {\n      this.stop();\n    } else {\n      this.start();\n    }\n\n    return this;\n  }\n\n}","map":{"version":3,"sources":["/Users/erickoduniyi/Desktop/Work/multi_media_signal_processing/skeuomorphic-synth-master/node_modules/pts/dist/es2015/Play.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Pt","Group","Num","Tempo","constructor","bpm","_listeners","_listenerInc","fromBeat","ms","_bpm","n","_ms","Math","floor","_createID","listener","id","name","every","beats","self","p","Array","isArray","start","fn","offset","period","index","duration","continuous","progress","track","time","k","hasOwnProperty","li","_t","isStart","length","count","max","ceil","params","clamp","stop","animate","ftime","Sound","type","_playing","_type","_ctx","window","AudioContext","webkitAudioContext","Error","undefined","from","node","ctx","stream","s","_node","_stream","load","source","crossOrigin","_source","Audio","autoplay","addEventListener","createMediaElementSource","loadAsBuffer","url","request","XMLHttpRequest","open","responseType","onload","decodeAudioData","response","buffer","createBuffer","err","send","buf","createBufferSource","_buffer","onended","generate","val","_gen","createOscillator","osc","setPeriodicWave","frequency","input","constraint","c","audio","video","navigator","mediaDevices","getUserMedia","createMediaStreamSource","console","error","b","playing","dur","curr","_timestamp","currentTime","playable","readyState","binSize","analyzer","size","sampleRate","f","connect","analyze","minDb","maxDb","smooth","a","createAnalyser","fftSize","minDecibels","maxDecibels","smoothingTimeConstant","frequencyBinCount","data","Uint8Array","_domain","getByteTimeDomainData","getByteFrequencyData","_domainTo","position","trim","timeDomain","freqDomain","g","i","len","push","timeDomainTo","freqDomainTo","reset","disconnect","timeAt","state","resume","play","destination","pause","getAudioTracks","forEach","toggle"],"mappings":"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","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Pt, Group } from \"./Pt\";\nimport { Num } from \"./Num\";\nexport class Tempo {\n    constructor(bpm) {\n        this._listeners = {};\n        this._listenerInc = 0;\n        this.bpm = bpm;\n    }\n    static fromBeat(ms) {\n        return new Tempo(60000 / ms);\n    }\n    get bpm() { return this._bpm; }\n    set bpm(n) {\n        this._bpm = n;\n        this._ms = 60000 / this._bpm;\n    }\n    get ms() { return this._ms; }\n    set ms(n) {\n        this._bpm = Math.floor(60000 / n);\n        this._ms = 60000 / this._bpm;\n    }\n    _createID(listener) {\n        let id = '';\n        if (typeof listener === 'function') {\n            id = '_b' + (this._listenerInc++);\n        }\n        else {\n            id = listener.name || '_b' + (this._listenerInc++);\n        }\n        return id;\n    }\n    every(beats) {\n        let self = this;\n        let p = Array.isArray(beats) ? beats[0] : beats;\n        return {\n            start: function (fn, offset = 0, name) {\n                let id = name || self._createID(fn);\n                self._listeners[id] = { name: id, beats: beats, period: p, index: 0, offset: offset, duration: -1, continuous: false, fn: fn };\n                return this;\n            },\n            progress: function (fn, offset = 0, name) {\n                let id = name || self._createID(fn);\n                self._listeners[id] = { name: id, beats: beats, period: p, index: 0, offset: offset, duration: -1, continuous: true, fn: fn };\n                return this;\n            }\n        };\n    }\n    track(time) {\n        for (let k in this._listeners) {\n            if (this._listeners.hasOwnProperty(k)) {\n                let li = this._listeners[k];\n                let _t = (li.offset) ? time + li.offset : time;\n                let ms = li.period * this._ms;\n                let isStart = false;\n                if (_t > li.duration + ms) {\n                    li.duration = _t - (_t % this._ms);\n                    if (Array.isArray(li.beats)) {\n                        li.index = (li.index + 1) % li.beats.length;\n                        li.period = li.beats[li.index];\n                    }\n                    isStart = true;\n                }\n                let count = Math.max(0, Math.ceil(Math.floor(li.duration / this._ms) / li.period));\n                let params = (li.continuous) ? [count, Num.clamp((_t - li.duration) / ms, 0, 1), _t, isStart] : [count];\n                if (li.continuous || isStart) {\n                    let done = li.fn.apply(li, params);\n                    if (done)\n                        delete this._listeners[li.name];\n                }\n            }\n        }\n    }\n    stop(name) {\n        if (this._listeners[name])\n            delete this._listeners[name];\n    }\n    animate(time, ftime) {\n        this.track(time);\n    }\n}\nexport class Sound {\n    constructor(type) {\n        this._playing = false;\n        this._type = type;\n        let _ctx = window.AudioContext || window.webkitAudioContext || false;\n        if (!_ctx)\n            throw (new Error(\"Your browser doesn't support Web Audio. (No AudioContext)\"));\n        this._ctx = (_ctx) ? new _ctx() : undefined;\n    }\n    static from(node, ctx, type = \"gen\", stream) {\n        let s = new Sound(type);\n        s._node = node;\n        s._ctx = ctx;\n        if (stream)\n            s._stream = stream;\n        return s;\n    }\n    static load(source, crossOrigin = \"anonymous\") {\n        return new Promise((resolve, reject) => {\n            let s = new Sound(\"file\");\n            s._source = (typeof source === 'string') ? new Audio(source) : source;\n            s._source.autoplay = false;\n            s._source.crossOrigin = crossOrigin;\n            s._source.addEventListener(\"ended\", function () { s._playing = false; });\n            s._source.addEventListener('error', function () { reject(\"Error loading sound\"); });\n            s._source.addEventListener('canplaythrough', function () {\n                s._node = s._ctx.createMediaElementSource(s._source);\n                resolve(s);\n            });\n        });\n    }\n    static loadAsBuffer(url) {\n        return new Promise((resolve, reject) => {\n            let request = new XMLHttpRequest();\n            request.open('GET', url, true);\n            request.responseType = 'arraybuffer';\n            let s = new Sound(\"file\");\n            request.onload = function () {\n                s._ctx.decodeAudioData(request.response, function (buffer) {\n                    s.createBuffer(buffer);\n                    resolve(s);\n                }, (err) => reject(\"Error decoding audio\"));\n            };\n            request.send();\n        });\n    }\n    createBuffer(buf) {\n        this._node = this._ctx.createBufferSource();\n        if (buf !== undefined)\n            this._buffer = buf;\n        this._node.buffer = this._buffer;\n        this._node.onended = () => { this._playing = false; };\n        return this;\n    }\n    static generate(type, val) {\n        let s = new Sound(\"gen\");\n        return s._gen(type, val);\n    }\n    _gen(type, val) {\n        this._node = this._ctx.createOscillator();\n        let osc = this._node;\n        osc.type = type;\n        if (type === 'custom') {\n            osc.setPeriodicWave(val);\n        }\n        else {\n            osc.frequency.value = val;\n        }\n        return this;\n    }\n    static input(constraint) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                let s = new Sound(\"input\");\n                if (!s)\n                    return undefined;\n                const c = constraint ? constraint : { audio: true, video: false };\n                s._stream = yield navigator.mediaDevices.getUserMedia(c);\n                s._node = s._ctx.createMediaStreamSource(s._stream);\n                return s;\n            }\n            catch (e) {\n                console.error(\"Cannot get audio from input device.\");\n                return Promise.resolve(null);\n            }\n        });\n    }\n    get ctx() { return this._ctx; }\n    get node() { return this._node; }\n    get stream() { return this._stream; }\n    get source() { return this._source; }\n    get buffer() { return this._buffer; }\n    set buffer(b) { this._buffer = b; }\n    get type() { return this._type; }\n    get playing() { return this._playing; }\n    get progress() {\n        let dur = 0;\n        let curr = 0;\n        if (!!this._buffer) {\n            dur = this._buffer.duration;\n            curr = (this._timestamp) ? this._ctx.currentTime - this._timestamp : 0;\n        }\n        else {\n            dur = this._source.duration;\n            curr = this._source.currentTime;\n        }\n        return curr / dur;\n    }\n    get playable() {\n        return (this._type === \"input\") ? this._node !== undefined : (!!this._buffer || this._source.readyState === 4);\n    }\n    get binSize() {\n        return this.analyzer.size;\n    }\n    get sampleRate() {\n        return this._ctx.sampleRate;\n    }\n    get frequency() {\n        return (this._type === \"gen\") ? this._node.frequency.value : 0;\n    }\n    set frequency(f) {\n        if (this._type === \"gen\")\n            this._node.frequency.value = f;\n    }\n    connect(node) {\n        this._node.connect(node);\n        return this;\n    }\n    analyze(size = 256, minDb = -100, maxDb = -30, smooth = 0.8) {\n        let a = this._ctx.createAnalyser();\n        a.fftSize = size * 2;\n        a.minDecibels = minDb;\n        a.maxDecibels = maxDb;\n        a.smoothingTimeConstant = smooth;\n        this.analyzer = {\n            node: a,\n            size: a.frequencyBinCount,\n            data: new Uint8Array(a.frequencyBinCount)\n        };\n        this._node.connect(this.analyzer.node);\n        return this;\n    }\n    _domain(time) {\n        if (this.analyzer) {\n            if (time) {\n                this.analyzer.node.getByteTimeDomainData(this.analyzer.data);\n            }\n            else {\n                this.analyzer.node.getByteFrequencyData(this.analyzer.data);\n            }\n            return this.analyzer.data;\n        }\n        return new Uint8Array(0);\n    }\n    _domainTo(time, size, position = [0, 0], trim = [0, 0]) {\n        let data = (time) ? this.timeDomain() : this.freqDomain();\n        let g = new Group();\n        for (let i = trim[0], len = data.length - trim[1]; i < len; i++) {\n            g.push(new Pt(position[0] + size[0] * i / len, position[1] + size[1] * data[i] / 255));\n        }\n        return g;\n    }\n    timeDomain() {\n        return this._domain(true);\n    }\n    timeDomainTo(size, position = [0, 0], trim = [0, 0]) {\n        return this._domainTo(true, size, position, trim);\n    }\n    freqDomain() {\n        return this._domain(false);\n    }\n    freqDomainTo(size, position = [0, 0], trim = [0, 0]) {\n        return this._domainTo(false, size, position, trim);\n    }\n    reset() {\n        this.stop();\n        this._node.disconnect();\n        return this;\n    }\n    start(timeAt = 0) {\n        if (this._ctx.state === 'suspended')\n            this._ctx.resume();\n        if (this._type === \"file\") {\n            if (!!this._buffer) {\n                this._node.start(timeAt);\n                this._timestamp = this._ctx.currentTime + timeAt;\n            }\n            else {\n                this._source.play();\n                if (timeAt > 0)\n                    this._source.currentTime = timeAt;\n            }\n        }\n        else if (this._type === \"gen\") {\n            this._gen(this._node.type, this._node.frequency.value);\n            this._node.start();\n            if (this.analyzer)\n                this._node.connect(this.analyzer.node);\n        }\n        this._node.connect(this._ctx.destination);\n        this._playing = true;\n        return this;\n    }\n    stop() {\n        if (this._playing)\n            this._node.disconnect(this._ctx.destination);\n        if (this._type === \"file\") {\n            if (!!this._buffer) {\n                if (this.progress < 1)\n                    this._node.stop();\n            }\n            else {\n                this._source.pause();\n            }\n        }\n        else if (this._type === \"gen\") {\n            this._node.stop();\n        }\n        else if (this._type === \"input\") {\n            this._stream.getAudioTracks().forEach(track => track.stop());\n        }\n        this._playing = false;\n        return this;\n    }\n    toggle() {\n        if (this._playing) {\n            this.stop();\n        }\n        else {\n            this.start();\n        }\n        return this;\n    }\n}\n//# sourceMappingURL=Play.js.map"]},"metadata":{},"sourceType":"module"}