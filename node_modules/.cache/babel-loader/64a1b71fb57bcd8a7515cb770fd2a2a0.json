{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { isArray, isObject, isString } from \"../../core/util/TypeCheck\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { OfflineContext } from \"../../core/context/OfflineContext\";\nimport { assert } from \"../../core/util/Debug\";\nimport { range, timeRange } from \"../../core/util/Decorator\";\n/**\n * Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)\n * envelope generator. Envelope outputs a signal which\n * can be connected to an AudioParam or Tone.Signal.\n * ```\n *           /\\\n *          /  \\\n *         /    \\\n *        /      \\\n *       /        \\___________\n *      /                     \\\n *     /                       \\\n *    /                         \\\n *   /                           \\\n * ```\n *\n * @example\n * import { Envelope, Gain } from \"tone\";\n * // an amplitude envelope\n * const gainNode = new Gain();\n * const env = new Envelope({\n * \tattack: 0.1,\n * \tdecay: 0.2,\n * \tsustain: 1,\n * \trelease: 0.8,\n * });\n * env.connect(gainNode.gain);\n * @category Component\n */\n\nvar Envelope =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Envelope, _super);\n\n  function Envelope() {\n    var _this = _super.call(this, optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"])) || this;\n\n    _this.name = \"Envelope\";\n    /**\n     * the signal which is output.\n     */\n\n    _this._sig = new Signal({\n      context: _this.context,\n      value: 0\n    });\n    /**\n     * The output signal of the envelope\n     */\n\n    _this.output = _this._sig;\n    /**\n     * Envelope has no input\n     */\n\n    _this.input = undefined;\n    var options = optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]);\n    _this.attack = options.attack;\n    _this.decay = options.decay;\n    _this.sustain = options.sustain;\n    _this.release = options.release;\n    _this.attackCurve = options.attackCurve;\n    _this.releaseCurve = options.releaseCurve;\n    _this.decayCurve = options.decayCurve;\n    return _this;\n  }\n\n  Envelope.getDefaults = function () {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      attack: 0.01,\n      attackCurve: \"linear\",\n      decay: 0.1,\n      decayCurve: \"exponential\",\n      release: 1,\n      releaseCurve: \"exponential\",\n      sustain: 0.5\n    });\n  };\n\n  Object.defineProperty(Envelope.prototype, \"value\", {\n    /**\n     * Read the current value of the envelope. Useful for\n     * synchronizing visual output to the envelope.\n     */\n    get: function () {\n      return this.getValueAtTime(this.now());\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Get the curve\n   * @param  curve\n   * @param  direction  In/Out\n   * @return The curve name\n   */\n\n  Envelope.prototype._getCurve = function (curve, direction) {\n    if (isString(curve)) {\n      return curve;\n    } else {\n      // look up the name in the curves array\n      var curveName = void 0;\n\n      for (curveName in EnvelopeCurves) {\n        if (EnvelopeCurves[curveName][direction] === curve) {\n          return curveName;\n        }\n      } // return the custom curve\n\n\n      return curve;\n    }\n  };\n  /**\n   * Assign a the curve to the given name using the direction\n   * @param  name\n   * @param  direction In/Out\n   * @param  curve\n   */\n\n\n  Envelope.prototype._setCurve = function (name, direction, curve) {\n    // check if it's a valid type\n    if (isString(curve) && Reflect.has(EnvelopeCurves, curve)) {\n      var curveDef = EnvelopeCurves[curve];\n\n      if (isObject(curveDef)) {\n        if (name !== \"_decayCurve\") {\n          this[name] = curveDef[direction];\n        }\n      } else {\n        this[name] = curveDef;\n      }\n    } else if (isArray(curve) && name !== \"_decayCurve\") {\n      this[name] = curve;\n    } else {\n      throw new Error(\"Envelope: invalid curve: \" + curve);\n    }\n  };\n\n  Object.defineProperty(Envelope.prototype, \"attackCurve\", {\n    /**\n     * The shape of the attack.\n     * Can be any of these strings:\n     * * \"linear\"\n     * * \"exponential\"\n     * * \"sine\"\n     * * \"cosine\"\n     * * \"bounce\"\n     * * \"ripple\"\n     * * \"step\"\n     *\n     * Can also be an array which describes the curve. Values\n     * in the array are evenly subdivided and linearly\n     * interpolated over the duration of the attack.\n     * @example\n     * import { Envelope } from \"tone\";\n     * const env = new Envelope();\n     * env.attackCurve = \"linear\";\n     * @example\n     * import { Envelope } from \"tone\";\n     * const env = new Envelope();\n     * // can also be an array\n     * env.attackCurve = [0, 0.2, 0.3, 0.4, 1];\n     */\n    get: function () {\n      return this._getCurve(this._attackCurve, \"In\");\n    },\n    set: function (curve) {\n      this._setCurve(\"_attackCurve\", \"In\", curve);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Envelope.prototype, \"releaseCurve\", {\n    /**\n     * The shape of the release. See the attack curve types.\n     * @example\n     * import { Envelope } from \"tone\";\n     * const env = new Envelope();\n     * env.releaseCurve = \"linear\";\n     */\n    get: function () {\n      return this._getCurve(this._releaseCurve, \"Out\");\n    },\n    set: function (curve) {\n      this._setCurve(\"_releaseCurve\", \"Out\", curve);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Envelope.prototype, \"decayCurve\", {\n    /**\n     * The shape of the decay either \"linear\" or \"exponential\"\n     * @example\n     * import { Envelope } from \"tone\";\n     * const env = new Envelope();\n     * env.decayCurve = \"linear\";\n     */\n    get: function () {\n      return this._decayCurve;\n    },\n    set: function (curve) {\n      assert([\"linear\", \"exponential\"].some(function (c) {\n        return c === curve;\n      }), \"Invalid envelope curve: \" + curve);\n      this._decayCurve = curve;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Trigger the attack/decay portion of the ADSR envelope.\n   * @param  time When the attack should start.\n   * @param velocity The velocity of the envelope scales the vales.\n   *                             number between 0-1\n   * @example\n   * import { AmplitudeEnvelope, Oscillator } from \"tone\";\n   * const env = new AmplitudeEnvelope().toDestination();\n   * const osc = new Oscillator().connect(env).start();\n   * // trigger the attack 0.5 seconds from now with a velocity of 0.2\n   * env.triggerAttack(\"+0.5\", 0.2);\n   */\n\n  Envelope.prototype.triggerAttack = function (time, velocity) {\n    if (velocity === void 0) {\n      velocity = 1;\n    }\n\n    this.log(\"triggerAttack\", time, velocity);\n    time = this.toSeconds(time);\n    var originalAttack = this.toSeconds(this.attack);\n    var attack = originalAttack;\n    var decay = this.toSeconds(this.decay); // check if it's not a complete attack\n\n    var currentValue = this.getValueAtTime(time);\n\n    if (currentValue > 0) {\n      // subtract the current value from the attack time\n      var attackRate = 1 / attack;\n      var remainingDistance = 1 - currentValue; // the attack is now the remaining time\n\n      attack = remainingDistance / attackRate;\n    } // attack\n\n\n    if (attack < this.sampleTime) {\n      // case where the attack time is 0 should set instantly\n      this._sig.setValueAtTime(velocity, time);\n    } else if (this._attackCurve === \"linear\") {\n      this._sig.linearRampTo(velocity, attack, time);\n    } else if (this._attackCurve === \"exponential\") {\n      this._sig.targetRampTo(velocity, attack, time);\n    } else {\n      this._sig.cancelAndHoldAtTime(time);\n\n      var curve = this._attackCurve; // find the starting position in the curve\n\n      for (var i = 1; i < curve.length; i++) {\n        // the starting index is between the two values\n        if (curve[i - 1] <= currentValue && currentValue <= curve[i]) {\n          curve = this._attackCurve.slice(i); // the first index is the current value\n\n          curve[0] = currentValue;\n          break;\n        }\n      }\n\n      this._sig.setValueCurveAtTime(curve, time, attack, velocity);\n    } // decay\n\n\n    if (decay) {\n      var decayValue = velocity * this.sustain;\n      var decayStart = time + attack;\n      this.log(\"decay\", decayStart);\n\n      if (this._decayCurve === \"linear\") {\n        this._sig.linearRampToValueAtTime(decayValue, decay + decayStart);\n      } else {\n        this._sig.exponentialApproachValueAtTime(decayValue, decayStart, decay);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Triggers the release of the envelope.\n   * @param  time When the release portion of the envelope should start.\n   * @example\n   * import { AmplitudeEnvelope, Oscillator } from \"tone\";\n   * const env = new AmplitudeEnvelope().toDestination();\n   * const osc = new Oscillator().connect(env).start();\n   * env.triggerAttack();\n   * // trigger the release half a second after the attack\n   * env.triggerRelease(\"+0.5\");\n   */\n\n\n  Envelope.prototype.triggerRelease = function (time) {\n    this.log(\"triggerRelease\", time);\n    time = this.toSeconds(time);\n    var currentValue = this.getValueAtTime(time);\n\n    if (currentValue > 0) {\n      var release = this.toSeconds(this.release);\n\n      if (release < this.sampleTime) {\n        this._sig.setValueAtTime(0, time);\n      } else if (this._releaseCurve === \"linear\") {\n        this._sig.linearRampTo(0, release, time);\n      } else if (this._releaseCurve === \"exponential\") {\n        this._sig.targetRampTo(0, release, time);\n      } else {\n        assert(isArray(this._releaseCurve), \"releaseCurve must be either 'linear', 'exponential' or an array\");\n\n        this._sig.cancelAndHoldAtTime(time);\n\n        this._sig.setValueCurveAtTime(this._releaseCurve, time, release, currentValue);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Get the scheduled value at the given time. This will\n   * return the unconverted (raw) value.\n   */\n\n\n  Envelope.prototype.getValueAtTime = function (time) {\n    return this._sig.getValueAtTime(time);\n  };\n  /**\n   * triggerAttackRelease is shorthand for triggerAttack, then waiting\n   * some duration, then triggerRelease.\n   * @param duration The duration of the sustain.\n   * @param time When the attack should be triggered.\n   * @param velocity The velocity of the envelope.\n   * @example\n   * import { AmplitudeEnvelope, Oscillator } from \"tone\";\n   * const env = new AmplitudeEnvelope().toDestination();\n   * const osc = new Oscillator().connect(env).start();\n   * // trigger the release 0.5 seconds after the attack\n   * env.triggerAttackRelease(0.5);\n   */\n\n\n  Envelope.prototype.triggerAttackRelease = function (duration, time, velocity) {\n    if (velocity === void 0) {\n      velocity = 1;\n    }\n\n    time = this.toSeconds(time);\n    this.triggerAttack(time, velocity);\n    this.triggerRelease(time + this.toSeconds(duration));\n    return this;\n  };\n  /**\n   * Cancels all scheduled envelope changes after the given time.\n   */\n\n\n  Envelope.prototype.cancel = function (after) {\n    this._sig.cancelScheduledValues(this.toSeconds(after));\n\n    return this;\n  };\n  /**\n   * Connect the envelope to a destination node.\n   */\n\n\n  Envelope.prototype.connect = function (destination, outputNumber, inputNumber) {\n    if (outputNumber === void 0) {\n      outputNumber = 0;\n    }\n\n    if (inputNumber === void 0) {\n      inputNumber = 0;\n    }\n\n    connectSignal(this, destination, outputNumber, inputNumber);\n    return this;\n  };\n  /**\n   * Render the envelope curve to an array of the given length.\n   * Good for visualizing the envelope curve\n   */\n\n\n  Envelope.prototype.asArray = function (length) {\n    if (length === void 0) {\n      length = 1024;\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var duration, context, attackPortion, envelopeDuration, sustainTime, totalDuration, clone, buffer;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            duration = length / this.context.sampleRate;\n            context = new OfflineContext(1, duration, this.context.sampleRate);\n            attackPortion = this.toSeconds(this.attack) + this.toSeconds(this.decay);\n            envelopeDuration = attackPortion + this.toSeconds(this.release);\n            sustainTime = envelopeDuration * 0.1;\n            totalDuration = envelopeDuration + sustainTime;\n            clone = new this.constructor(Object.assign(this.get(), {\n              attack: duration * this.toSeconds(this.attack) / totalDuration,\n              decay: duration * this.toSeconds(this.decay) / totalDuration,\n              release: duration * this.toSeconds(this.release) / totalDuration,\n              context: context\n            }));\n\n            clone._sig.toDestination();\n\n            clone.triggerAttackRelease(duration * (attackPortion + sustainTime) / totalDuration, 0);\n            return [4\n            /*yield*/\n            , context.render()];\n\n          case 1:\n            buffer = _a.sent();\n            return [2\n            /*return*/\n            , buffer.getChannelData(0)];\n        }\n      });\n    });\n  };\n\n  Envelope.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._sig.dispose();\n\n    return this;\n  };\n\n  tslib_1.__decorate([timeRange(0)], Envelope.prototype, \"attack\", void 0);\n\n  tslib_1.__decorate([timeRange(0)], Envelope.prototype, \"decay\", void 0);\n\n  tslib_1.__decorate([range(0, 1)], Envelope.prototype, \"sustain\", void 0);\n\n  tslib_1.__decorate([timeRange(0)], Envelope.prototype, \"release\", void 0);\n\n  return Envelope;\n}(ToneAudioNode);\n\nexport { Envelope };\n/**\n * Generate some complex envelope curves.\n */\n\nvar EnvelopeCurves = function () {\n  var curveLen = 128;\n  var i;\n  var k; // cosine curve\n\n  var cosineCurve = [];\n\n  for (i = 0; i < curveLen; i++) {\n    cosineCurve[i] = Math.sin(i / (curveLen - 1) * (Math.PI / 2));\n  } // ripple curve\n\n\n  var rippleCurve = [];\n  var rippleCurveFreq = 6.4;\n\n  for (i = 0; i < curveLen - 1; i++) {\n    k = i / (curveLen - 1);\n    var sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;\n    rippleCurve[i] = sineWave / 10 + k * 0.83;\n  }\n\n  rippleCurve[curveLen - 1] = 1; // stairs curve\n\n  var stairsCurve = [];\n  var steps = 5;\n\n  for (i = 0; i < curveLen; i++) {\n    stairsCurve[i] = Math.ceil(i / (curveLen - 1) * steps) / steps;\n  } // in-out easing curve\n\n\n  var sineCurve = [];\n\n  for (i = 0; i < curveLen; i++) {\n    k = i / (curveLen - 1);\n    sineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));\n  } // a bounce curve\n\n\n  var bounceCurve = [];\n\n  for (i = 0; i < curveLen; i++) {\n    k = i / (curveLen - 1);\n    var freq = Math.pow(k, 3) * 4 + 0.2;\n    var val = Math.cos(freq * Math.PI * 2 * k);\n    bounceCurve[i] = Math.abs(val * (1 - k));\n  }\n  /**\n   * Invert a value curve to make it work for the release\n   */\n\n\n  function invertCurve(curve) {\n    var out = new Array(curve.length);\n\n    for (var j = 0; j < curve.length; j++) {\n      out[j] = 1 - curve[j];\n    }\n\n    return out;\n  }\n  /**\n   * reverse the curve\n   */\n\n\n  function reverseCurve(curve) {\n    return curve.slice(0).reverse();\n  }\n  /**\n   * attack and release curve arrays\n   */\n\n\n  return {\n    bounce: {\n      In: invertCurve(bounceCurve),\n      Out: bounceCurve\n    },\n    cosine: {\n      In: cosineCurve,\n      Out: reverseCurve(cosineCurve)\n    },\n    exponential: \"exponential\",\n    linear: \"linear\",\n    ripple: {\n      In: rippleCurve,\n      Out: invertCurve(rippleCurve)\n    },\n    sine: {\n      In: sineCurve,\n      Out: invertCurve(sineCurve)\n    },\n    step: {\n      In: stairsCurve,\n      Out: invertCurve(stairsCurve)\n    }\n  };\n}();","map":{"version":3,"sources":["../../../../Tone/component/envelope/Envelope.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { isArray, isObject, isString } from \"../../core/util/TypeCheck\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { OfflineContext } from \"../../core/context/OfflineContext\";\nimport { assert } from \"../../core/util/Debug\";\nimport { range, timeRange } from \"../../core/util/Decorator\";\n/**\n * Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)\n * envelope generator. Envelope outputs a signal which\n * can be connected to an AudioParam or Tone.Signal.\n * ```\n *           /\\\n *          /  \\\n *         /    \\\n *        /      \\\n *       /        \\___________\n *      /                     \\\n *     /                       \\\n *    /                         \\\n *   /                           \\\n * ```\n *\n * @example\n * import { Envelope, Gain } from \"tone\";\n * // an amplitude envelope\n * const gainNode = new Gain();\n * const env = new Envelope({\n * \tattack: 0.1,\n * \tdecay: 0.2,\n * \tsustain: 1,\n * \trelease: 0.8,\n * });\n * env.connect(gainNode.gain);\n * @category Component\n */\nvar Envelope = /** @class */ (function (_super) {\n    tslib_1.__extends(Envelope, _super);\n    function Envelope() {\n        var _this = _super.call(this, optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"])) || this;\n        _this.name = \"Envelope\";\n        /**\n         * the signal which is output.\n         */\n        _this._sig = new Signal({\n            context: _this.context,\n            value: 0,\n        });\n        /**\n         * The output signal of the envelope\n         */\n        _this.output = _this._sig;\n        /**\n         * Envelope has no input\n         */\n        _this.input = undefined;\n        var options = optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]);\n        _this.attack = options.attack;\n        _this.decay = options.decay;\n        _this.sustain = options.sustain;\n        _this.release = options.release;\n        _this.attackCurve = options.attackCurve;\n        _this.releaseCurve = options.releaseCurve;\n        _this.decayCurve = options.decayCurve;\n        return _this;\n    }\n    Envelope.getDefaults = function () {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            attack: 0.01,\n            attackCurve: \"linear\",\n            decay: 0.1,\n            decayCurve: \"exponential\",\n            release: 1,\n            releaseCurve: \"exponential\",\n            sustain: 0.5,\n        });\n    };\n    Object.defineProperty(Envelope.prototype, \"value\", {\n        /**\n         * Read the current value of the envelope. Useful for\n         * synchronizing visual output to the envelope.\n         */\n        get: function () {\n            return this.getValueAtTime(this.now());\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Get the curve\n     * @param  curve\n     * @param  direction  In/Out\n     * @return The curve name\n     */\n    Envelope.prototype._getCurve = function (curve, direction) {\n        if (isString(curve)) {\n            return curve;\n        }\n        else {\n            // look up the name in the curves array\n            var curveName = void 0;\n            for (curveName in EnvelopeCurves) {\n                if (EnvelopeCurves[curveName][direction] === curve) {\n                    return curveName;\n                }\n            }\n            // return the custom curve\n            return curve;\n        }\n    };\n    /**\n     * Assign a the curve to the given name using the direction\n     * @param  name\n     * @param  direction In/Out\n     * @param  curve\n     */\n    Envelope.prototype._setCurve = function (name, direction, curve) {\n        // check if it's a valid type\n        if (isString(curve) && Reflect.has(EnvelopeCurves, curve)) {\n            var curveDef = EnvelopeCurves[curve];\n            if (isObject(curveDef)) {\n                if (name !== \"_decayCurve\") {\n                    this[name] = curveDef[direction];\n                }\n            }\n            else {\n                this[name] = curveDef;\n            }\n        }\n        else if (isArray(curve) && name !== \"_decayCurve\") {\n            this[name] = curve;\n        }\n        else {\n            throw new Error(\"Envelope: invalid curve: \" + curve);\n        }\n    };\n    Object.defineProperty(Envelope.prototype, \"attackCurve\", {\n        /**\n         * The shape of the attack.\n         * Can be any of these strings:\n         * * \"linear\"\n         * * \"exponential\"\n         * * \"sine\"\n         * * \"cosine\"\n         * * \"bounce\"\n         * * \"ripple\"\n         * * \"step\"\n         *\n         * Can also be an array which describes the curve. Values\n         * in the array are evenly subdivided and linearly\n         * interpolated over the duration of the attack.\n         * @example\n         * import { Envelope } from \"tone\";\n         * const env = new Envelope();\n         * env.attackCurve = \"linear\";\n         * @example\n         * import { Envelope } from \"tone\";\n         * const env = new Envelope();\n         * // can also be an array\n         * env.attackCurve = [0, 0.2, 0.3, 0.4, 1];\n         */\n        get: function () {\n            return this._getCurve(this._attackCurve, \"In\");\n        },\n        set: function (curve) {\n            this._setCurve(\"_attackCurve\", \"In\", curve);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Envelope.prototype, \"releaseCurve\", {\n        /**\n         * The shape of the release. See the attack curve types.\n         * @example\n         * import { Envelope } from \"tone\";\n         * const env = new Envelope();\n         * env.releaseCurve = \"linear\";\n         */\n        get: function () {\n            return this._getCurve(this._releaseCurve, \"Out\");\n        },\n        set: function (curve) {\n            this._setCurve(\"_releaseCurve\", \"Out\", curve);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Envelope.prototype, \"decayCurve\", {\n        /**\n         * The shape of the decay either \"linear\" or \"exponential\"\n         * @example\n         * import { Envelope } from \"tone\";\n         * const env = new Envelope();\n         * env.decayCurve = \"linear\";\n         */\n        get: function () {\n            return this._decayCurve;\n        },\n        set: function (curve) {\n            assert([\"linear\", \"exponential\"].some(function (c) { return c === curve; }), \"Invalid envelope curve: \" + curve);\n            this._decayCurve = curve;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Trigger the attack/decay portion of the ADSR envelope.\n     * @param  time When the attack should start.\n     * @param velocity The velocity of the envelope scales the vales.\n     *                             number between 0-1\n     * @example\n     * import { AmplitudeEnvelope, Oscillator } from \"tone\";\n     * const env = new AmplitudeEnvelope().toDestination();\n     * const osc = new Oscillator().connect(env).start();\n     * // trigger the attack 0.5 seconds from now with a velocity of 0.2\n     * env.triggerAttack(\"+0.5\", 0.2);\n     */\n    Envelope.prototype.triggerAttack = function (time, velocity) {\n        if (velocity === void 0) { velocity = 1; }\n        this.log(\"triggerAttack\", time, velocity);\n        time = this.toSeconds(time);\n        var originalAttack = this.toSeconds(this.attack);\n        var attack = originalAttack;\n        var decay = this.toSeconds(this.decay);\n        // check if it's not a complete attack\n        var currentValue = this.getValueAtTime(time);\n        if (currentValue > 0) {\n            // subtract the current value from the attack time\n            var attackRate = 1 / attack;\n            var remainingDistance = 1 - currentValue;\n            // the attack is now the remaining time\n            attack = remainingDistance / attackRate;\n        }\n        // attack\n        if (attack < this.sampleTime) {\n            // case where the attack time is 0 should set instantly\n            this._sig.setValueAtTime(velocity, time);\n        }\n        else if (this._attackCurve === \"linear\") {\n            this._sig.linearRampTo(velocity, attack, time);\n        }\n        else if (this._attackCurve === \"exponential\") {\n            this._sig.targetRampTo(velocity, attack, time);\n        }\n        else {\n            this._sig.cancelAndHoldAtTime(time);\n            var curve = this._attackCurve;\n            // find the starting position in the curve\n            for (var i = 1; i < curve.length; i++) {\n                // the starting index is between the two values\n                if (curve[i - 1] <= currentValue && currentValue <= curve[i]) {\n                    curve = this._attackCurve.slice(i);\n                    // the first index is the current value\n                    curve[0] = currentValue;\n                    break;\n                }\n            }\n            this._sig.setValueCurveAtTime(curve, time, attack, velocity);\n        }\n        // decay\n        if (decay) {\n            var decayValue = velocity * this.sustain;\n            var decayStart = time + attack;\n            this.log(\"decay\", decayStart);\n            if (this._decayCurve === \"linear\") {\n                this._sig.linearRampToValueAtTime(decayValue, decay + decayStart);\n            }\n            else {\n                this._sig.exponentialApproachValueAtTime(decayValue, decayStart, decay);\n            }\n        }\n        return this;\n    };\n    /**\n     * Triggers the release of the envelope.\n     * @param  time When the release portion of the envelope should start.\n     * @example\n     * import { AmplitudeEnvelope, Oscillator } from \"tone\";\n     * const env = new AmplitudeEnvelope().toDestination();\n     * const osc = new Oscillator().connect(env).start();\n     * env.triggerAttack();\n     * // trigger the release half a second after the attack\n     * env.triggerRelease(\"+0.5\");\n     */\n    Envelope.prototype.triggerRelease = function (time) {\n        this.log(\"triggerRelease\", time);\n        time = this.toSeconds(time);\n        var currentValue = this.getValueAtTime(time);\n        if (currentValue > 0) {\n            var release = this.toSeconds(this.release);\n            if (release < this.sampleTime) {\n                this._sig.setValueAtTime(0, time);\n            }\n            else if (this._releaseCurve === \"linear\") {\n                this._sig.linearRampTo(0, release, time);\n            }\n            else if (this._releaseCurve === \"exponential\") {\n                this._sig.targetRampTo(0, release, time);\n            }\n            else {\n                assert(isArray(this._releaseCurve), \"releaseCurve must be either 'linear', 'exponential' or an array\");\n                this._sig.cancelAndHoldAtTime(time);\n                this._sig.setValueCurveAtTime(this._releaseCurve, time, release, currentValue);\n            }\n        }\n        return this;\n    };\n    /**\n     * Get the scheduled value at the given time. This will\n     * return the unconverted (raw) value.\n     */\n    Envelope.prototype.getValueAtTime = function (time) {\n        return this._sig.getValueAtTime(time);\n    };\n    /**\n     * triggerAttackRelease is shorthand for triggerAttack, then waiting\n     * some duration, then triggerRelease.\n     * @param duration The duration of the sustain.\n     * @param time When the attack should be triggered.\n     * @param velocity The velocity of the envelope.\n     * @example\n     * import { AmplitudeEnvelope, Oscillator } from \"tone\";\n     * const env = new AmplitudeEnvelope().toDestination();\n     * const osc = new Oscillator().connect(env).start();\n     * // trigger the release 0.5 seconds after the attack\n     * env.triggerAttackRelease(0.5);\n     */\n    Envelope.prototype.triggerAttackRelease = function (duration, time, velocity) {\n        if (velocity === void 0) { velocity = 1; }\n        time = this.toSeconds(time);\n        this.triggerAttack(time, velocity);\n        this.triggerRelease(time + this.toSeconds(duration));\n        return this;\n    };\n    /**\n     * Cancels all scheduled envelope changes after the given time.\n     */\n    Envelope.prototype.cancel = function (after) {\n        this._sig.cancelScheduledValues(this.toSeconds(after));\n        return this;\n    };\n    /**\n     * Connect the envelope to a destination node.\n     */\n    Envelope.prototype.connect = function (destination, outputNumber, inputNumber) {\n        if (outputNumber === void 0) { outputNumber = 0; }\n        if (inputNumber === void 0) { inputNumber = 0; }\n        connectSignal(this, destination, outputNumber, inputNumber);\n        return this;\n    };\n    /**\n     * Render the envelope curve to an array of the given length.\n     * Good for visualizing the envelope curve\n     */\n    Envelope.prototype.asArray = function (length) {\n        if (length === void 0) { length = 1024; }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var duration, context, attackPortion, envelopeDuration, sustainTime, totalDuration, clone, buffer;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        duration = length / this.context.sampleRate;\n                        context = new OfflineContext(1, duration, this.context.sampleRate);\n                        attackPortion = this.toSeconds(this.attack) + this.toSeconds(this.decay);\n                        envelopeDuration = attackPortion + this.toSeconds(this.release);\n                        sustainTime = envelopeDuration * 0.1;\n                        totalDuration = envelopeDuration + sustainTime;\n                        clone = new this.constructor(Object.assign(this.get(), {\n                            attack: duration * this.toSeconds(this.attack) / totalDuration,\n                            decay: duration * this.toSeconds(this.decay) / totalDuration,\n                            release: duration * this.toSeconds(this.release) / totalDuration,\n                            context: context\n                        }));\n                        clone._sig.toDestination();\n                        clone.triggerAttackRelease(duration * (attackPortion + sustainTime) / totalDuration, 0);\n                        return [4 /*yield*/, context.render()];\n                    case 1:\n                        buffer = _a.sent();\n                        return [2 /*return*/, buffer.getChannelData(0)];\n                }\n            });\n        });\n    };\n    Envelope.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this._sig.dispose();\n        return this;\n    };\n    tslib_1.__decorate([\n        timeRange(0)\n    ], Envelope.prototype, \"attack\", void 0);\n    tslib_1.__decorate([\n        timeRange(0)\n    ], Envelope.prototype, \"decay\", void 0);\n    tslib_1.__decorate([\n        range(0, 1)\n    ], Envelope.prototype, \"sustain\", void 0);\n    tslib_1.__decorate([\n        timeRange(0)\n    ], Envelope.prototype, \"release\", void 0);\n    return Envelope;\n}(ToneAudioNode));\nexport { Envelope };\n/**\n * Generate some complex envelope curves.\n */\nvar EnvelopeCurves = (function () {\n    var curveLen = 128;\n    var i;\n    var k;\n    // cosine curve\n    var cosineCurve = [];\n    for (i = 0; i < curveLen; i++) {\n        cosineCurve[i] = Math.sin((i / (curveLen - 1)) * (Math.PI / 2));\n    }\n    // ripple curve\n    var rippleCurve = [];\n    var rippleCurveFreq = 6.4;\n    for (i = 0; i < curveLen - 1; i++) {\n        k = (i / (curveLen - 1));\n        var sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;\n        rippleCurve[i] = sineWave / 10 + k * 0.83;\n    }\n    rippleCurve[curveLen - 1] = 1;\n    // stairs curve\n    var stairsCurve = [];\n    var steps = 5;\n    for (i = 0; i < curveLen; i++) {\n        stairsCurve[i] = Math.ceil((i / (curveLen - 1)) * steps) / steps;\n    }\n    // in-out easing curve\n    var sineCurve = [];\n    for (i = 0; i < curveLen; i++) {\n        k = i / (curveLen - 1);\n        sineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));\n    }\n    // a bounce curve\n    var bounceCurve = [];\n    for (i = 0; i < curveLen; i++) {\n        k = i / (curveLen - 1);\n        var freq = Math.pow(k, 3) * 4 + 0.2;\n        var val = Math.cos(freq * Math.PI * 2 * k);\n        bounceCurve[i] = Math.abs(val * (1 - k));\n    }\n    /**\n     * Invert a value curve to make it work for the release\n     */\n    function invertCurve(curve) {\n        var out = new Array(curve.length);\n        for (var j = 0; j < curve.length; j++) {\n            out[j] = 1 - curve[j];\n        }\n        return out;\n    }\n    /**\n     * reverse the curve\n     */\n    function reverseCurve(curve) {\n        return curve.slice(0).reverse();\n    }\n    /**\n     * attack and release curve arrays\n     */\n    return {\n        bounce: {\n            In: invertCurve(bounceCurve),\n            Out: bounceCurve,\n        },\n        cosine: {\n            In: cosineCurve,\n            Out: reverseCurve(cosineCurve),\n        },\n        exponential: \"exponential\",\n        linear: \"linear\",\n        ripple: {\n            In: rippleCurve,\n            Out: invertCurve(rippleCurve),\n        },\n        sine: {\n            In: sineCurve,\n            Out: invertCurve(sineCurve),\n        },\n        step: {\n            In: stairsCurve,\n            Out: invertCurve(stairsCurve),\n        },\n    };\n})();\n//# sourceMappingURL=Envelope.js.map"]},"metadata":{},"sourceType":"module"}