{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { Param } from \"../context/Param\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isUndef } from \"../util/TypeCheck\";\n/**\n * A Param class just for computing ticks. Similar to the [[Param]] class,\n * but offers conversion to BPM values as well as ability to compute tick\n * duration and elapsed ticks\n */\n\nvar TickParam =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(TickParam, _super);\n\n  function TickParam() {\n    var _this = _super.call(this, optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"])) || this;\n\n    _this.name = \"TickParam\";\n    /**\n     * The timeline which tracks all of the automations.\n     */\n\n    _this._events = new Timeline(Infinity);\n    /**\n     * The internal holder for the multiplier value\n     */\n\n    _this._multiplier = 1;\n    var options = optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]); // set the multiplier\n\n    _this._multiplier = options.multiplier; // clear the ticks from the beginning\n\n    _this._events.cancel(0); // set an initial event\n\n\n    _this._events.add({\n      ticks: 0,\n      time: 0,\n      type: \"setValueAtTime\",\n      value: _this._fromType(options.value)\n    });\n\n    _this.setValueAtTime(options.value, 0);\n\n    return _this;\n  }\n\n  TickParam.getDefaults = function () {\n    return Object.assign(Param.getDefaults(), {\n      multiplier: 1,\n      units: \"hertz\",\n      value: 1\n    });\n  };\n\n  TickParam.prototype.setTargetAtTime = function (value, time, constant) {\n    // approximate it with multiple linear ramps\n    time = this.toSeconds(time);\n    this.setRampPoint(time);\n\n    var computedValue = this._fromType(value); // start from previously scheduled value\n\n\n    var prevEvent = this._events.get(time);\n\n    var segments = Math.round(Math.max(1 / constant, 1));\n\n    for (var i = 0; i <= segments; i++) {\n      var segTime = constant * i + time;\n\n      var rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);\n\n      this.linearRampToValueAtTime(this._toType(rampVal), segTime);\n    }\n\n    return this;\n  };\n\n  TickParam.prototype.setValueAtTime = function (value, time) {\n    var computedTime = this.toSeconds(time);\n\n    _super.prototype.setValueAtTime.call(this, value, time);\n\n    var event = this._events.get(computedTime);\n\n    var previousEvent = this._events.previousEvent(event);\n\n    var ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\n    event.ticks = Math.max(ticksUntilTime, 0);\n    return this;\n  };\n\n  TickParam.prototype.linearRampToValueAtTime = function (value, time) {\n    var computedTime = this.toSeconds(time);\n\n    _super.prototype.linearRampToValueAtTime.call(this, value, time);\n\n    var event = this._events.get(computedTime);\n\n    var previousEvent = this._events.previousEvent(event);\n\n    var ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\n    event.ticks = Math.max(ticksUntilTime, 0);\n    return this;\n  };\n\n  TickParam.prototype.exponentialRampToValueAtTime = function (value, time) {\n    // aproximate it with multiple linear ramps\n    time = this.toSeconds(time);\n\n    var computedVal = this._fromType(value); // start from previously scheduled value\n\n\n    var prevEvent = this._events.get(time); // approx 10 segments per second\n\n\n    var segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));\n    var segmentDur = (time - prevEvent.time) / segments;\n\n    for (var i = 0; i <= segments; i++) {\n      var segTime = segmentDur * i + prevEvent.time;\n\n      var rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);\n\n      this.linearRampToValueAtTime(this._toType(rampVal), segTime);\n    }\n\n    return this;\n  };\n  /**\n   * Returns the tick value at the time. Takes into account\n   * any automation curves scheduled on the signal.\n   * @param  event The time to get the tick count at\n   * @return The number of ticks which have elapsed at the time given any automations.\n   */\n\n\n  TickParam.prototype._getTicksUntilEvent = function (event, time) {\n    if (event === null) {\n      event = {\n        ticks: 0,\n        time: 0,\n        type: \"setValueAtTime\",\n        value: 0\n      };\n    } else if (isUndef(event.ticks)) {\n      var previousEvent = this._events.previousEvent(event);\n\n      event.ticks = this._getTicksUntilEvent(previousEvent, event.time);\n    }\n\n    var val0 = this._fromType(this.getValueAtTime(event.time));\n\n    var val1 = this._fromType(this.getValueAtTime(time)); // if it's right on the line, take the previous value\n\n\n    var onTheLineEvent = this._events.get(time);\n\n    if (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === \"setValueAtTime\") {\n      val1 = this._fromType(this.getValueAtTime(time - this.sampleTime));\n    }\n\n    return 0.5 * (time - event.time) * (val0 + val1) + event.ticks;\n  };\n  /**\n   * Returns the tick value at the time. Takes into account\n   * any automation curves scheduled on the signal.\n   * @param  time The time to get the tick count at\n   * @return The number of ticks which have elapsed at the time given any automations.\n   */\n\n\n  TickParam.prototype.getTicksAtTime = function (time) {\n    var computedTime = this.toSeconds(time);\n\n    var event = this._events.get(computedTime);\n\n    return Math.max(this._getTicksUntilEvent(event, computedTime), 0);\n  };\n  /**\n   * Return the elapsed time of the number of ticks from the given time\n   * @param ticks The number of ticks to calculate\n   * @param  time The time to get the next tick from\n   * @return The duration of the number of ticks from the given time in seconds\n   */\n\n\n  TickParam.prototype.getDurationOfTicks = function (ticks, time) {\n    var computedTime = this.toSeconds(time);\n    var currentTick = this.getTicksAtTime(time);\n    return this.getTimeOfTick(currentTick + ticks) - computedTime;\n  };\n  /**\n   * Given a tick, returns the time that tick occurs at.\n   * @return The time that the tick occurs.\n   */\n\n\n  TickParam.prototype.getTimeOfTick = function (tick) {\n    var before = this._events.get(tick, \"ticks\");\n\n    var after = this._events.getAfter(tick, \"ticks\");\n\n    if (before && before.ticks === tick) {\n      return before.time;\n    } else if (before && after && after.type === \"linearRampToValueAtTime\" && before.value !== after.value) {\n      var val0 = this._fromType(this.getValueAtTime(before.time));\n\n      var val1 = this._fromType(this.getValueAtTime(after.time));\n\n      var delta = (val1 - val0) / (after.time - before.time);\n      var k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));\n      var sol1 = (-val0 + k) / delta;\n      var sol2 = (-val0 - k) / delta;\n      return (sol1 > 0 ? sol1 : sol2) + before.time;\n    } else if (before) {\n      if (before.value === 0) {\n        return Infinity;\n      } else {\n        return before.time + (tick - before.ticks) / before.value;\n      }\n    } else {\n      return tick / this._initialValue;\n    }\n  };\n  /**\n   * Convert some number of ticks their the duration in seconds accounting\n   * for any automation curves starting at the given time.\n   * @param  ticks The number of ticks to convert to seconds.\n   * @param  when  When along the automation timeline to convert the ticks.\n   * @return The duration in seconds of the ticks.\n   */\n\n\n  TickParam.prototype.ticksToTime = function (ticks, when) {\n    return this.getDurationOfTicks(ticks, when);\n  };\n  /**\n   * The inverse of [[ticksToTime]]. Convert a duration in\n   * seconds to the corresponding number of ticks accounting for any\n   * automation curves starting at the given time.\n   * @param  duration The time interval to convert to ticks.\n   * @param  when When along the automation timeline to convert the ticks.\n   * @return The duration in ticks.\n   */\n\n\n  TickParam.prototype.timeToTicks = function (duration, when) {\n    var computedTime = this.toSeconds(when);\n    var computedDuration = this.toSeconds(duration);\n    var startTicks = this.getTicksAtTime(computedTime);\n    var endTicks = this.getTicksAtTime(computedTime + computedDuration);\n    return endTicks - startTicks;\n  };\n  /**\n   * Convert from the type when the unit value is BPM\n   */\n\n\n  TickParam.prototype._fromType = function (val) {\n    if (this.units === \"bpm\" && this.multiplier) {\n      return 1 / (60 / val / this.multiplier);\n    } else {\n      return _super.prototype._fromType.call(this, val);\n    }\n  };\n  /**\n   * Special case of type conversion where the units === \"bpm\"\n   */\n\n\n  TickParam.prototype._toType = function (val) {\n    if (this.units === \"bpm\" && this.multiplier) {\n      return val / this.multiplier * 60;\n    } else {\n      return _super.prototype._toType.call(this, val);\n    }\n  };\n\n  Object.defineProperty(TickParam.prototype, \"multiplier\", {\n    /**\n     * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n     */\n    get: function () {\n      return this._multiplier;\n    },\n    set: function (m) {\n      // get and reset the current value with the new multiplier\n      // might be necessary to clear all the previous values\n      var currentVal = this.value;\n      this._multiplier = m;\n      this.cancelScheduledValues(0);\n      this.setValueAtTime(currentVal, 0);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return TickParam;\n}(Param);\n\nexport { TickParam };","map":{"version":3,"sources":["../../../../Tone/core/clock/TickParam.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { Param } from \"../context/Param\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isUndef } from \"../util/TypeCheck\";\n/**\n * A Param class just for computing ticks. Similar to the [[Param]] class,\n * but offers conversion to BPM values as well as ability to compute tick\n * duration and elapsed ticks\n */\nvar TickParam = /** @class */ (function (_super) {\n    tslib_1.__extends(TickParam, _super);\n    function TickParam() {\n        var _this = _super.call(this, optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"])) || this;\n        _this.name = \"TickParam\";\n        /**\n         * The timeline which tracks all of the automations.\n         */\n        _this._events = new Timeline(Infinity);\n        /**\n         * The internal holder for the multiplier value\n         */\n        _this._multiplier = 1;\n        var options = optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]);\n        // set the multiplier\n        _this._multiplier = options.multiplier;\n        // clear the ticks from the beginning\n        _this._events.cancel(0);\n        // set an initial event\n        _this._events.add({\n            ticks: 0,\n            time: 0,\n            type: \"setValueAtTime\",\n            value: _this._fromType(options.value),\n        });\n        _this.setValueAtTime(options.value, 0);\n        return _this;\n    }\n    TickParam.getDefaults = function () {\n        return Object.assign(Param.getDefaults(), {\n            multiplier: 1,\n            units: \"hertz\",\n            value: 1,\n        });\n    };\n    TickParam.prototype.setTargetAtTime = function (value, time, constant) {\n        // approximate it with multiple linear ramps\n        time = this.toSeconds(time);\n        this.setRampPoint(time);\n        var computedValue = this._fromType(value);\n        // start from previously scheduled value\n        var prevEvent = this._events.get(time);\n        var segments = Math.round(Math.max(1 / constant, 1));\n        for (var i = 0; i <= segments; i++) {\n            var segTime = constant * i + time;\n            var rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);\n            this.linearRampToValueAtTime(this._toType(rampVal), segTime);\n        }\n        return this;\n    };\n    TickParam.prototype.setValueAtTime = function (value, time) {\n        var computedTime = this.toSeconds(time);\n        _super.prototype.setValueAtTime.call(this, value, time);\n        var event = this._events.get(computedTime);\n        var previousEvent = this._events.previousEvent(event);\n        var ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n        event.ticks = Math.max(ticksUntilTime, 0);\n        return this;\n    };\n    TickParam.prototype.linearRampToValueAtTime = function (value, time) {\n        var computedTime = this.toSeconds(time);\n        _super.prototype.linearRampToValueAtTime.call(this, value, time);\n        var event = this._events.get(computedTime);\n        var previousEvent = this._events.previousEvent(event);\n        var ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n        event.ticks = Math.max(ticksUntilTime, 0);\n        return this;\n    };\n    TickParam.prototype.exponentialRampToValueAtTime = function (value, time) {\n        // aproximate it with multiple linear ramps\n        time = this.toSeconds(time);\n        var computedVal = this._fromType(value);\n        // start from previously scheduled value\n        var prevEvent = this._events.get(time);\n        // approx 10 segments per second\n        var segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));\n        var segmentDur = ((time - prevEvent.time) / segments);\n        for (var i = 0; i <= segments; i++) {\n            var segTime = segmentDur * i + prevEvent.time;\n            var rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);\n            this.linearRampToValueAtTime(this._toType(rampVal), segTime);\n        }\n        return this;\n    };\n    /**\n     * Returns the tick value at the time. Takes into account\n     * any automation curves scheduled on the signal.\n     * @param  event The time to get the tick count at\n     * @return The number of ticks which have elapsed at the time given any automations.\n     */\n    TickParam.prototype._getTicksUntilEvent = function (event, time) {\n        if (event === null) {\n            event = {\n                ticks: 0,\n                time: 0,\n                type: \"setValueAtTime\",\n                value: 0,\n            };\n        }\n        else if (isUndef(event.ticks)) {\n            var previousEvent = this._events.previousEvent(event);\n            event.ticks = this._getTicksUntilEvent(previousEvent, event.time);\n        }\n        var val0 = this._fromType(this.getValueAtTime(event.time));\n        var val1 = this._fromType(this.getValueAtTime(time));\n        // if it's right on the line, take the previous value\n        var onTheLineEvent = this._events.get(time);\n        if (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === \"setValueAtTime\") {\n            val1 = this._fromType(this.getValueAtTime(time - this.sampleTime));\n        }\n        return 0.5 * (time - event.time) * (val0 + val1) + event.ticks;\n    };\n    /**\n     * Returns the tick value at the time. Takes into account\n     * any automation curves scheduled on the signal.\n     * @param  time The time to get the tick count at\n     * @return The number of ticks which have elapsed at the time given any automations.\n     */\n    TickParam.prototype.getTicksAtTime = function (time) {\n        var computedTime = this.toSeconds(time);\n        var event = this._events.get(computedTime);\n        return Math.max(this._getTicksUntilEvent(event, computedTime), 0);\n    };\n    /**\n     * Return the elapsed time of the number of ticks from the given time\n     * @param ticks The number of ticks to calculate\n     * @param  time The time to get the next tick from\n     * @return The duration of the number of ticks from the given time in seconds\n     */\n    TickParam.prototype.getDurationOfTicks = function (ticks, time) {\n        var computedTime = this.toSeconds(time);\n        var currentTick = this.getTicksAtTime(time);\n        return this.getTimeOfTick(currentTick + ticks) - computedTime;\n    };\n    /**\n     * Given a tick, returns the time that tick occurs at.\n     * @return The time that the tick occurs.\n     */\n    TickParam.prototype.getTimeOfTick = function (tick) {\n        var before = this._events.get(tick, \"ticks\");\n        var after = this._events.getAfter(tick, \"ticks\");\n        if (before && before.ticks === tick) {\n            return before.time;\n        }\n        else if (before && after &&\n            after.type === \"linearRampToValueAtTime\" &&\n            before.value !== after.value) {\n            var val0 = this._fromType(this.getValueAtTime(before.time));\n            var val1 = this._fromType(this.getValueAtTime(after.time));\n            var delta = (val1 - val0) / (after.time - before.time);\n            var k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));\n            var sol1 = (-val0 + k) / delta;\n            var sol2 = (-val0 - k) / delta;\n            return (sol1 > 0 ? sol1 : sol2) + before.time;\n        }\n        else if (before) {\n            if (before.value === 0) {\n                return Infinity;\n            }\n            else {\n                return before.time + (tick - before.ticks) / before.value;\n            }\n        }\n        else {\n            return tick / this._initialValue;\n        }\n    };\n    /**\n     * Convert some number of ticks their the duration in seconds accounting\n     * for any automation curves starting at the given time.\n     * @param  ticks The number of ticks to convert to seconds.\n     * @param  when  When along the automation timeline to convert the ticks.\n     * @return The duration in seconds of the ticks.\n     */\n    TickParam.prototype.ticksToTime = function (ticks, when) {\n        return this.getDurationOfTicks(ticks, when);\n    };\n    /**\n     * The inverse of [[ticksToTime]]. Convert a duration in\n     * seconds to the corresponding number of ticks accounting for any\n     * automation curves starting at the given time.\n     * @param  duration The time interval to convert to ticks.\n     * @param  when When along the automation timeline to convert the ticks.\n     * @return The duration in ticks.\n     */\n    TickParam.prototype.timeToTicks = function (duration, when) {\n        var computedTime = this.toSeconds(when);\n        var computedDuration = this.toSeconds(duration);\n        var startTicks = this.getTicksAtTime(computedTime);\n        var endTicks = this.getTicksAtTime(computedTime + computedDuration);\n        return endTicks - startTicks;\n    };\n    /**\n     * Convert from the type when the unit value is BPM\n     */\n    TickParam.prototype._fromType = function (val) {\n        if (this.units === \"bpm\" && this.multiplier) {\n            return 1 / (60 / val / this.multiplier);\n        }\n        else {\n            return _super.prototype._fromType.call(this, val);\n        }\n    };\n    /**\n     * Special case of type conversion where the units === \"bpm\"\n     */\n    TickParam.prototype._toType = function (val) {\n        if (this.units === \"bpm\" && this.multiplier) {\n            return (val / this.multiplier) * 60;\n        }\n        else {\n            return _super.prototype._toType.call(this, val);\n        }\n    };\n    Object.defineProperty(TickParam.prototype, \"multiplier\", {\n        /**\n         * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n         */\n        get: function () {\n            return this._multiplier;\n        },\n        set: function (m) {\n            // get and reset the current value with the new multiplier\n            // might be necessary to clear all the previous values\n            var currentVal = this.value;\n            this._multiplier = m;\n            this.cancelScheduledValues(0);\n            this.setValueAtTime(currentVal, 0);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return TickParam;\n}(Param));\nexport { TickParam };\n//# sourceMappingURL=TickParam.js.map"]},"metadata":{},"sourceType":"module"}