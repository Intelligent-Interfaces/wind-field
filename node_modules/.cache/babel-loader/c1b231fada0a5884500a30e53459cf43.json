{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { isAudioNode, isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { Param } from \"./Param\";\nimport { ToneWithContext } from \"./ToneWithContext\";\nimport { assert, warn } from \"../util/Debug\";\n/**\n * ToneAudioNode is the base class for classes which process audio.\n */\n\nvar ToneAudioNode =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ToneAudioNode, _super);\n\n  function ToneAudioNode() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * The name of the class\n     */\n\n\n    _this.name = \"ToneAudioNode\";\n    /**\n     * List all of the node that must be set to match the ChannelProperties\n     */\n\n    _this._internalChannels = [];\n    return _this;\n  }\n\n  Object.defineProperty(ToneAudioNode.prototype, \"numberOfInputs\", {\n    /**\n     * The number of inputs feeding into the AudioNode.\n     * For source nodes, this will be 0.\n     */\n    get: function () {\n      if (isDefined(this.input)) {\n        if (isAudioParam(this.input) || this.input instanceof Param) {\n          return 1;\n        } else {\n          return this.input.numberOfInputs;\n        }\n      } else {\n        return 0;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ToneAudioNode.prototype, \"numberOfOutputs\", {\n    /**\n     * The number of outputs of the AudioNode.\n     */\n    get: function () {\n      if (isDefined(this.output)) {\n        return this.output.numberOfOutputs;\n      } else {\n        return 0;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  }); //-------------------------------------\n  // AUDIO PROPERTIES\n  //-------------------------------------\n\n  /**\n   * Used to decide which nodes to get/set properties on\n   */\n\n  ToneAudioNode.prototype._isAudioNode = function (node) {\n    return isDefined(node) && (node instanceof ToneAudioNode || isAudioNode(node));\n  };\n  /**\n   * Get all of the audio nodes (either internal or input/output) which together\n   * make up how the class node responds to channel input/output\n   */\n\n\n  ToneAudioNode.prototype._getInternalNodes = function () {\n    var nodeList = this._internalChannels.slice(0);\n\n    if (this._isAudioNode(this.input)) {\n      nodeList.push(this.input);\n    }\n\n    if (this._isAudioNode(this.output)) {\n      if (this.input !== this.output) {\n        nodeList.push(this.output);\n      }\n    }\n\n    return nodeList;\n  };\n  /**\n   * Set the audio options for this node such as channelInterpretation\n   * channelCount, etc.\n   * @param options\n   */\n\n\n  ToneAudioNode.prototype._setChannelProperties = function (options) {\n    var nodeList = this._getInternalNodes();\n\n    nodeList.forEach(function (node) {\n      node.channelCount = options.channelCount;\n      node.channelCountMode = options.channelCountMode;\n      node.channelInterpretation = options.channelInterpretation;\n    });\n  };\n  /**\n   * Get the current audio options for this node such as channelInterpretation\n   * channelCount, etc.\n   */\n\n\n  ToneAudioNode.prototype._getChannelProperties = function () {\n    var nodeList = this._getInternalNodes();\n\n    assert(nodeList.length > 0, \"ToneAudioNode does not have any internal nodes\"); // use the first node to get properties\n    // they should all be the same\n\n    var node = nodeList[0];\n    return {\n      channelCount: node.channelCount,\n      channelCountMode: node.channelCountMode,\n      channelInterpretation: node.channelInterpretation\n    };\n  };\n\n  Object.defineProperty(ToneAudioNode.prototype, \"channelCount\", {\n    /**\n     * channelCount is the number of channels used when up-mixing and down-mixing\n     * connections to any inputs to the node. The default value is 2 except for\n     * specific nodes where its value is specially determined.\n     */\n    get: function () {\n      return this._getChannelProperties().channelCount;\n    },\n    set: function (channelCount) {\n      var props = this._getChannelProperties(); // merge it with the other properties\n\n\n      this._setChannelProperties(Object.assign(props, {\n        channelCount: channelCount\n      }));\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ToneAudioNode.prototype, \"channelCountMode\", {\n    /**\n     * channelCountMode determines how channels will be counted when up-mixing and\n     * down-mixing connections to any inputs to the node.\n     * The default value is \"max\". This attribute has no effect for nodes with no inputs.\n     * * \"max\" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.\n     * * \"clamped-max\" - computedNumberOfChannels is determined as for \"max\" and then clamped to a maximum value of the given channelCount.\n     * * \"explicit\" - computedNumberOfChannels is the exact value as specified by the channelCount.\n     */\n    get: function () {\n      return this._getChannelProperties().channelCountMode;\n    },\n    set: function (channelCountMode) {\n      var props = this._getChannelProperties(); // merge it with the other properties\n\n\n      this._setChannelProperties(Object.assign(props, {\n        channelCountMode: channelCountMode\n      }));\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ToneAudioNode.prototype, \"channelInterpretation\", {\n    /**\n     * channelInterpretation determines how individual channels will be treated\n     * when up-mixing and down-mixing connections to any inputs to the node.\n     * The default value is \"speakers\".\n     */\n    get: function () {\n      return this._getChannelProperties().channelInterpretation;\n    },\n    set: function (channelInterpretation) {\n      var props = this._getChannelProperties(); // merge it with the other properties\n\n\n      this._setChannelProperties(Object.assign(props, {\n        channelInterpretation: channelInterpretation\n      }));\n    },\n    enumerable: true,\n    configurable: true\n  }); //-------------------------------------\n  // CONNECTIONS\n  //-------------------------------------\n\n  /**\n   * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode\n   * @param destination The output to connect to\n   * @param outputNum The output to connect from\n   * @param inputNum The input to connect to\n   */\n\n  ToneAudioNode.prototype.connect = function (destination, outputNum, inputNum) {\n    if (outputNum === void 0) {\n      outputNum = 0;\n    }\n\n    if (inputNum === void 0) {\n      inputNum = 0;\n    }\n\n    connect(this, destination, outputNum, inputNum);\n    return this;\n  };\n  /**\n   * Connect the output to the context's destination node.\n   */\n\n\n  ToneAudioNode.prototype.toDestination = function () {\n    this.connect(this.context.destination);\n    return this;\n  };\n  /**\n   * Connect the output to the context's destination node.\n   * See [[toDestination]]\n   * @deprecated\n   */\n\n\n  ToneAudioNode.prototype.toMaster = function () {\n    warn(\"toMaster() has been renamed toDestination()\");\n    return this.toDestination();\n  };\n  /**\n   * disconnect the output\n   */\n\n\n  ToneAudioNode.prototype.disconnect = function (destination, outputNum, inputNum) {\n    if (outputNum === void 0) {\n      outputNum = 0;\n    }\n\n    if (inputNum === void 0) {\n      inputNum = 0;\n    }\n\n    disconnect(this, destination, outputNum, inputNum);\n    return this;\n  };\n  /**\n   * Connect the output of this node to the rest of the nodes in series.\n   * @example\n   * import { Destination, Filter, Oscillator, Volume } from \"tone\";\n   * const osc = new Oscillator().start();\n   * const filter = new Filter();\n   * const volume = new Volume(-8);\n   * // connect a node to the filter, volume and then to the master output\n   * osc.chain(filter, volume, Destination);\n   */\n\n\n  ToneAudioNode.prototype.chain = function () {\n    var nodes = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      nodes[_i] = arguments[_i];\n    }\n\n    connectSeries.apply(void 0, tslib_1.__spread([this], nodes));\n    return this;\n  };\n  /**\n   * connect the output of this node to the rest of the nodes in parallel.\n   */\n\n\n  ToneAudioNode.prototype.fan = function () {\n    var _this = this;\n\n    var nodes = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      nodes[_i] = arguments[_i];\n    }\n\n    nodes.forEach(function (node) {\n      return _this.connect(node);\n    });\n    return this;\n  };\n  /**\n   * Dispose and disconnect\n   */\n\n\n  ToneAudioNode.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    if (isDefined(this.input)) {\n      if (this.input instanceof ToneAudioNode) {\n        this.input.dispose();\n      } else if (isAudioNode(this.input)) {\n        this.input.disconnect();\n      }\n    }\n\n    if (isDefined(this.output)) {\n      if (this.output instanceof ToneAudioNode) {\n        this.output.dispose();\n      } else if (isAudioNode(this.output)) {\n        this.output.disconnect();\n      }\n    }\n\n    this._internalChannels = [];\n    return this;\n  };\n\n  return ToneAudioNode;\n}(ToneWithContext);\n\nexport { ToneAudioNode }; //-------------------------------------\n// CONNECTIONS\n//-------------------------------------\n\n/**\n * connect together all of the arguments in series\n * @param nodes\n */\n\nexport function connectSeries() {\n  var nodes = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    nodes[_i] = arguments[_i];\n  }\n\n  var first = nodes.shift();\n  nodes.reduce(function (prev, current) {\n    if (prev instanceof ToneAudioNode) {\n      prev.connect(current);\n    } else if (isAudioNode(prev)) {\n      connect(prev, current);\n    }\n\n    return current;\n  }, first);\n}\n/**\n * Connect two nodes together so that signal flows from the\n * first node to the second. Optionally specify the input and output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\n\nexport function connect(srcNode, dstNode, outputNumber, inputNumber) {\n  if (outputNumber === void 0) {\n    outputNumber = 0;\n  }\n\n  if (inputNumber === void 0) {\n    inputNumber = 0;\n  }\n\n  assert(isDefined(srcNode), \"Cannot connect from undefined node\");\n  assert(isDefined(dstNode), \"Cannot connect to undefined node\");\n\n  if (dstNode instanceof ToneAudioNode || isAudioNode(dstNode)) {\n    assert(dstNode.numberOfInputs > 0, \"Cannot connect to node with no inputs\");\n  }\n\n  assert(srcNode.numberOfOutputs > 0, \"Cannot connect from node with no outputs\"); // resolve the input of the dstNode\n\n  while (dstNode instanceof ToneAudioNode || dstNode instanceof Param) {\n    if (isDefined(dstNode.input)) {\n      dstNode = dstNode.input;\n    }\n  }\n\n  while (srcNode instanceof ToneAudioNode) {\n    if (isDefined(srcNode.output)) {\n      srcNode = srcNode.output;\n    }\n  } // make the connection\n\n\n  if (isAudioParam(dstNode)) {\n    srcNode.connect(dstNode, outputNumber);\n  } else {\n    srcNode.connect(dstNode, outputNumber, inputNumber);\n  }\n}\n/**\n * Disconnect a node from all nodes or optionally include a destination node and input/output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\n\nexport function disconnect(srcNode, dstNode, outputNumber, inputNumber) {\n  if (outputNumber === void 0) {\n    outputNumber = 0;\n  }\n\n  if (inputNumber === void 0) {\n    inputNumber = 0;\n  } // resolve the destination node\n\n\n  if (isDefined(dstNode)) {\n    while (dstNode instanceof ToneAudioNode) {\n      dstNode = dstNode.input;\n    }\n  } // resolve the src node\n\n\n  while (!isAudioNode(srcNode)) {\n    if (isDefined(srcNode.output)) {\n      srcNode = srcNode.output;\n    }\n  }\n\n  if (isAudioParam(dstNode)) {\n    srcNode.disconnect(dstNode, outputNumber);\n  } else if (isAudioNode(dstNode)) {\n    srcNode.disconnect(dstNode, outputNumber, inputNumber);\n  } else {\n    srcNode.disconnect();\n  }\n}","map":{"version":3,"sources":["../../../../Tone/core/context/ToneAudioNode.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { isAudioNode, isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { Param } from \"./Param\";\nimport { ToneWithContext } from \"./ToneWithContext\";\nimport { assert, warn } from \"../util/Debug\";\n/**\n * ToneAudioNode is the base class for classes which process audio.\n */\nvar ToneAudioNode = /** @class */ (function (_super) {\n    tslib_1.__extends(ToneAudioNode, _super);\n    function ToneAudioNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * The name of the class\n         */\n        _this.name = \"ToneAudioNode\";\n        /**\n         * List all of the node that must be set to match the ChannelProperties\n         */\n        _this._internalChannels = [];\n        return _this;\n    }\n    Object.defineProperty(ToneAudioNode.prototype, \"numberOfInputs\", {\n        /**\n         * The number of inputs feeding into the AudioNode.\n         * For source nodes, this will be 0.\n         */\n        get: function () {\n            if (isDefined(this.input)) {\n                if (isAudioParam(this.input) || this.input instanceof Param) {\n                    return 1;\n                }\n                else {\n                    return this.input.numberOfInputs;\n                }\n            }\n            else {\n                return 0;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ToneAudioNode.prototype, \"numberOfOutputs\", {\n        /**\n         * The number of outputs of the AudioNode.\n         */\n        get: function () {\n            if (isDefined(this.output)) {\n                return this.output.numberOfOutputs;\n            }\n            else {\n                return 0;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    //-------------------------------------\n    // AUDIO PROPERTIES\n    //-------------------------------------\n    /**\n     * Used to decide which nodes to get/set properties on\n     */\n    ToneAudioNode.prototype._isAudioNode = function (node) {\n        return isDefined(node) && (node instanceof ToneAudioNode || isAudioNode(node));\n    };\n    /**\n     * Get all of the audio nodes (either internal or input/output) which together\n     * make up how the class node responds to channel input/output\n     */\n    ToneAudioNode.prototype._getInternalNodes = function () {\n        var nodeList = this._internalChannels.slice(0);\n        if (this._isAudioNode(this.input)) {\n            nodeList.push(this.input);\n        }\n        if (this._isAudioNode(this.output)) {\n            if (this.input !== this.output) {\n                nodeList.push(this.output);\n            }\n        }\n        return nodeList;\n    };\n    /**\n     * Set the audio options for this node such as channelInterpretation\n     * channelCount, etc.\n     * @param options\n     */\n    ToneAudioNode.prototype._setChannelProperties = function (options) {\n        var nodeList = this._getInternalNodes();\n        nodeList.forEach(function (node) {\n            node.channelCount = options.channelCount;\n            node.channelCountMode = options.channelCountMode;\n            node.channelInterpretation = options.channelInterpretation;\n        });\n    };\n    /**\n     * Get the current audio options for this node such as channelInterpretation\n     * channelCount, etc.\n     */\n    ToneAudioNode.prototype._getChannelProperties = function () {\n        var nodeList = this._getInternalNodes();\n        assert(nodeList.length > 0, \"ToneAudioNode does not have any internal nodes\");\n        // use the first node to get properties\n        // they should all be the same\n        var node = nodeList[0];\n        return {\n            channelCount: node.channelCount,\n            channelCountMode: node.channelCountMode,\n            channelInterpretation: node.channelInterpretation,\n        };\n    };\n    Object.defineProperty(ToneAudioNode.prototype, \"channelCount\", {\n        /**\n         * channelCount is the number of channels used when up-mixing and down-mixing\n         * connections to any inputs to the node. The default value is 2 except for\n         * specific nodes where its value is specially determined.\n         */\n        get: function () {\n            return this._getChannelProperties().channelCount;\n        },\n        set: function (channelCount) {\n            var props = this._getChannelProperties();\n            // merge it with the other properties\n            this._setChannelProperties(Object.assign(props, { channelCount: channelCount }));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ToneAudioNode.prototype, \"channelCountMode\", {\n        /**\n         * channelCountMode determines how channels will be counted when up-mixing and\n         * down-mixing connections to any inputs to the node.\n         * The default value is \"max\". This attribute has no effect for nodes with no inputs.\n         * * \"max\" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.\n         * * \"clamped-max\" - computedNumberOfChannels is determined as for \"max\" and then clamped to a maximum value of the given channelCount.\n         * * \"explicit\" - computedNumberOfChannels is the exact value as specified by the channelCount.\n         */\n        get: function () {\n            return this._getChannelProperties().channelCountMode;\n        },\n        set: function (channelCountMode) {\n            var props = this._getChannelProperties();\n            // merge it with the other properties\n            this._setChannelProperties(Object.assign(props, { channelCountMode: channelCountMode }));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ToneAudioNode.prototype, \"channelInterpretation\", {\n        /**\n         * channelInterpretation determines how individual channels will be treated\n         * when up-mixing and down-mixing connections to any inputs to the node.\n         * The default value is \"speakers\".\n         */\n        get: function () {\n            return this._getChannelProperties().channelInterpretation;\n        },\n        set: function (channelInterpretation) {\n            var props = this._getChannelProperties();\n            // merge it with the other properties\n            this._setChannelProperties(Object.assign(props, { channelInterpretation: channelInterpretation }));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    //-------------------------------------\n    // CONNECTIONS\n    //-------------------------------------\n    /**\n     * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode\n     * @param destination The output to connect to\n     * @param outputNum The output to connect from\n     * @param inputNum The input to connect to\n     */\n    ToneAudioNode.prototype.connect = function (destination, outputNum, inputNum) {\n        if (outputNum === void 0) { outputNum = 0; }\n        if (inputNum === void 0) { inputNum = 0; }\n        connect(this, destination, outputNum, inputNum);\n        return this;\n    };\n    /**\n     * Connect the output to the context's destination node.\n     */\n    ToneAudioNode.prototype.toDestination = function () {\n        this.connect(this.context.destination);\n        return this;\n    };\n    /**\n     * Connect the output to the context's destination node.\n     * See [[toDestination]]\n     * @deprecated\n     */\n    ToneAudioNode.prototype.toMaster = function () {\n        warn(\"toMaster() has been renamed toDestination()\");\n        return this.toDestination();\n    };\n    /**\n     * disconnect the output\n     */\n    ToneAudioNode.prototype.disconnect = function (destination, outputNum, inputNum) {\n        if (outputNum === void 0) { outputNum = 0; }\n        if (inputNum === void 0) { inputNum = 0; }\n        disconnect(this, destination, outputNum, inputNum);\n        return this;\n    };\n    /**\n     * Connect the output of this node to the rest of the nodes in series.\n     * @example\n     * import { Destination, Filter, Oscillator, Volume } from \"tone\";\n     * const osc = new Oscillator().start();\n     * const filter = new Filter();\n     * const volume = new Volume(-8);\n     * // connect a node to the filter, volume and then to the master output\n     * osc.chain(filter, volume, Destination);\n     */\n    ToneAudioNode.prototype.chain = function () {\n        var nodes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nodes[_i] = arguments[_i];\n        }\n        connectSeries.apply(void 0, tslib_1.__spread([this], nodes));\n        return this;\n    };\n    /**\n     * connect the output of this node to the rest of the nodes in parallel.\n     */\n    ToneAudioNode.prototype.fan = function () {\n        var _this = this;\n        var nodes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nodes[_i] = arguments[_i];\n        }\n        nodes.forEach(function (node) { return _this.connect(node); });\n        return this;\n    };\n    /**\n     * Dispose and disconnect\n     */\n    ToneAudioNode.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        if (isDefined(this.input)) {\n            if (this.input instanceof ToneAudioNode) {\n                this.input.dispose();\n            }\n            else if (isAudioNode(this.input)) {\n                this.input.disconnect();\n            }\n        }\n        if (isDefined(this.output)) {\n            if (this.output instanceof ToneAudioNode) {\n                this.output.dispose();\n            }\n            else if (isAudioNode(this.output)) {\n                this.output.disconnect();\n            }\n        }\n        this._internalChannels = [];\n        return this;\n    };\n    return ToneAudioNode;\n}(ToneWithContext));\nexport { ToneAudioNode };\n//-------------------------------------\n// CONNECTIONS\n//-------------------------------------\n/**\n * connect together all of the arguments in series\n * @param nodes\n */\nexport function connectSeries() {\n    var nodes = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        nodes[_i] = arguments[_i];\n    }\n    var first = nodes.shift();\n    nodes.reduce(function (prev, current) {\n        if (prev instanceof ToneAudioNode) {\n            prev.connect(current);\n        }\n        else if (isAudioNode(prev)) {\n            connect(prev, current);\n        }\n        return current;\n    }, first);\n}\n/**\n * Connect two nodes together so that signal flows from the\n * first node to the second. Optionally specify the input and output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function connect(srcNode, dstNode, outputNumber, inputNumber) {\n    if (outputNumber === void 0) { outputNumber = 0; }\n    if (inputNumber === void 0) { inputNumber = 0; }\n    assert(isDefined(srcNode), \"Cannot connect from undefined node\");\n    assert(isDefined(dstNode), \"Cannot connect to undefined node\");\n    if (dstNode instanceof ToneAudioNode || isAudioNode(dstNode)) {\n        assert(dstNode.numberOfInputs > 0, \"Cannot connect to node with no inputs\");\n    }\n    assert(srcNode.numberOfOutputs > 0, \"Cannot connect from node with no outputs\");\n    // resolve the input of the dstNode\n    while ((dstNode instanceof ToneAudioNode || dstNode instanceof Param)) {\n        if (isDefined(dstNode.input)) {\n            dstNode = dstNode.input;\n        }\n    }\n    while (srcNode instanceof ToneAudioNode) {\n        if (isDefined(srcNode.output)) {\n            srcNode = srcNode.output;\n        }\n    }\n    // make the connection\n    if (isAudioParam(dstNode)) {\n        srcNode.connect(dstNode, outputNumber);\n    }\n    else {\n        srcNode.connect(dstNode, outputNumber, inputNumber);\n    }\n}\n/**\n * Disconnect a node from all nodes or optionally include a destination node and input/output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function disconnect(srcNode, dstNode, outputNumber, inputNumber) {\n    if (outputNumber === void 0) { outputNumber = 0; }\n    if (inputNumber === void 0) { inputNumber = 0; }\n    // resolve the destination node\n    if (isDefined(dstNode)) {\n        while (dstNode instanceof ToneAudioNode) {\n            dstNode = dstNode.input;\n        }\n    }\n    // resolve the src node\n    while (!(isAudioNode(srcNode))) {\n        if (isDefined(srcNode.output)) {\n            srcNode = srcNode.output;\n        }\n    }\n    if (isAudioParam(dstNode)) {\n        srcNode.disconnect(dstNode, outputNumber);\n    }\n    else if (isAudioNode(dstNode)) {\n        srcNode.disconnect(dstNode, outputNumber, inputNumber);\n    }\n    else {\n        srcNode.disconnect();\n    }\n}\n//# sourceMappingURL=ToneAudioNode.js.map"]},"metadata":{},"sourceType":"module"}