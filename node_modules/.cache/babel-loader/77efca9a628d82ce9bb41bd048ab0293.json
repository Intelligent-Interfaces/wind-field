{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { createOfflineAudioContext } from \"../context/AudioContext\";\nimport { Context } from \"../context/Context\";\nimport { isOfflineAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n/**\n * Wrapper around the OfflineAudioContext\n * @category Core\n */\n\nvar OfflineContext =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(OfflineContext, _super);\n\n  function OfflineContext() {\n    var _this = _super.call(this, {\n      clockSource: \"offline\",\n      context: isOfflineAudioContext(arguments[0]) ? arguments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),\n      lookAhead: 0,\n      updateInterval: isOfflineAudioContext(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]\n    }) || this;\n\n    _this.name = \"OfflineContext\";\n    /**\n     * An artificial clock source\n     */\n\n    _this._currentTime = 0;\n    _this.isOffline = true;\n    _this._duration = isOfflineAudioContext(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1];\n    return _this;\n  }\n  /**\n   * Override the now method to point to the internal clock time\n   */\n\n\n  OfflineContext.prototype.now = function () {\n    return this._currentTime;\n  };\n\n  Object.defineProperty(OfflineContext.prototype, \"currentTime\", {\n    /**\n     * Same as this.now()\n     */\n    get: function () {\n      return this._currentTime;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Render just the clock portion of the audio context.\n   */\n\n  OfflineContext.prototype._renderClock = function (asynchronous) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var index, yieldEvery;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            index = 0;\n            _a.label = 1;\n\n          case 1:\n            if (!(this._duration - this._currentTime >= 0)) return [3\n            /*break*/\n            , 4]; // invoke all the callbacks on that time\n\n            this.emit(\"tick\"); // increment the clock in block-sized chunks\n\n            this._currentTime += 128 / this.sampleRate; // yield once a second of audio\n\n            index++;\n            yieldEvery = Math.floor(this.sampleRate / 128);\n            if (!(asynchronous && index % yieldEvery === 0)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , new Promise(function (done) {\n              return setTimeout(done, 1);\n            })];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            return [3\n            /*break*/\n            , 1];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Render the output of the OfflineContext\n   * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.\n   */\n\n\n  OfflineContext.prototype.render = function (asynchronous) {\n    if (asynchronous === void 0) {\n      asynchronous = true;\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var buffer;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.workletsAreReady()];\n\n          case 1:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this._renderClock(asynchronous)];\n\n          case 2:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this._context.startRendering()];\n\n          case 3:\n            buffer = _a.sent();\n            return [2\n            /*return*/\n            , new ToneAudioBuffer(buffer)];\n        }\n      });\n    });\n  };\n  /**\n   * Close the context\n   */\n\n\n  OfflineContext.prototype.close = function () {\n    return Promise.resolve();\n  };\n\n  return OfflineContext;\n}(Context);\n\nexport { OfflineContext };","map":{"version":3,"sources":["../../../../Tone/core/context/OfflineContext.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { createOfflineAudioContext } from \"../context/AudioContext\";\nimport { Context } from \"../context/Context\";\nimport { isOfflineAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n/**\n * Wrapper around the OfflineAudioContext\n * @category Core\n */\nvar OfflineContext = /** @class */ (function (_super) {\n    tslib_1.__extends(OfflineContext, _super);\n    function OfflineContext() {\n        var _this = _super.call(this, {\n            clockSource: \"offline\",\n            context: isOfflineAudioContext(arguments[0]) ?\n                arguments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),\n            lookAhead: 0,\n            updateInterval: isOfflineAudioContext(arguments[0]) ?\n                128 / arguments[0].sampleRate : 128 / arguments[2],\n        }) || this;\n        _this.name = \"OfflineContext\";\n        /**\n         * An artificial clock source\n         */\n        _this._currentTime = 0;\n        _this.isOffline = true;\n        _this._duration = isOfflineAudioContext(arguments[0]) ?\n            arguments[0].length / arguments[0].sampleRate : arguments[1];\n        return _this;\n    }\n    /**\n     * Override the now method to point to the internal clock time\n     */\n    OfflineContext.prototype.now = function () {\n        return this._currentTime;\n    };\n    Object.defineProperty(OfflineContext.prototype, \"currentTime\", {\n        /**\n         * Same as this.now()\n         */\n        get: function () {\n            return this._currentTime;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Render just the clock portion of the audio context.\n     */\n    OfflineContext.prototype._renderClock = function (asynchronous) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var index, yieldEvery;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        index = 0;\n                        _a.label = 1;\n                    case 1:\n                        if (!(this._duration - this._currentTime >= 0)) return [3 /*break*/, 4];\n                        // invoke all the callbacks on that time\n                        this.emit(\"tick\");\n                        // increment the clock in block-sized chunks\n                        this._currentTime += 128 / this.sampleRate;\n                        // yield once a second of audio\n                        index++;\n                        yieldEvery = Math.floor(this.sampleRate / 128);\n                        if (!(asynchronous && index % yieldEvery === 0)) return [3 /*break*/, 3];\n                        return [4 /*yield*/, new Promise(function (done) { return setTimeout(done, 1); })];\n                    case 2:\n                        _a.sent();\n                        _a.label = 3;\n                    case 3: return [3 /*break*/, 1];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Render the output of the OfflineContext\n     * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.\n     */\n    OfflineContext.prototype.render = function (asynchronous) {\n        if (asynchronous === void 0) { asynchronous = true; }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var buffer;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.workletsAreReady()];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, this._renderClock(asynchronous)];\n                    case 2:\n                        _a.sent();\n                        return [4 /*yield*/, this._context.startRendering()];\n                    case 3:\n                        buffer = _a.sent();\n                        return [2 /*return*/, new ToneAudioBuffer(buffer)];\n                }\n            });\n        });\n    };\n    /**\n     * Close the context\n     */\n    OfflineContext.prototype.close = function () {\n        return Promise.resolve();\n    };\n    return OfflineContext;\n}(Context));\nexport { OfflineContext };\n//# sourceMappingURL=OfflineContext.js.map"]},"metadata":{},"sourceType":"module"}