{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { deepEquals, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { ToneOscillatorNode } from \"./ToneOscillatorNode\";\nimport { assertRange } from \"../../core/util/Debug\";\nimport { clamp } from \"../../core/util/Math\";\n/**\n * Oscillator supports a number of features including\n * phase rotation, multiple oscillator types (see Oscillator.type),\n * and Transport syncing (see Oscillator.syncFrequency).\n *\n * @example\n * import { Oscillator } from \"tone\";\n * // make and start a 440hz sine tone\n * const osc = new Oscillator(440, \"sine\").toDestination().start();\n * @category Source\n */\n\nvar Oscillator =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Oscillator, _super);\n\n  function Oscillator() {\n    var _this = _super.call(this, optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"])) || this;\n\n    _this.name = \"Oscillator\";\n    /**\n     * the main oscillator\n     */\n\n    _this._oscillator = null;\n    var options = optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n    _this.frequency = new Signal({\n      context: _this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    readOnly(_this, \"frequency\");\n    _this.detune = new Signal({\n      context: _this.context,\n      units: \"cents\",\n      value: options.detune\n    });\n    readOnly(_this, \"detune\");\n    _this._partials = options.partials;\n    _this._partialCount = options.partialCount;\n    _this._type = options.type;\n\n    if (options.partialCount && options.type !== \"custom\") {\n      _this._type = _this.baseType + options.partialCount.toString();\n    }\n\n    _this.phase = options.phase;\n    return _this;\n  }\n\n  Oscillator.getDefaults = function () {\n    return Object.assign(Source.getDefaults(), {\n      detune: 0,\n      frequency: 440,\n      partialCount: 0,\n      partials: [],\n      phase: 0,\n      type: \"sine\"\n    });\n  };\n  /**\n   * start the oscillator\n   */\n\n\n  Oscillator.prototype._start = function (time) {\n    var _this = this;\n\n    var computedTime = this.toSeconds(time); // new oscillator with previous values\n\n    var oscillator = new ToneOscillatorNode({\n      context: this.context,\n      onended: function () {\n        return _this.onstop(_this);\n      }\n    });\n    this._oscillator = oscillator;\n\n    if (this._wave) {\n      this._oscillator.setPeriodicWave(this._wave);\n    } else {\n      this._oscillator.type = this._type;\n    } // connect the control signal to the oscillator frequency & detune\n\n\n    this._oscillator.connect(this.output);\n\n    this.frequency.connect(this._oscillator.frequency);\n    this.detune.connect(this._oscillator.detune); // start the oscillator\n\n    this._oscillator.start(computedTime);\n  };\n  /**\n   * stop the oscillator\n   */\n\n\n  Oscillator.prototype._stop = function (time) {\n    var computedTime = this.toSeconds(time);\n\n    if (this._oscillator) {\n      this._oscillator.stop(computedTime);\n    }\n  };\n  /**\n   * Restart the oscillator. Does not stop the oscillator, but instead\n   * just cancels any scheduled 'stop' from being invoked.\n   */\n\n\n  Oscillator.prototype._restart = function (time) {\n    var computedTime = this.toSeconds(time);\n    this.log(\"restart\", computedTime);\n\n    if (this._oscillator) {\n      this._oscillator.cancelStop();\n    }\n\n    this._state.cancel(computedTime);\n\n    return this;\n  };\n  /**\n   * Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n   * will also affect the oscillators frequency.\n   * @example\n   * import { Oscillator, Transport } from \"tone\";\n   * const osc = new Oscillator().toDestination().start();\n   * osc.frequency.value = 440;\n   * // the ratio between the bpm and the frequency will be maintained\n   * osc.syncFrequency();\n   * // double the tempo\n   * Transport.bpm.value *= 2;\n   * // the frequency of the oscillator is doubled to 880\n   */\n\n\n  Oscillator.prototype.syncFrequency = function () {\n    this.context.transport.syncSignal(this.frequency);\n    return this;\n  };\n  /**\n   * Unsync the oscillator's frequency from the Transport.\n   * See Oscillator.syncFrequency\n   */\n\n\n  Oscillator.prototype.unsyncFrequency = function () {\n    this.context.transport.unsyncSignal(this.frequency);\n    return this;\n  };\n  /**\n   * Get a cached periodic wave. Avoids having to recompute\n   * the oscillator values when they have already been computed\n   * with the same values.\n   */\n\n\n  Oscillator.prototype._getCachedPeriodicWave = function () {\n    var _this = this;\n\n    if (this._type === \"custom\") {\n      var oscProps = Oscillator._periodicWaveCache.find(function (description) {\n        return description.phase === _this._phase && deepEquals(description.partials, _this._partials);\n      });\n\n      return oscProps;\n    } else {\n      var oscProps = Oscillator._periodicWaveCache.find(function (description) {\n        return description.type === _this._type && description.phase === _this._phase;\n      });\n\n      this._partialCount = oscProps ? oscProps.partialCount : this._partialCount;\n      return oscProps;\n    }\n  };\n\n  Object.defineProperty(Oscillator.prototype, \"type\", {\n    get: function () {\n      return this._type;\n    },\n    set: function (type) {\n      this._type = type;\n      var isBasicType = [\"sine\", \"square\", \"sawtooth\", \"triangle\"].indexOf(type) !== -1;\n\n      if (this._phase === 0 && isBasicType) {\n        this._wave = undefined;\n        this._partialCount = 0; // just go with the basic approach\n\n        if (this._oscillator !== null) {\n          // already tested that it's a basic type\n          this._oscillator.type = type;\n        }\n      } else {\n        // first check if the value is cached\n        var cache = this._getCachedPeriodicWave();\n\n        if (isDefined(cache)) {\n          var partials = cache.partials,\n              wave = cache.wave;\n          this._wave = wave;\n          this._partials = partials;\n\n          if (this._oscillator !== null) {\n            this._oscillator.setPeriodicWave(this._wave);\n          }\n        } else {\n          var _a = tslib_1.__read(this._getRealImaginary(type, this._phase), 2),\n              real = _a[0],\n              imag = _a[1];\n\n          var periodicWave = this.context.createPeriodicWave(real, imag);\n          this._wave = periodicWave;\n\n          if (this._oscillator !== null) {\n            this._oscillator.setPeriodicWave(this._wave);\n          } // set the cache\n\n\n          Oscillator._periodicWaveCache.push({\n            imag: imag,\n            partialCount: this._partialCount,\n            partials: this._partials,\n            phase: this._phase,\n            real: real,\n            type: this._type,\n            wave: this._wave\n          });\n\n          if (Oscillator._periodicWaveCache.length > 100) {\n            Oscillator._periodicWaveCache.shift();\n          }\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Oscillator.prototype, \"baseType\", {\n    get: function () {\n      return this._type.replace(this.partialCount.toString(), \"\");\n    },\n    set: function (baseType) {\n      if (this.partialCount && this._type !== \"custom\" && baseType !== \"custom\") {\n        this.type = baseType + this.partialCount;\n      } else {\n        this.type = baseType;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Oscillator.prototype, \"partialCount\", {\n    get: function () {\n      return this._partialCount;\n    },\n    set: function (p) {\n      assertRange(p, 0);\n      var type = this._type;\n      var partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(this._type);\n\n      if (partial) {\n        type = partial[1];\n      }\n\n      if (this._type !== \"custom\") {\n        if (p === 0) {\n          this.type = type;\n        } else {\n          this.type = type + p.toString();\n        }\n      } else {\n        // extend or shorten the partials array\n        var fullPartials_1 = new Float32Array(p); // copy over the partials array\n\n        this._partials.forEach(function (v, i) {\n          return fullPartials_1[i] = v;\n        });\n\n        this._partials = Array.from(fullPartials_1);\n        this.type = this._type;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Returns the real and imaginary components based\n   * on the oscillator type.\n   * @returns [real: Float32Array, imaginary: Float32Array]\n   */\n\n  Oscillator.prototype._getRealImaginary = function (type, phase) {\n    var fftSize = 4096;\n    var periodicWaveSize = fftSize / 2;\n    var real = new Float32Array(periodicWaveSize);\n    var imag = new Float32Array(periodicWaveSize);\n    var partialCount = 1;\n\n    if (type === \"custom\") {\n      partialCount = this._partials.length + 1;\n      this._partialCount = this._partials.length;\n      periodicWaveSize = partialCount; // if the partial count is 0, don't bother doing any computation\n\n      if (this._partials.length === 0) {\n        return [real, imag];\n      }\n    } else {\n      var partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n\n      if (partial) {\n        partialCount = parseInt(partial[2], 10) + 1;\n        this._partialCount = parseInt(partial[2], 10);\n        type = partial[1];\n        partialCount = Math.max(partialCount, 2);\n        periodicWaveSize = partialCount;\n      } else {\n        this._partialCount = 0;\n      }\n\n      this._partials = [];\n    }\n\n    for (var n = 1; n < periodicWaveSize; ++n) {\n      var piFactor = 2 / (n * Math.PI);\n      var b = void 0;\n\n      switch (type) {\n        case \"sine\":\n          b = n <= partialCount ? 1 : 0;\n          this._partials[n - 1] = b;\n          break;\n\n        case \"square\":\n          b = n & 1 ? 2 * piFactor : 0;\n          this._partials[n - 1] = b;\n          break;\n\n        case \"sawtooth\":\n          b = piFactor * (n & 1 ? 1 : -1);\n          this._partials[n - 1] = b;\n          break;\n\n        case \"triangle\":\n          if (n & 1) {\n            b = 2 * (piFactor * piFactor) * (n - 1 >> 1 & 1 ? -1 : 1);\n          } else {\n            b = 0;\n          }\n\n          this._partials[n - 1] = b;\n          break;\n\n        case \"custom\":\n          b = this._partials[n - 1];\n          break;\n\n        default:\n          throw new TypeError(\"Oscillator: invalid type: \" + type);\n      }\n\n      if (b !== 0) {\n        real[n] = -b * Math.sin(phase * n);\n        imag[n] = b * Math.cos(phase * n);\n      } else {\n        real[n] = 0;\n        imag[n] = 0;\n      }\n    }\n\n    return [real, imag];\n  };\n  /**\n   * Compute the inverse FFT for a given phase.\n   */\n\n\n  Oscillator.prototype._inverseFFT = function (real, imag, phase) {\n    var sum = 0;\n    var len = real.length;\n\n    for (var i = 0; i < len; i++) {\n      sum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n    }\n\n    return sum;\n  };\n  /**\n   * Returns the initial value of the oscillator when stopped.\n   * E.g. a \"sine\" oscillator with phase = 90 would return an initial value of -1.\n   */\n\n\n  Oscillator.prototype.getInitialValue = function () {\n    var _a = tslib_1.__read(this._getRealImaginary(this._type, 0), 2),\n        real = _a[0],\n        imag = _a[1];\n\n    var maxValue = 0;\n    var twoPi = Math.PI * 2;\n    var testPositions = 32; // check for peaks in 16 places\n\n    for (var i = 0; i < testPositions; i++) {\n      maxValue = Math.max(this._inverseFFT(real, imag, i / testPositions * twoPi), maxValue);\n    }\n\n    return clamp(-this._inverseFFT(real, imag, this._phase) / maxValue, -1, 1);\n  };\n\n  Object.defineProperty(Oscillator.prototype, \"partials\", {\n    get: function () {\n      return this._partials.slice(0, this.partialCount);\n    },\n    set: function (partials) {\n      this._partials = partials;\n      this._partialCount = this._partials.length;\n\n      if (partials.length) {\n        this.type = \"custom\";\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Oscillator.prototype, \"phase\", {\n    get: function () {\n      return this._phase * (180 / Math.PI);\n    },\n    set: function (phase) {\n      this._phase = phase * Math.PI / 180; // reset the type\n\n      this.type = this._type;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Oscillator.prototype.asArray = function (length) {\n    if (length === void 0) {\n      length = 1024;\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        return [2\n        /*return*/\n        , generateWaveform(this, length)];\n      });\n    });\n  };\n\n  Oscillator.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    if (this._oscillator !== null) {\n      this._oscillator.dispose();\n    }\n\n    this._wave = undefined;\n    this.frequency.dispose();\n    this.detune.dispose();\n    return this;\n  };\n  /**\n   * Cache the periodic waves to avoid having to redo computations\n   */\n\n\n  Oscillator._periodicWaveCache = [];\n  return Oscillator;\n}(Source);\n\nexport { Oscillator };","map":{"version":3,"sources":["../../../../Tone/source/oscillator/Oscillator.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { deepEquals, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { ToneOscillatorNode } from \"./ToneOscillatorNode\";\nimport { assertRange } from \"../../core/util/Debug\";\nimport { clamp } from \"../../core/util/Math\";\n/**\n * Oscillator supports a number of features including\n * phase rotation, multiple oscillator types (see Oscillator.type),\n * and Transport syncing (see Oscillator.syncFrequency).\n *\n * @example\n * import { Oscillator } from \"tone\";\n * // make and start a 440hz sine tone\n * const osc = new Oscillator(440, \"sine\").toDestination().start();\n * @category Source\n */\nvar Oscillator = /** @class */ (function (_super) {\n    tslib_1.__extends(Oscillator, _super);\n    function Oscillator() {\n        var _this = _super.call(this, optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"])) || this;\n        _this.name = \"Oscillator\";\n        /**\n         * the main oscillator\n         */\n        _this._oscillator = null;\n        var options = optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n        _this.frequency = new Signal({\n            context: _this.context,\n            units: \"frequency\",\n            value: options.frequency,\n        });\n        readOnly(_this, \"frequency\");\n        _this.detune = new Signal({\n            context: _this.context,\n            units: \"cents\",\n            value: options.detune,\n        });\n        readOnly(_this, \"detune\");\n        _this._partials = options.partials;\n        _this._partialCount = options.partialCount;\n        _this._type = options.type;\n        if (options.partialCount && options.type !== \"custom\") {\n            _this._type = _this.baseType + options.partialCount.toString();\n        }\n        _this.phase = options.phase;\n        return _this;\n    }\n    Oscillator.getDefaults = function () {\n        return Object.assign(Source.getDefaults(), {\n            detune: 0,\n            frequency: 440,\n            partialCount: 0,\n            partials: [],\n            phase: 0,\n            type: \"sine\",\n        });\n    };\n    /**\n     * start the oscillator\n     */\n    Oscillator.prototype._start = function (time) {\n        var _this = this;\n        var computedTime = this.toSeconds(time);\n        // new oscillator with previous values\n        var oscillator = new ToneOscillatorNode({\n            context: this.context,\n            onended: function () { return _this.onstop(_this); },\n        });\n        this._oscillator = oscillator;\n        if (this._wave) {\n            this._oscillator.setPeriodicWave(this._wave);\n        }\n        else {\n            this._oscillator.type = this._type;\n        }\n        // connect the control signal to the oscillator frequency & detune\n        this._oscillator.connect(this.output);\n        this.frequency.connect(this._oscillator.frequency);\n        this.detune.connect(this._oscillator.detune);\n        // start the oscillator\n        this._oscillator.start(computedTime);\n    };\n    /**\n     * stop the oscillator\n     */\n    Oscillator.prototype._stop = function (time) {\n        var computedTime = this.toSeconds(time);\n        if (this._oscillator) {\n            this._oscillator.stop(computedTime);\n        }\n    };\n    /**\n     * Restart the oscillator. Does not stop the oscillator, but instead\n     * just cancels any scheduled 'stop' from being invoked.\n     */\n    Oscillator.prototype._restart = function (time) {\n        var computedTime = this.toSeconds(time);\n        this.log(\"restart\", computedTime);\n        if (this._oscillator) {\n            this._oscillator.cancelStop();\n        }\n        this._state.cancel(computedTime);\n        return this;\n    };\n    /**\n     * Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n     * will also affect the oscillators frequency.\n     * @example\n     * import { Oscillator, Transport } from \"tone\";\n     * const osc = new Oscillator().toDestination().start();\n     * osc.frequency.value = 440;\n     * // the ratio between the bpm and the frequency will be maintained\n     * osc.syncFrequency();\n     * // double the tempo\n     * Transport.bpm.value *= 2;\n     * // the frequency of the oscillator is doubled to 880\n     */\n    Oscillator.prototype.syncFrequency = function () {\n        this.context.transport.syncSignal(this.frequency);\n        return this;\n    };\n    /**\n     * Unsync the oscillator's frequency from the Transport.\n     * See Oscillator.syncFrequency\n     */\n    Oscillator.prototype.unsyncFrequency = function () {\n        this.context.transport.unsyncSignal(this.frequency);\n        return this;\n    };\n    /**\n     * Get a cached periodic wave. Avoids having to recompute\n     * the oscillator values when they have already been computed\n     * with the same values.\n     */\n    Oscillator.prototype._getCachedPeriodicWave = function () {\n        var _this = this;\n        if (this._type === \"custom\") {\n            var oscProps = Oscillator._periodicWaveCache.find(function (description) {\n                return description.phase === _this._phase &&\n                    deepEquals(description.partials, _this._partials);\n            });\n            return oscProps;\n        }\n        else {\n            var oscProps = Oscillator._periodicWaveCache.find(function (description) {\n                return description.type === _this._type &&\n                    description.phase === _this._phase;\n            });\n            this._partialCount = oscProps ? oscProps.partialCount : this._partialCount;\n            return oscProps;\n        }\n    };\n    Object.defineProperty(Oscillator.prototype, \"type\", {\n        get: function () {\n            return this._type;\n        },\n        set: function (type) {\n            this._type = type;\n            var isBasicType = [\"sine\", \"square\", \"sawtooth\", \"triangle\"].indexOf(type) !== -1;\n            if (this._phase === 0 && isBasicType) {\n                this._wave = undefined;\n                this._partialCount = 0;\n                // just go with the basic approach\n                if (this._oscillator !== null) {\n                    // already tested that it's a basic type\n                    this._oscillator.type = type;\n                }\n            }\n            else {\n                // first check if the value is cached\n                var cache = this._getCachedPeriodicWave();\n                if (isDefined(cache)) {\n                    var partials = cache.partials, wave = cache.wave;\n                    this._wave = wave;\n                    this._partials = partials;\n                    if (this._oscillator !== null) {\n                        this._oscillator.setPeriodicWave(this._wave);\n                    }\n                }\n                else {\n                    var _a = tslib_1.__read(this._getRealImaginary(type, this._phase), 2), real = _a[0], imag = _a[1];\n                    var periodicWave = this.context.createPeriodicWave(real, imag);\n                    this._wave = periodicWave;\n                    if (this._oscillator !== null) {\n                        this._oscillator.setPeriodicWave(this._wave);\n                    }\n                    // set the cache\n                    Oscillator._periodicWaveCache.push({\n                        imag: imag,\n                        partialCount: this._partialCount,\n                        partials: this._partials,\n                        phase: this._phase,\n                        real: real,\n                        type: this._type,\n                        wave: this._wave,\n                    });\n                    if (Oscillator._periodicWaveCache.length > 100) {\n                        Oscillator._periodicWaveCache.shift();\n                    }\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Oscillator.prototype, \"baseType\", {\n        get: function () {\n            return this._type.replace(this.partialCount.toString(), \"\");\n        },\n        set: function (baseType) {\n            if (this.partialCount && this._type !== \"custom\" && baseType !== \"custom\") {\n                this.type = baseType + this.partialCount;\n            }\n            else {\n                this.type = baseType;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Oscillator.prototype, \"partialCount\", {\n        get: function () {\n            return this._partialCount;\n        },\n        set: function (p) {\n            assertRange(p, 0);\n            var type = this._type;\n            var partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(this._type);\n            if (partial) {\n                type = partial[1];\n            }\n            if (this._type !== \"custom\") {\n                if (p === 0) {\n                    this.type = type;\n                }\n                else {\n                    this.type = type + p.toString();\n                }\n            }\n            else {\n                // extend or shorten the partials array\n                var fullPartials_1 = new Float32Array(p);\n                // copy over the partials array\n                this._partials.forEach(function (v, i) { return fullPartials_1[i] = v; });\n                this._partials = Array.from(fullPartials_1);\n                this.type = this._type;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Returns the real and imaginary components based\n     * on the oscillator type.\n     * @returns [real: Float32Array, imaginary: Float32Array]\n     */\n    Oscillator.prototype._getRealImaginary = function (type, phase) {\n        var fftSize = 4096;\n        var periodicWaveSize = fftSize / 2;\n        var real = new Float32Array(periodicWaveSize);\n        var imag = new Float32Array(periodicWaveSize);\n        var partialCount = 1;\n        if (type === \"custom\") {\n            partialCount = this._partials.length + 1;\n            this._partialCount = this._partials.length;\n            periodicWaveSize = partialCount;\n            // if the partial count is 0, don't bother doing any computation\n            if (this._partials.length === 0) {\n                return [real, imag];\n            }\n        }\n        else {\n            var partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n            if (partial) {\n                partialCount = parseInt(partial[2], 10) + 1;\n                this._partialCount = parseInt(partial[2], 10);\n                type = partial[1];\n                partialCount = Math.max(partialCount, 2);\n                periodicWaveSize = partialCount;\n            }\n            else {\n                this._partialCount = 0;\n            }\n            this._partials = [];\n        }\n        for (var n = 1; n < periodicWaveSize; ++n) {\n            var piFactor = 2 / (n * Math.PI);\n            var b = void 0;\n            switch (type) {\n                case \"sine\":\n                    b = (n <= partialCount) ? 1 : 0;\n                    this._partials[n - 1] = b;\n                    break;\n                case \"square\":\n                    b = (n & 1) ? 2 * piFactor : 0;\n                    this._partials[n - 1] = b;\n                    break;\n                case \"sawtooth\":\n                    b = piFactor * ((n & 1) ? 1 : -1);\n                    this._partials[n - 1] = b;\n                    break;\n                case \"triangle\":\n                    if (n & 1) {\n                        b = 2 * (piFactor * piFactor) * ((((n - 1) >> 1) & 1) ? -1 : 1);\n                    }\n                    else {\n                        b = 0;\n                    }\n                    this._partials[n - 1] = b;\n                    break;\n                case \"custom\":\n                    b = this._partials[n - 1];\n                    break;\n                default:\n                    throw new TypeError(\"Oscillator: invalid type: \" + type);\n            }\n            if (b !== 0) {\n                real[n] = -b * Math.sin(phase * n);\n                imag[n] = b * Math.cos(phase * n);\n            }\n            else {\n                real[n] = 0;\n                imag[n] = 0;\n            }\n        }\n        return [real, imag];\n    };\n    /**\n     * Compute the inverse FFT for a given phase.\n     */\n    Oscillator.prototype._inverseFFT = function (real, imag, phase) {\n        var sum = 0;\n        var len = real.length;\n        for (var i = 0; i < len; i++) {\n            sum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n        }\n        return sum;\n    };\n    /**\n     * Returns the initial value of the oscillator when stopped.\n     * E.g. a \"sine\" oscillator with phase = 90 would return an initial value of -1.\n     */\n    Oscillator.prototype.getInitialValue = function () {\n        var _a = tslib_1.__read(this._getRealImaginary(this._type, 0), 2), real = _a[0], imag = _a[1];\n        var maxValue = 0;\n        var twoPi = Math.PI * 2;\n        var testPositions = 32;\n        // check for peaks in 16 places\n        for (var i = 0; i < testPositions; i++) {\n            maxValue = Math.max(this._inverseFFT(real, imag, (i / testPositions) * twoPi), maxValue);\n        }\n        return clamp(-this._inverseFFT(real, imag, this._phase) / maxValue, -1, 1);\n    };\n    Object.defineProperty(Oscillator.prototype, \"partials\", {\n        get: function () {\n            return this._partials.slice(0, this.partialCount);\n        },\n        set: function (partials) {\n            this._partials = partials;\n            this._partialCount = this._partials.length;\n            if (partials.length) {\n                this.type = \"custom\";\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Oscillator.prototype, \"phase\", {\n        get: function () {\n            return this._phase * (180 / Math.PI);\n        },\n        set: function (phase) {\n            this._phase = phase * Math.PI / 180;\n            // reset the type\n            this.type = this._type;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Oscillator.prototype.asArray = function (length) {\n        if (length === void 0) { length = 1024; }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            return tslib_1.__generator(this, function (_a) {\n                return [2 /*return*/, generateWaveform(this, length)];\n            });\n        });\n    };\n    Oscillator.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        if (this._oscillator !== null) {\n            this._oscillator.dispose();\n        }\n        this._wave = undefined;\n        this.frequency.dispose();\n        this.detune.dispose();\n        return this;\n    };\n    /**\n     * Cache the periodic waves to avoid having to redo computations\n     */\n    Oscillator._periodicWaveCache = [];\n    return Oscillator;\n}(Source));\nexport { Oscillator };\n//# sourceMappingURL=Oscillator.js.map"]},"metadata":{},"sourceType":"module"}