{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { Loop } from \"./Loop\";\nimport { PatternGenerator } from \"./PatternGenerator\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\n/**\n * Pattern arpeggiates between the given notes\n * in a number of patterns.\n * @example\n * import { Pattern } from \"tone\";\n * const pattern = new Pattern((time, note) => {\n * \t// the order of the notes passed in depends on the pattern\n * }, [\"C2\", \"D4\", \"E5\", \"A6\"], \"upDown\");\n * @category Event\n */\n\nvar Pattern =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Pattern, _super);\n\n  function Pattern() {\n    var _this = _super.call(this, optionsFromArguments(Pattern.getDefaults(), arguments, [\"callback\", \"values\", \"pattern\"])) || this;\n\n    _this.name = \"Pattern\";\n    var options = optionsFromArguments(Pattern.getDefaults(), arguments, [\"callback\", \"values\", \"pattern\"]);\n    _this.callback = options.callback;\n    _this._values = options.values;\n    _this._pattern = PatternGenerator(options.values, options.pattern);\n    _this._type = options.pattern;\n    return _this;\n  }\n\n  Pattern.getDefaults = function () {\n    return Object.assign(Loop.getDefaults(), {\n      pattern: \"up\",\n      values: [],\n      callback: noOp\n    });\n  };\n  /**\n   * Internal function called when the notes should be called\n   */\n\n\n  Pattern.prototype._tick = function (time) {\n    var value = this._pattern.next();\n\n    this._value = value.value;\n    this.callback(time, this._value);\n  };\n\n  Object.defineProperty(Pattern.prototype, \"values\", {\n    /**\n     * The array of events.\n     */\n    get: function () {\n      return this._values;\n    },\n    set: function (val) {\n      this._values = val; // reset the pattern\n\n      this.pattern = this._type;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Pattern.prototype, \"value\", {\n    /**\n     * The current value of the pattern.\n     */\n    get: function () {\n      return this._value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Pattern.prototype, \"pattern\", {\n    /**\n     * The pattern type. See Tone.CtrlPattern for the full list of patterns.\n     */\n    get: function () {\n      return this._type;\n    },\n    set: function (pattern) {\n      this._type = pattern;\n      this._pattern = PatternGenerator(this._values, this._type);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Pattern;\n}(Loop);\n\nexport { Pattern };","map":{"version":3,"sources":["../../../Tone/event/Pattern.ts"],"names":[],"mappings":";AAAA,SAAS,IAAT,QAAkC,QAAlC;AACA,SAAS,gBAAT,QAA8C,oBAA9C;AAEA,SAAS,oBAAT,QAAqC,uBAArC;AAEA,SAAS,IAAT,QAAqB,wBAArB;AAQA;;;;;;;;;;;AAUA,IAAA,OAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAwC,EAAA,OAAA,CAAA,SAAA,CAAA,OAAA,EAAA,MAAA;;AAwCvC,WAAA,OAAA,GAAA;AAAA,QAAA,KAAA,GAEC,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,oBAAoB,CAAC,OAAO,CAAC,WAAR,EAAD,EAAwB,SAAxB,EAAmC,CAAC,UAAD,EAAa,QAAb,EAAuB,SAAvB,CAAnC,CAA1B,KAAgG,IAFjG;;AAtCS,IAAA,KAAA,CAAA,IAAA,GAAe,SAAf;AAyCR,QAAM,OAAO,GAAG,oBAAoB,CAAC,OAAO,CAAC,WAAR,EAAD,EAAwB,SAAxB,EAAmC,CAAC,UAAD,EAAa,QAAb,EAAuB,SAAvB,CAAnC,CAApC;AAEA,IAAA,KAAI,CAAC,QAAL,GAAgB,OAAO,CAAC,QAAxB;AACA,IAAA,KAAI,CAAC,OAAL,GAAe,OAAO,CAAC,MAAvB;AACA,IAAA,KAAI,CAAC,QAAL,GAAgB,gBAAgB,CAAC,OAAO,CAAC,MAAT,EAAiB,OAAO,CAAC,OAAzB,CAAhC;AACA,IAAA,KAAI,CAAC,KAAL,GAAa,OAAO,CAAC,OAArB;;AACA;;AAEM,EAAA,OAAA,CAAA,WAAA,GAAP,YAAA;AACC,WAAO,MAAM,CAAC,MAAP,CAAc,IAAI,CAAC,WAAL,EAAd,EAAkC;AACxC,MAAA,OAAO,EAAE,IAD+B;AAExC,MAAA,MAAM,EAAE,EAFgC;AAGxC,MAAA,QAAQ,EAAE;AAH8B,KAAlC,CAAP;AAKA,GANM;AAQP;;;;;AAGU,EAAA,OAAA,CAAA,SAAA,CAAA,KAAA,GAAV,UAAgB,IAAhB,EAA6B;AAC5B,QAAM,KAAK,GAAG,KAAK,QAAL,CAAc,IAAd,EAAd;;AACA,SAAK,MAAL,GAAc,KAAK,CAAC,KAApB;AACA,SAAK,QAAL,CAAc,IAAd,EAAoB,KAAK,MAAzB;AACA,GAJS;;AASV,EAAA,MAAA,CAAA,cAAA,CAAI,OAAA,CAAA,SAAJ,EAAI,QAAJ,EAAU;AAHV;;;SAGA,YAAA;AACC,aAAO,KAAK,OAAZ;AACA,KAFS;SAGV,UAAW,GAAX,EAAc;AACb,WAAK,OAAL,GAAe,GAAf,CADa,CAEb;;AACA,WAAK,OAAL,GAAe,KAAK,KAApB;AACA,KAPS;oBAAA;;AAAA,GAAV;AAYA,EAAA,MAAA,CAAA,cAAA,CAAI,OAAA,CAAA,SAAJ,EAAI,OAAJ,EAAS;AAHT;;;SAGA,YAAA;AACC,aAAO,KAAK,MAAZ;AACA,KAFQ;oBAAA;;AAAA,GAAT;AAOA,EAAA,MAAA,CAAA,cAAA,CAAI,OAAA,CAAA,SAAJ,EAAI,SAAJ,EAAW;AAHX;;;SAGA,YAAA;AACC,aAAO,KAAK,KAAZ;AACA,KAFU;SAGX,UAAY,OAAZ,EAAmB;AAClB,WAAK,KAAL,GAAa,OAAb;AACA,WAAK,QAAL,GAAgB,gBAAgB,CAAC,KAAK,OAAN,EAAe,KAAK,KAApB,CAAhC;AACA,KANU;oBAAA;;AAAA,GAAX;AAOD,SAAA,OAAA;AAAC,CAjGD,CAAwC,IAAxC,CAAA","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { Loop } from \"./Loop\";\nimport { PatternGenerator } from \"./PatternGenerator\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\n/**\n * Pattern arpeggiates between the given notes\n * in a number of patterns.\n * @example\n * import { Pattern } from \"tone\";\n * const pattern = new Pattern((time, note) => {\n * \t// the order of the notes passed in depends on the pattern\n * }, [\"C2\", \"D4\", \"E5\", \"A6\"], \"upDown\");\n * @category Event\n */\nvar Pattern = /** @class */ (function (_super) {\n    tslib_1.__extends(Pattern, _super);\n    function Pattern() {\n        var _this = _super.call(this, optionsFromArguments(Pattern.getDefaults(), arguments, [\"callback\", \"values\", \"pattern\"])) || this;\n        _this.name = \"Pattern\";\n        var options = optionsFromArguments(Pattern.getDefaults(), arguments, [\"callback\", \"values\", \"pattern\"]);\n        _this.callback = options.callback;\n        _this._values = options.values;\n        _this._pattern = PatternGenerator(options.values, options.pattern);\n        _this._type = options.pattern;\n        return _this;\n    }\n    Pattern.getDefaults = function () {\n        return Object.assign(Loop.getDefaults(), {\n            pattern: \"up\",\n            values: [],\n            callback: noOp,\n        });\n    };\n    /**\n     * Internal function called when the notes should be called\n     */\n    Pattern.prototype._tick = function (time) {\n        var value = this._pattern.next();\n        this._value = value.value;\n        this.callback(time, this._value);\n    };\n    Object.defineProperty(Pattern.prototype, \"values\", {\n        /**\n         * The array of events.\n         */\n        get: function () {\n            return this._values;\n        },\n        set: function (val) {\n            this._values = val;\n            // reset the pattern\n            this.pattern = this._type;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Pattern.prototype, \"value\", {\n        /**\n         * The current value of the pattern.\n         */\n        get: function () {\n            return this._value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Pattern.prototype, \"pattern\", {\n        /**\n         * The pattern type. See Tone.CtrlPattern for the full list of patterns.\n         */\n        get: function () {\n            return this._type;\n        },\n        set: function (pattern) {\n            this._type = pattern;\n            this._pattern = PatternGenerator(this._values, this._type);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return Pattern;\n}(Loop));\nexport { Pattern };\n//# sourceMappingURL=Pattern.js.map"]},"metadata":{},"sourceType":"module"}