{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { assert } from \"../core/util/Debug\";\nimport { clamp } from \"../core/util/Math\";\n/**\n * Start at the first value and go up to the last\n */\n\nfunction upPatternGen(values) {\n  var index;\n  return tslib_1.__generator(this, function (_a) {\n    switch (_a.label) {\n      case 0:\n        index = 0;\n        _a.label = 1;\n\n      case 1:\n        if (!(index < values.length)) return [3\n        /*break*/\n        , 3];\n        index = clampToArraySize(index, values);\n        return [4\n        /*yield*/\n        , values[index]];\n\n      case 2:\n        _a.sent();\n\n        index++;\n        return [3\n        /*break*/\n        , 1];\n\n      case 3:\n        return [2\n        /*return*/\n        ];\n    }\n  });\n}\n/**\n * Start at the last value and go down to 0\n */\n\n\nfunction downPatternGen(values) {\n  var index;\n  return tslib_1.__generator(this, function (_a) {\n    switch (_a.label) {\n      case 0:\n        index = values.length - 1;\n        _a.label = 1;\n\n      case 1:\n        if (!(index >= 0)) return [3\n        /*break*/\n        , 3];\n        index = clampToArraySize(index, values);\n        return [4\n        /*yield*/\n        , values[index]];\n\n      case 2:\n        _a.sent();\n\n        index--;\n        return [3\n        /*break*/\n        , 1];\n\n      case 3:\n        return [2\n        /*return*/\n        ];\n    }\n  });\n}\n/**\n * Infinitely yield the generator\n */\n\n\nfunction infiniteGen(values, gen) {\n  return tslib_1.__generator(this, function (_a) {\n    switch (_a.label) {\n      case 0:\n        if (!true) return [3\n        /*break*/\n        , 2];\n        return [5\n        /*yield**/\n        , tslib_1.__values(gen(values))];\n\n      case 1:\n        _a.sent();\n\n        return [3\n        /*break*/\n        , 0];\n\n      case 2:\n        return [2\n        /*return*/\n        ];\n    }\n  });\n}\n/**\n * Make sure that the index is in the given range\n */\n\n\nfunction clampToArraySize(index, values) {\n  return clamp(index, 0, values.length - 1);\n}\n/**\n * Alternate between two generators\n */\n\n\nfunction alternatingGenerator(values, directionUp) {\n  var index;\n  return tslib_1.__generator(this, function (_a) {\n    switch (_a.label) {\n      case 0:\n        index = directionUp ? 0 : values.length - 1;\n        _a.label = 1;\n\n      case 1:\n        if (!true) return [3\n        /*break*/\n        , 3];\n        index = clampToArraySize(index, values);\n        return [4\n        /*yield*/\n        , values[index]];\n\n      case 2:\n        _a.sent();\n\n        if (directionUp) {\n          index++;\n\n          if (index >= values.length - 1) {\n            directionUp = false;\n          }\n        } else {\n          index--;\n\n          if (index <= 0) {\n            directionUp = true;\n          }\n        }\n\n        return [3\n        /*break*/\n        , 1];\n\n      case 3:\n        return [2\n        /*return*/\n        ];\n    }\n  });\n}\n/**\n * Starting from the bottom move up 2, down 1\n */\n\n\nfunction jumpUp(values) {\n  var index, stepIndex;\n  return tslib_1.__generator(this, function (_a) {\n    switch (_a.label) {\n      case 0:\n        index = 0;\n        stepIndex = 0;\n        _a.label = 1;\n\n      case 1:\n        if (!(index < values.length)) return [3\n        /*break*/\n        , 3];\n        index = clampToArraySize(index, values);\n        return [4\n        /*yield*/\n        , values[index]];\n\n      case 2:\n        _a.sent();\n\n        stepIndex++;\n        index += stepIndex % 2 ? 2 : -1;\n        return [3\n        /*break*/\n        , 1];\n\n      case 3:\n        return [2\n        /*return*/\n        ];\n    }\n  });\n}\n/**\n * Starting from the top move down 2, up 1\n */\n\n\nfunction jumpDown(values) {\n  var index, stepIndex;\n  return tslib_1.__generator(this, function (_a) {\n    switch (_a.label) {\n      case 0:\n        index = values.length - 1;\n        stepIndex = 0;\n        _a.label = 1;\n\n      case 1:\n        if (!(index >= 0)) return [3\n        /*break*/\n        , 3];\n        index = clampToArraySize(index, values);\n        return [4\n        /*yield*/\n        , values[index]];\n\n      case 2:\n        _a.sent();\n\n        stepIndex++;\n        index += stepIndex % 2 ? -2 : 1;\n        return [3\n        /*break*/\n        , 1];\n\n      case 3:\n        return [2\n        /*return*/\n        ];\n    }\n  });\n}\n/**\n * Choose a random index each time\n */\n\n\nfunction randomGen(values) {\n  var randomIndex;\n  return tslib_1.__generator(this, function (_a) {\n    switch (_a.label) {\n      case 0:\n        if (!true) return [3\n        /*break*/\n        , 2];\n        randomIndex = Math.floor(Math.random() * values.length);\n        return [4\n        /*yield*/\n        , values[randomIndex]];\n\n      case 1:\n        _a.sent();\n\n        return [3\n        /*break*/\n        , 0];\n\n      case 2:\n        return [2\n        /*return*/\n        ];\n    }\n  });\n}\n/**\n * Randomly go through all of the values once before choosing a new random order\n */\n\n\nfunction randomOnce(values) {\n  var copy, i, randVal, index;\n  return tslib_1.__generator(this, function (_a) {\n    switch (_a.label) {\n      case 0:\n        copy = [];\n\n        for (i = 0; i < values.length; i++) {\n          copy.push(i);\n        }\n\n        _a.label = 1;\n\n      case 1:\n        if (!(copy.length > 0)) return [3\n        /*break*/\n        , 3];\n        randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);\n        index = clampToArraySize(randVal[0], values);\n        return [4\n        /*yield*/\n        , values[index]];\n\n      case 2:\n        _a.sent();\n\n        return [3\n        /*break*/\n        , 1];\n\n      case 3:\n        return [2\n        /*return*/\n        ];\n    }\n  });\n}\n/**\n * PatternGenerator returns a generator which will iterate over the given array\n * of values and yield the items according to the passed in pattern\n * @param values An array of values to iterate over\n * @param pattern The name of the pattern use when iterating over\n * @param index Where to start in the offset of the values array\n */\n\n\nexport function PatternGenerator(values, pattern, index) {\n  var _a;\n\n  if (pattern === void 0) {\n    pattern = \"up\";\n  }\n\n  if (index === void 0) {\n    index = 0;\n  }\n\n  return tslib_1.__generator(this, function (_b) {\n    switch (_b.label) {\n      case 0:\n        // safeguards\n        assert(values.length > 0, \"The array must have more than one value in it\");\n        _a = pattern;\n\n        switch (_a) {\n          case \"up\":\n            return [3\n            /*break*/\n            , 1];\n\n          case \"down\":\n            return [3\n            /*break*/\n            , 3];\n\n          case \"upDown\":\n            return [3\n            /*break*/\n            , 5];\n\n          case \"downUp\":\n            return [3\n            /*break*/\n            , 7];\n\n          case \"alternateUp\":\n            return [3\n            /*break*/\n            , 9];\n\n          case \"alternateDown\":\n            return [3\n            /*break*/\n            , 11];\n\n          case \"random\":\n            return [3\n            /*break*/\n            , 13];\n\n          case \"randomOnce\":\n            return [3\n            /*break*/\n            , 15];\n        }\n\n        return [3\n        /*break*/\n        , 17];\n\n      case 1:\n        return [5\n        /*yield**/\n        , tslib_1.__values(infiniteGen(values, upPatternGen))];\n\n      case 2:\n        _b.sent();\n\n        _b.label = 3;\n\n      case 3:\n        return [5\n        /*yield**/\n        , tslib_1.__values(infiniteGen(values, downPatternGen))];\n\n      case 4:\n        _b.sent();\n\n        _b.label = 5;\n\n      case 5:\n        return [5\n        /*yield**/\n        , tslib_1.__values(alternatingGenerator(values, true))];\n\n      case 6:\n        _b.sent();\n\n        _b.label = 7;\n\n      case 7:\n        return [5\n        /*yield**/\n        , tslib_1.__values(alternatingGenerator(values, false))];\n\n      case 8:\n        _b.sent();\n\n        _b.label = 9;\n\n      case 9:\n        return [5\n        /*yield**/\n        , tslib_1.__values(infiniteGen(values, jumpUp))];\n\n      case 10:\n        _b.sent();\n\n        _b.label = 11;\n\n      case 11:\n        return [5\n        /*yield**/\n        , tslib_1.__values(infiniteGen(values, jumpDown))];\n\n      case 12:\n        _b.sent();\n\n        _b.label = 13;\n\n      case 13:\n        return [5\n        /*yield**/\n        , tslib_1.__values(randomGen(values))];\n\n      case 14:\n        _b.sent();\n\n        _b.label = 15;\n\n      case 15:\n        return [5\n        /*yield**/\n        , tslib_1.__values(infiniteGen(values, randomOnce))];\n\n      case 16:\n        _b.sent();\n\n        _b.label = 17;\n\n      case 17:\n        return [2\n        /*return*/\n        ];\n    }\n  });\n}","map":{"version":3,"sources":["../../../Tone/event/PatternGenerator.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { assert } from \"../core/util/Debug\";\nimport { clamp } from \"../core/util/Math\";\n/**\n * Start at the first value and go up to the last\n */\nfunction upPatternGen(values) {\n    var index;\n    return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                index = 0;\n                _a.label = 1;\n            case 1:\n                if (!(index < values.length)) return [3 /*break*/, 3];\n                index = clampToArraySize(index, values);\n                return [4 /*yield*/, values[index]];\n            case 2:\n                _a.sent();\n                index++;\n                return [3 /*break*/, 1];\n            case 3: return [2 /*return*/];\n        }\n    });\n}\n/**\n * Start at the last value and go down to 0\n */\nfunction downPatternGen(values) {\n    var index;\n    return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                index = values.length - 1;\n                _a.label = 1;\n            case 1:\n                if (!(index >= 0)) return [3 /*break*/, 3];\n                index = clampToArraySize(index, values);\n                return [4 /*yield*/, values[index]];\n            case 2:\n                _a.sent();\n                index--;\n                return [3 /*break*/, 1];\n            case 3: return [2 /*return*/];\n        }\n    });\n}\n/**\n * Infinitely yield the generator\n */\nfunction infiniteGen(values, gen) {\n    return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                if (!true) return [3 /*break*/, 2];\n                return [5 /*yield**/, tslib_1.__values(gen(values))];\n            case 1:\n                _a.sent();\n                return [3 /*break*/, 0];\n            case 2: return [2 /*return*/];\n        }\n    });\n}\n/**\n * Make sure that the index is in the given range\n */\nfunction clampToArraySize(index, values) {\n    return clamp(index, 0, values.length - 1);\n}\n/**\n * Alternate between two generators\n */\nfunction alternatingGenerator(values, directionUp) {\n    var index;\n    return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                index = directionUp ? 0 : values.length - 1;\n                _a.label = 1;\n            case 1:\n                if (!true) return [3 /*break*/, 3];\n                index = clampToArraySize(index, values);\n                return [4 /*yield*/, values[index]];\n            case 2:\n                _a.sent();\n                if (directionUp) {\n                    index++;\n                    if (index >= values.length - 1) {\n                        directionUp = false;\n                    }\n                }\n                else {\n                    index--;\n                    if (index <= 0) {\n                        directionUp = true;\n                    }\n                }\n                return [3 /*break*/, 1];\n            case 3: return [2 /*return*/];\n        }\n    });\n}\n/**\n * Starting from the bottom move up 2, down 1\n */\nfunction jumpUp(values) {\n    var index, stepIndex;\n    return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                index = 0;\n                stepIndex = 0;\n                _a.label = 1;\n            case 1:\n                if (!(index < values.length)) return [3 /*break*/, 3];\n                index = clampToArraySize(index, values);\n                return [4 /*yield*/, values[index]];\n            case 2:\n                _a.sent();\n                stepIndex++;\n                index += (stepIndex % 2 ? 2 : -1);\n                return [3 /*break*/, 1];\n            case 3: return [2 /*return*/];\n        }\n    });\n}\n/**\n * Starting from the top move down 2, up 1\n */\nfunction jumpDown(values) {\n    var index, stepIndex;\n    return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                index = values.length - 1;\n                stepIndex = 0;\n                _a.label = 1;\n            case 1:\n                if (!(index >= 0)) return [3 /*break*/, 3];\n                index = clampToArraySize(index, values);\n                return [4 /*yield*/, values[index]];\n            case 2:\n                _a.sent();\n                stepIndex++;\n                index += (stepIndex % 2 ? -2 : 1);\n                return [3 /*break*/, 1];\n            case 3: return [2 /*return*/];\n        }\n    });\n}\n/**\n * Choose a random index each time\n */\nfunction randomGen(values) {\n    var randomIndex;\n    return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                if (!true) return [3 /*break*/, 2];\n                randomIndex = Math.floor(Math.random() * values.length);\n                return [4 /*yield*/, values[randomIndex]];\n            case 1:\n                _a.sent();\n                return [3 /*break*/, 0];\n            case 2: return [2 /*return*/];\n        }\n    });\n}\n/**\n * Randomly go through all of the values once before choosing a new random order\n */\nfunction randomOnce(values) {\n    var copy, i, randVal, index;\n    return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                copy = [];\n                for (i = 0; i < values.length; i++) {\n                    copy.push(i);\n                }\n                _a.label = 1;\n            case 1:\n                if (!(copy.length > 0)) return [3 /*break*/, 3];\n                randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);\n                index = clampToArraySize(randVal[0], values);\n                return [4 /*yield*/, values[index]];\n            case 2:\n                _a.sent();\n                return [3 /*break*/, 1];\n            case 3: return [2 /*return*/];\n        }\n    });\n}\n/**\n * PatternGenerator returns a generator which will iterate over the given array\n * of values and yield the items according to the passed in pattern\n * @param values An array of values to iterate over\n * @param pattern The name of the pattern use when iterating over\n * @param index Where to start in the offset of the values array\n */\nexport function PatternGenerator(values, pattern, index) {\n    var _a;\n    if (pattern === void 0) { pattern = \"up\"; }\n    if (index === void 0) { index = 0; }\n    return tslib_1.__generator(this, function (_b) {\n        switch (_b.label) {\n            case 0:\n                // safeguards\n                assert(values.length > 0, \"The array must have more than one value in it\");\n                _a = pattern;\n                switch (_a) {\n                    case \"up\": return [3 /*break*/, 1];\n                    case \"down\": return [3 /*break*/, 3];\n                    case \"upDown\": return [3 /*break*/, 5];\n                    case \"downUp\": return [3 /*break*/, 7];\n                    case \"alternateUp\": return [3 /*break*/, 9];\n                    case \"alternateDown\": return [3 /*break*/, 11];\n                    case \"random\": return [3 /*break*/, 13];\n                    case \"randomOnce\": return [3 /*break*/, 15];\n                }\n                return [3 /*break*/, 17];\n            case 1: return [5 /*yield**/, tslib_1.__values(infiniteGen(values, upPatternGen))];\n            case 2:\n                _b.sent();\n                _b.label = 3;\n            case 3: return [5 /*yield**/, tslib_1.__values(infiniteGen(values, downPatternGen))];\n            case 4:\n                _b.sent();\n                _b.label = 5;\n            case 5: return [5 /*yield**/, tslib_1.__values(alternatingGenerator(values, true))];\n            case 6:\n                _b.sent();\n                _b.label = 7;\n            case 7: return [5 /*yield**/, tslib_1.__values(alternatingGenerator(values, false))];\n            case 8:\n                _b.sent();\n                _b.label = 9;\n            case 9: return [5 /*yield**/, tslib_1.__values(infiniteGen(values, jumpUp))];\n            case 10:\n                _b.sent();\n                _b.label = 11;\n            case 11: return [5 /*yield**/, tslib_1.__values(infiniteGen(values, jumpDown))];\n            case 12:\n                _b.sent();\n                _b.label = 13;\n            case 13: return [5 /*yield**/, tslib_1.__values(randomGen(values))];\n            case 14:\n                _b.sent();\n                _b.label = 15;\n            case 15: return [5 /*yield**/, tslib_1.__values(infiniteGen(values, randomOnce))];\n            case 16:\n                _b.sent();\n                _b.label = 17;\n            case 17: return [2 /*return*/];\n        }\n    });\n}\n//# sourceMappingURL=PatternGenerator.js.map"]},"metadata":{},"sourceType":"module"}