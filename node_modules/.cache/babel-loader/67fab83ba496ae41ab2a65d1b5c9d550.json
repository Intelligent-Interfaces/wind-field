{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { MidiClass } from \"../core/type/Midi\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument } from \"./Instrument\";\nimport { Synth } from \"./Synth\";\nimport { assert, warn } from \"../core/util/Debug\";\n/**\n * PolySynth handles voice creation and allocation for any\n * instruments passed in as the second paramter. PolySynth is\n * not a synthesizer by itself, it merely manages voices of\n * one of the other types of synths, allowing any of the\n * monophonic synthesizers to be polyphonic.\n *\n * @example\n * import { PolySynth } from \"tone\";\n * const synth = new PolySynth().toDestination();\n * // set the attributes across all the voices using 'set'\n * synth.set({ detune: -1200 });\n * // play a chord\n * synth.triggerAttackRelease([\"C4\", \"E4\", \"A4\"], 1);\n * @category Instrument\n */\n\nvar PolySynth =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(PolySynth, _super);\n\n  function PolySynth() {\n    var _this = _super.call(this, optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"])) || this;\n\n    _this.name = \"PolySynth\";\n    /**\n     * The voices which are not currently in use\n     */\n\n    _this._availableVoices = [];\n    /**\n     * The currently active voices\n     */\n\n    _this._activeVoices = [];\n    /**\n     * All of the allocated voices for this synth.\n     */\n\n    _this._voices = [];\n    /**\n     * The GC timeout. Held so that it could be cancelled when the node is disposed.\n     */\n\n    _this._gcTimeout = -1;\n    /**\n     * A moving average of the number of active voices\n     */\n\n    _this._averageActiveVoices = 0;\n    var options = optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]); // check against the old API (pre 14.3.0)\n\n    assert(!isNumber(options.voice), \"DEPRECATED: The polyphony count is no longer the first argument.\");\n    var defaults = options.voice.getDefaults();\n    _this.options = Object.assign(defaults, options.options);\n    _this.voice = options.voice;\n    _this.maxPolyphony = options.maxPolyphony; // create the first voice\n\n    _this._dummyVoice = _this._getNextAvailableVoice(); // remove it from the voices list\n\n    var index = _this._voices.indexOf(_this._dummyVoice);\n\n    _this._voices.splice(index, 1); // kick off the GC interval\n\n\n    _this._gcTimeout = _this.context.setInterval(_this._collectGarbage.bind(_this), 1);\n    return _this;\n  }\n\n  PolySynth.getDefaults = function () {\n    return Object.assign(Instrument.getDefaults(), {\n      maxPolyphony: 32,\n      options: {},\n      voice: Synth\n    });\n  };\n\n  Object.defineProperty(PolySynth.prototype, \"activeVoices\", {\n    /**\n     * The number of active voices.\n     */\n    get: function () {\n      return this._activeVoices.length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Invoked when the source is done making sound, so that it can be\n   * readded to the pool of available voices\n   */\n\n  PolySynth.prototype._makeVoiceAvailable = function (voice) {\n    this._availableVoices.push(voice); // remove the midi note from 'active voices'\n\n\n    var activeVoiceIndex = this._activeVoices.findIndex(function (e) {\n      return e.voice === voice;\n    });\n\n    this._activeVoices.splice(activeVoiceIndex, 1);\n  };\n  /**\n   * Get an available voice from the pool of available voices.\n   * If one is not available and the maxPolyphony limit is reached,\n   * steal a voice, otherwise return null.\n   */\n\n\n  PolySynth.prototype._getNextAvailableVoice = function () {\n    // if there are available voices, return the first one\n    if (this._availableVoices.length) {\n      return this._availableVoices.shift();\n    } else if (this._voices.length < this.maxPolyphony) {\n      // otherwise if there is still more maxPolyphony, make a new voice\n      var voice = new this.voice(Object.assign(this.options, {\n        context: this.context,\n        onsilence: this._makeVoiceAvailable.bind(this)\n      }));\n      voice.connect(this.output);\n\n      this._voices.push(voice);\n\n      return voice;\n    } else {\n      warn(\"Max polyphony exceeded. Note dropped.\");\n    }\n  };\n  /**\n   * Occasionally check if there are any allocated voices which can be cleaned up.\n   */\n\n\n  PolySynth.prototype._collectGarbage = function () {\n    this._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices);\n\n    if (this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {\n      // take off an available note\n      var firstAvail = this._availableVoices.shift();\n\n      var index = this._voices.indexOf(firstAvail);\n\n      this._voices.splice(index, 1);\n\n      if (!this.context.isOffline) {\n        firstAvail.dispose();\n      }\n    }\n  };\n  /**\n   * Internal method which triggers the attack\n   */\n\n\n  PolySynth.prototype._triggerAttack = function (notes, time, velocity) {\n    var _this = this;\n\n    notes.forEach(function (note) {\n      var midiNote = new MidiClass(_this.context, note).toMidi();\n\n      var voice = _this._getNextAvailableVoice();\n\n      if (voice) {\n        voice.triggerAttack(note, time, velocity);\n\n        _this._activeVoices.push({\n          midi: midiNote,\n          voice: voice,\n          released: false\n        });\n\n        _this.log(\"triggerAttack\", note, time);\n      }\n    });\n  };\n  /**\n   * Internal method which triggers the release\n   */\n\n\n  PolySynth.prototype._triggerRelease = function (notes, time) {\n    var _this = this;\n\n    notes.forEach(function (note) {\n      var midiNote = new MidiClass(_this.context, note).toMidi();\n\n      var event = _this._activeVoices.find(function (_a) {\n        var midi = _a.midi,\n            released = _a.released;\n        return midi === midiNote && !released;\n      });\n\n      if (event) {\n        // trigger release on that note\n        event.voice.triggerRelease(time); // mark it as released\n\n        event.released = true;\n\n        _this.log(\"triggerRelease\", note, time);\n      }\n    });\n  };\n  /**\n   * Schedule the attack/release events. If the time is in the future, then it should set a timeout\n   * to wait for just-in-time scheduling\n   */\n\n\n  PolySynth.prototype._scheduleEvent = function (type, notes, time, velocity) {\n    var _this = this;\n\n    assert(!this.disposed, \"Synth was already disposed\"); // if the notes are greater than this amount of time in the future, they should be scheduled with setTimeout\n\n    if (time <= this.now()) {\n      // do it immediately\n      if (type === \"attack\") {\n        this._triggerAttack(notes, time, velocity);\n      } else {\n        this._triggerRelease(notes, time);\n      }\n    } else {\n      // schedule it to start in the future\n      this.context.setTimeout(function () {\n        _this._scheduleEvent(type, notes, time, velocity);\n      }, time - this.now());\n    }\n  };\n  /**\n   * Trigger the attack portion of the note\n   * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n   * @param  time  The start time of the note.\n   * @param velocity The velocity of the note.\n   * @example\n   * import { FMSynth, now, PolySynth } from \"tone\";\n   * const synth = new PolySynth(FMSynth).toDestination();\n   * // trigger a chord immediately with a velocity of 0.2\n   * synth.triggerAttack([\"Ab3\", \"C4\", \"F5\"], now(), 0.2);\n   */\n\n\n  PolySynth.prototype.triggerAttack = function (notes, time, velocity) {\n    if (!Array.isArray(notes)) {\n      notes = [notes];\n    }\n\n    var computedTime = this.toSeconds(time);\n\n    this._scheduleEvent(\"attack\", notes, computedTime, velocity);\n\n    return this;\n  };\n  /**\n   * Trigger the release of the note. Unlike monophonic instruments,\n   * a note (or array of notes) needs to be passed in as the first argument.\n   * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n   * @param  time  When the release will be triggered.\n   * @example\n   * @example\n   * import { AMSynth, PolySynth } from \"tone\";\n   * const poly = new PolySynth(AMSynth).toDestination();\n   * poly.triggerAttack([\"Ab3\", \"C4\", \"F5\"]);\n   * // trigger the release of the given notes.\n   * poly.triggerRelease([\"Ab3\", \"C4\"], \"+1\");\n   * poly.triggerRelease(\"F5\", \"+3\");\n   */\n\n\n  PolySynth.prototype.triggerRelease = function (notes, time) {\n    if (!Array.isArray(notes)) {\n      notes = [notes];\n    }\n\n    var computedTime = this.toSeconds(time);\n\n    this._scheduleEvent(\"release\", notes, computedTime);\n\n    return this;\n  };\n  /**\n   * Trigger the attack and release after the specified duration\n   * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.\n   * @param  duration the duration of the note\n   * @param  time  if no time is given, defaults to now\n   * @param  velocity the velocity of the attack (0-1)\n   * @example\n   * import { AMSynth, PolySynth } from \"tone\";\n   * const poly = new PolySynth(AMSynth).toDestination();\n   * // can pass in an array of durations as well\n   * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"Bb4\", \"D5\"], [4, 3, 2, 1]);\n   */\n\n\n  PolySynth.prototype.triggerAttackRelease = function (notes, duration, time, velocity) {\n    var computedTime = this.toSeconds(time);\n    this.triggerAttack(notes, computedTime, velocity);\n\n    if (isArray(duration)) {\n      assert(isArray(notes), \"If the duration is an array, the notes must also be an array\");\n      notes = notes;\n\n      for (var i = 0; i < notes.length; i++) {\n        var d = duration[Math.min(i, duration.length - 1)];\n        var durationSeconds = this.toSeconds(d);\n        assert(durationSeconds > 0, \"The duration must be greater than 0\");\n        this.triggerRelease(notes[i], computedTime + durationSeconds);\n      }\n    } else {\n      var durationSeconds = this.toSeconds(duration);\n      assert(durationSeconds > 0, \"The duration must be greater than 0\");\n      this.triggerRelease(notes, computedTime + durationSeconds);\n    }\n\n    return this;\n  };\n\n  PolySynth.prototype.sync = function () {\n    this._syncMethod(\"triggerAttack\", 1);\n\n    this._syncMethod(\"triggerRelease\", 1);\n\n    return this;\n  };\n  /**\n   * Set a member/attribute of the voices\n   * @example\n   * import { PolySynth } from \"tone\";\n   * const poly = new PolySynth().toDestination();\n   * // set all of the voices using an options object for the synth type\n   * poly.set({\n   * \tenvelope: {\n   * \t\tattack: 0.25\n   * \t}\n   * });\n   * poly.triggerAttackRelease(\"Bb3\", 0.2);\n   */\n\n\n  PolySynth.prototype.set = function (options) {\n    // remove options which are controlled by the PolySynth\n    var sanitizedOptions = omitFromObject(options, [\"onsilence\", \"context\"]); // store all of the options\n\n    this.options = deepMerge(this.options, sanitizedOptions);\n\n    this._voices.forEach(function (voice) {\n      return voice.set(sanitizedOptions);\n    });\n\n    this._dummyVoice.set(sanitizedOptions);\n\n    return this;\n  };\n\n  PolySynth.prototype.get = function () {\n    return this._dummyVoice.get();\n  };\n  /**\n   * Trigger the release portion of all the currently active voices immediately.\n   * Useful for silencing the synth.\n   */\n\n\n  PolySynth.prototype.releaseAll = function () {\n    var now = this.now();\n\n    this._activeVoices.forEach(function (_a) {\n      var voice = _a.voice;\n      voice.triggerRelease(now);\n    });\n\n    this._activeVoices = [];\n    return this;\n  };\n\n  PolySynth.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._dummyVoice.dispose();\n\n    this._voices.forEach(function (v) {\n      return v.dispose();\n    });\n\n    this._activeVoices = [];\n    this._availableVoices = [];\n    this.context.clearInterval(this._gcTimeout);\n    return this;\n  };\n\n  return PolySynth;\n}(Instrument);\n\nexport { PolySynth };","map":{"version":3,"sources":["../../../Tone/instrument/PolySynth.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { MidiClass } from \"../core/type/Midi\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument } from \"./Instrument\";\nimport { Synth } from \"./Synth\";\nimport { assert, warn } from \"../core/util/Debug\";\n/**\n * PolySynth handles voice creation and allocation for any\n * instruments passed in as the second paramter. PolySynth is\n * not a synthesizer by itself, it merely manages voices of\n * one of the other types of synths, allowing any of the\n * monophonic synthesizers to be polyphonic.\n *\n * @example\n * import { PolySynth } from \"tone\";\n * const synth = new PolySynth().toDestination();\n * // set the attributes across all the voices using 'set'\n * synth.set({ detune: -1200 });\n * // play a chord\n * synth.triggerAttackRelease([\"C4\", \"E4\", \"A4\"], 1);\n * @category Instrument\n */\nvar PolySynth = /** @class */ (function (_super) {\n    tslib_1.__extends(PolySynth, _super);\n    function PolySynth() {\n        var _this = _super.call(this, optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"])) || this;\n        _this.name = \"PolySynth\";\n        /**\n         * The voices which are not currently in use\n         */\n        _this._availableVoices = [];\n        /**\n         * The currently active voices\n         */\n        _this._activeVoices = [];\n        /**\n         * All of the allocated voices for this synth.\n         */\n        _this._voices = [];\n        /**\n         * The GC timeout. Held so that it could be cancelled when the node is disposed.\n         */\n        _this._gcTimeout = -1;\n        /**\n         * A moving average of the number of active voices\n         */\n        _this._averageActiveVoices = 0;\n        var options = optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]);\n        // check against the old API (pre 14.3.0)\n        assert(!isNumber(options.voice), \"DEPRECATED: The polyphony count is no longer the first argument.\");\n        var defaults = options.voice.getDefaults();\n        _this.options = Object.assign(defaults, options.options);\n        _this.voice = options.voice;\n        _this.maxPolyphony = options.maxPolyphony;\n        // create the first voice\n        _this._dummyVoice = _this._getNextAvailableVoice();\n        // remove it from the voices list\n        var index = _this._voices.indexOf(_this._dummyVoice);\n        _this._voices.splice(index, 1);\n        // kick off the GC interval\n        _this._gcTimeout = _this.context.setInterval(_this._collectGarbage.bind(_this), 1);\n        return _this;\n    }\n    PolySynth.getDefaults = function () {\n        return Object.assign(Instrument.getDefaults(), {\n            maxPolyphony: 32,\n            options: {},\n            voice: Synth,\n        });\n    };\n    Object.defineProperty(PolySynth.prototype, \"activeVoices\", {\n        /**\n         * The number of active voices.\n         */\n        get: function () {\n            return this._activeVoices.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Invoked when the source is done making sound, so that it can be\n     * readded to the pool of available voices\n     */\n    PolySynth.prototype._makeVoiceAvailable = function (voice) {\n        this._availableVoices.push(voice);\n        // remove the midi note from 'active voices'\n        var activeVoiceIndex = this._activeVoices.findIndex(function (e) { return e.voice === voice; });\n        this._activeVoices.splice(activeVoiceIndex, 1);\n    };\n    /**\n     * Get an available voice from the pool of available voices.\n     * If one is not available and the maxPolyphony limit is reached,\n     * steal a voice, otherwise return null.\n     */\n    PolySynth.prototype._getNextAvailableVoice = function () {\n        // if there are available voices, return the first one\n        if (this._availableVoices.length) {\n            return this._availableVoices.shift();\n        }\n        else if (this._voices.length < this.maxPolyphony) {\n            // otherwise if there is still more maxPolyphony, make a new voice\n            var voice = new this.voice(Object.assign(this.options, {\n                context: this.context,\n                onsilence: this._makeVoiceAvailable.bind(this),\n            }));\n            voice.connect(this.output);\n            this._voices.push(voice);\n            return voice;\n        }\n        else {\n            warn(\"Max polyphony exceeded. Note dropped.\");\n        }\n    };\n    /**\n     * Occasionally check if there are any allocated voices which can be cleaned up.\n     */\n    PolySynth.prototype._collectGarbage = function () {\n        this._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices);\n        if (this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {\n            // take off an available note\n            var firstAvail = this._availableVoices.shift();\n            var index = this._voices.indexOf(firstAvail);\n            this._voices.splice(index, 1);\n            if (!this.context.isOffline) {\n                firstAvail.dispose();\n            }\n        }\n    };\n    /**\n     * Internal method which triggers the attack\n     */\n    PolySynth.prototype._triggerAttack = function (notes, time, velocity) {\n        var _this = this;\n        notes.forEach(function (note) {\n            var midiNote = new MidiClass(_this.context, note).toMidi();\n            var voice = _this._getNextAvailableVoice();\n            if (voice) {\n                voice.triggerAttack(note, time, velocity);\n                _this._activeVoices.push({\n                    midi: midiNote, voice: voice, released: false,\n                });\n                _this.log(\"triggerAttack\", note, time);\n            }\n        });\n    };\n    /**\n     * Internal method which triggers the release\n     */\n    PolySynth.prototype._triggerRelease = function (notes, time) {\n        var _this = this;\n        notes.forEach(function (note) {\n            var midiNote = new MidiClass(_this.context, note).toMidi();\n            var event = _this._activeVoices.find(function (_a) {\n                var midi = _a.midi, released = _a.released;\n                return midi === midiNote && !released;\n            });\n            if (event) {\n                // trigger release on that note\n                event.voice.triggerRelease(time);\n                // mark it as released\n                event.released = true;\n                _this.log(\"triggerRelease\", note, time);\n            }\n        });\n    };\n    /**\n     * Schedule the attack/release events. If the time is in the future, then it should set a timeout\n     * to wait for just-in-time scheduling\n     */\n    PolySynth.prototype._scheduleEvent = function (type, notes, time, velocity) {\n        var _this = this;\n        assert(!this.disposed, \"Synth was already disposed\");\n        // if the notes are greater than this amount of time in the future, they should be scheduled with setTimeout\n        if (time <= this.now()) {\n            // do it immediately\n            if (type === \"attack\") {\n                this._triggerAttack(notes, time, velocity);\n            }\n            else {\n                this._triggerRelease(notes, time);\n            }\n        }\n        else {\n            // schedule it to start in the future\n            this.context.setTimeout(function () {\n                _this._scheduleEvent(type, notes, time, velocity);\n            }, time - this.now());\n        }\n    };\n    /**\n     * Trigger the attack portion of the note\n     * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n     * @param  time  The start time of the note.\n     * @param velocity The velocity of the note.\n     * @example\n     * import { FMSynth, now, PolySynth } from \"tone\";\n     * const synth = new PolySynth(FMSynth).toDestination();\n     * // trigger a chord immediately with a velocity of 0.2\n     * synth.triggerAttack([\"Ab3\", \"C4\", \"F5\"], now(), 0.2);\n     */\n    PolySynth.prototype.triggerAttack = function (notes, time, velocity) {\n        if (!Array.isArray(notes)) {\n            notes = [notes];\n        }\n        var computedTime = this.toSeconds(time);\n        this._scheduleEvent(\"attack\", notes, computedTime, velocity);\n        return this;\n    };\n    /**\n     * Trigger the release of the note. Unlike monophonic instruments,\n     * a note (or array of notes) needs to be passed in as the first argument.\n     * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n     * @param  time  When the release will be triggered.\n     * @example\n     * @example\n     * import { AMSynth, PolySynth } from \"tone\";\n     * const poly = new PolySynth(AMSynth).toDestination();\n     * poly.triggerAttack([\"Ab3\", \"C4\", \"F5\"]);\n     * // trigger the release of the given notes.\n     * poly.triggerRelease([\"Ab3\", \"C4\"], \"+1\");\n     * poly.triggerRelease(\"F5\", \"+3\");\n     */\n    PolySynth.prototype.triggerRelease = function (notes, time) {\n        if (!Array.isArray(notes)) {\n            notes = [notes];\n        }\n        var computedTime = this.toSeconds(time);\n        this._scheduleEvent(\"release\", notes, computedTime);\n        return this;\n    };\n    /**\n     * Trigger the attack and release after the specified duration\n     * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.\n     * @param  duration the duration of the note\n     * @param  time  if no time is given, defaults to now\n     * @param  velocity the velocity of the attack (0-1)\n     * @example\n     * import { AMSynth, PolySynth } from \"tone\";\n     * const poly = new PolySynth(AMSynth).toDestination();\n     * // can pass in an array of durations as well\n     * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"Bb4\", \"D5\"], [4, 3, 2, 1]);\n     */\n    PolySynth.prototype.triggerAttackRelease = function (notes, duration, time, velocity) {\n        var computedTime = this.toSeconds(time);\n        this.triggerAttack(notes, computedTime, velocity);\n        if (isArray(duration)) {\n            assert(isArray(notes), \"If the duration is an array, the notes must also be an array\");\n            notes = notes;\n            for (var i = 0; i < notes.length; i++) {\n                var d = duration[Math.min(i, duration.length - 1)];\n                var durationSeconds = this.toSeconds(d);\n                assert(durationSeconds > 0, \"The duration must be greater than 0\");\n                this.triggerRelease(notes[i], computedTime + durationSeconds);\n            }\n        }\n        else {\n            var durationSeconds = this.toSeconds(duration);\n            assert(durationSeconds > 0, \"The duration must be greater than 0\");\n            this.triggerRelease(notes, computedTime + durationSeconds);\n        }\n        return this;\n    };\n    PolySynth.prototype.sync = function () {\n        this._syncMethod(\"triggerAttack\", 1);\n        this._syncMethod(\"triggerRelease\", 1);\n        return this;\n    };\n    /**\n     * Set a member/attribute of the voices\n     * @example\n     * import { PolySynth } from \"tone\";\n     * const poly = new PolySynth().toDestination();\n     * // set all of the voices using an options object for the synth type\n     * poly.set({\n     * \tenvelope: {\n     * \t\tattack: 0.25\n     * \t}\n     * });\n     * poly.triggerAttackRelease(\"Bb3\", 0.2);\n     */\n    PolySynth.prototype.set = function (options) {\n        // remove options which are controlled by the PolySynth\n        var sanitizedOptions = omitFromObject(options, [\"onsilence\", \"context\"]);\n        // store all of the options\n        this.options = deepMerge(this.options, sanitizedOptions);\n        this._voices.forEach(function (voice) { return voice.set(sanitizedOptions); });\n        this._dummyVoice.set(sanitizedOptions);\n        return this;\n    };\n    PolySynth.prototype.get = function () {\n        return this._dummyVoice.get();\n    };\n    /**\n     * Trigger the release portion of all the currently active voices immediately.\n     * Useful for silencing the synth.\n     */\n    PolySynth.prototype.releaseAll = function () {\n        var now = this.now();\n        this._activeVoices.forEach(function (_a) {\n            var voice = _a.voice;\n            voice.triggerRelease(now);\n        });\n        this._activeVoices = [];\n        return this;\n    };\n    PolySynth.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this._dummyVoice.dispose();\n        this._voices.forEach(function (v) { return v.dispose(); });\n        this._activeVoices = [];\n        this._availableVoices = [];\n        this.context.clearInterval(this._gcTimeout);\n        return this;\n    };\n    return PolySynth;\n}(Instrument));\nexport { PolySynth };\n//# sourceMappingURL=PolySynth.js.map"]},"metadata":{},"sourceType":"module"}