{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { connect, ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { Volume } from \"../component/channel/Volume\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { isDefined, isNumber } from \"../core/util/TypeCheck\";\n/**\n * UserMedia uses MediaDevices.getUserMedia to open up and external microphone or audio input.\n * Check [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)\n * to see which browsers are supported. Access to an external input\n * is limited to secure (HTTPS) connections.\n * @example\n * import { UserMedia } from \"tone\";\n * const mic = new UserMedia();\n * mic.open().then(() => {\n * \t// promise resolves when input is available\n * });\n * @category Source\n */\n\nvar UserMedia =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(UserMedia, _super);\n\n  function UserMedia() {\n    var _this = _super.call(this, optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"])) || this;\n\n    _this.name = \"UserMedia\";\n    var options = optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]);\n    _this._volume = _this.output = new Volume({\n      context: _this.context,\n      volume: options.volume\n    });\n    _this.volume = _this._volume.volume;\n    readOnly(_this, \"volume\");\n    _this.mute = options.mute;\n    return _this;\n  }\n\n  UserMedia.getDefaults = function () {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      mute: false,\n      volume: 0\n    });\n  };\n  /**\n   * Open the media stream. If a string is passed in, it is assumed\n   * to be the label or id of the stream, if a number is passed in,\n   * it is the input number of the stream.\n   * @param  labelOrId The label or id of the audio input media device.\n   *                   With no argument, the default stream is opened.\n   * @return The promise is resolved when the stream is open.\n   */\n\n\n  UserMedia.prototype.open = function (labelOrId) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var devices, constraints, stream, mediaStreamNode;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert(UserMedia.supported, \"UserMedia is not supported\"); // close the previous stream\n\n            if (this.state === \"started\") {\n              this.close();\n            }\n\n            return [4\n            /*yield*/\n            , UserMedia.enumerateDevices()];\n\n          case 1:\n            devices = _a.sent();\n\n            if (isNumber(labelOrId)) {\n              this._device = devices[labelOrId];\n            } else {\n              this._device = devices.find(function (device) {\n                return device.label === labelOrId || device.deviceId === labelOrId;\n              }); // didn't find a matching device\n\n              if (!this._device && devices.length > 0) {\n                this._device = devices[0];\n              }\n\n              assert(isDefined(this._device), \"No matching device \" + labelOrId);\n            }\n\n            constraints = {\n              audio: {\n                echoCancellation: false,\n                sampleRate: this.context.sampleRate,\n                noiseSuppression: false,\n                mozNoiseSuppression: false\n              }\n            };\n\n            if (this._device) {\n              // @ts-ignore\n              constraints.audio.deviceId = this._device.deviceId;\n            }\n\n            return [4\n            /*yield*/\n            , navigator.mediaDevices.getUserMedia(constraints)];\n\n          case 2:\n            stream = _a.sent(); // start a new source only if the previous one is closed\n\n            if (!this._stream) {\n              this._stream = stream;\n              mediaStreamNode = this.context.createMediaStreamSource(stream); // Connect the MediaStreamSourceNode to a gate gain node\n\n              connect(mediaStreamNode, this.output);\n              this._mediaStream = mediaStreamNode;\n            }\n\n            return [2\n            /*return*/\n            , this];\n        }\n      });\n    });\n  };\n  /**\n   * Close the media stream\n   */\n\n\n  UserMedia.prototype.close = function () {\n    if (this._stream && this._mediaStream) {\n      this._stream.getAudioTracks().forEach(function (track) {\n        track.stop();\n      });\n\n      this._stream = undefined; // remove the old media stream\n\n      this._mediaStream.disconnect();\n\n      this._mediaStream = undefined;\n    }\n\n    this._device = undefined;\n    return this;\n  };\n  /**\n   * Returns a promise which resolves with the list of audio input devices available.\n   * @return The promise that is resolved with the devices\n   * @example\n   * import { UserMedia } from \"tone\";\n   * UserMedia.enumerateDevices().then((devices) => {\n   * \t// print the device labels\n   * \tconsole.log(devices.map(device => device.label));\n   * });\n   */\n\n\n  UserMedia.enumerateDevices = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var allDevices;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , navigator.mediaDevices.enumerateDevices()];\n\n          case 1:\n            allDevices = _a.sent();\n            return [2\n            /*return*/\n            , allDevices.filter(function (device) {\n              return device.kind === \"audioinput\";\n            })];\n        }\n      });\n    });\n  };\n\n  Object.defineProperty(UserMedia.prototype, \"state\", {\n    /**\n     * Returns the playback state of the source, \"started\" when the microphone is open\n     * and \"stopped\" when the mic is closed.\n     */\n    get: function () {\n      return this._stream && this._stream.active ? \"started\" : \"stopped\";\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(UserMedia.prototype, \"deviceId\", {\n    /**\n     * Returns an identifier for the represented device that is\n     * persisted across sessions. It is un-guessable by other applications and\n     * unique to the origin of the calling application. It is reset when the\n     * user clears cookies (for Private Browsing, a different identifier is\n     * used that is not persisted across sessions). Returns undefined when the\n     * device is not open.\n     */\n    get: function () {\n      if (this._device) {\n        return this._device.deviceId;\n      } else {\n        return undefined;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(UserMedia.prototype, \"groupId\", {\n    /**\n     * Returns a group identifier. Two devices have the\n     * same group identifier if they belong to the same physical device.\n     * Returns null  when the device is not open.\n     */\n    get: function () {\n      if (this._device) {\n        return this._device.groupId;\n      } else {\n        return undefined;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(UserMedia.prototype, \"label\", {\n    /**\n     * Returns a label describing this device (for example \"Built-in Microphone\").\n     * Returns undefined when the device is not open or label is not available\n     * because of permissions.\n     */\n    get: function () {\n      if (this._device) {\n        return this._device.label;\n      } else {\n        return undefined;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(UserMedia.prototype, \"mute\", {\n    /**\n     * Mute the output.\n     * @example\n     * import { UserMedia } from \"tone\";\n     * const mic = new UserMedia();\n     * mic.open().then(() => {\n     * \t// promise resolves when input is available\n     * });\n     * // mute the output\n     * mic.mute = true;\n     */\n    get: function () {\n      return this._volume.mute;\n    },\n    set: function (mute) {\n      this._volume.mute = mute;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  UserMedia.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.close();\n\n    this._volume.dispose();\n\n    this.volume.dispose();\n    return this;\n  };\n\n  Object.defineProperty(UserMedia, \"supported\", {\n    /**\n     * If getUserMedia is supported by the browser.\n     */\n    get: function () {\n      return isDefined(navigator.mediaDevices) && isDefined(navigator.mediaDevices.getUserMedia);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return UserMedia;\n}(ToneAudioNode);\n\nexport { UserMedia };","map":{"version":3,"sources":["../../../Tone/source/UserMedia.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { connect, ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { Volume } from \"../component/channel/Volume\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { isDefined, isNumber } from \"../core/util/TypeCheck\";\n/**\n * UserMedia uses MediaDevices.getUserMedia to open up and external microphone or audio input.\n * Check [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)\n * to see which browsers are supported. Access to an external input\n * is limited to secure (HTTPS) connections.\n * @example\n * import { UserMedia } from \"tone\";\n * const mic = new UserMedia();\n * mic.open().then(() => {\n * \t// promise resolves when input is available\n * });\n * @category Source\n */\nvar UserMedia = /** @class */ (function (_super) {\n    tslib_1.__extends(UserMedia, _super);\n    function UserMedia() {\n        var _this = _super.call(this, optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"])) || this;\n        _this.name = \"UserMedia\";\n        var options = optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]);\n        _this._volume = _this.output = new Volume({\n            context: _this.context,\n            volume: options.volume,\n        });\n        _this.volume = _this._volume.volume;\n        readOnly(_this, \"volume\");\n        _this.mute = options.mute;\n        return _this;\n    }\n    UserMedia.getDefaults = function () {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            mute: false,\n            volume: 0\n        });\n    };\n    /**\n     * Open the media stream. If a string is passed in, it is assumed\n     * to be the label or id of the stream, if a number is passed in,\n     * it is the input number of the stream.\n     * @param  labelOrId The label or id of the audio input media device.\n     *                   With no argument, the default stream is opened.\n     * @return The promise is resolved when the stream is open.\n     */\n    UserMedia.prototype.open = function (labelOrId) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var devices, constraints, stream, mediaStreamNode;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert(UserMedia.supported, \"UserMedia is not supported\");\n                        // close the previous stream\n                        if (this.state === \"started\") {\n                            this.close();\n                        }\n                        return [4 /*yield*/, UserMedia.enumerateDevices()];\n                    case 1:\n                        devices = _a.sent();\n                        if (isNumber(labelOrId)) {\n                            this._device = devices[labelOrId];\n                        }\n                        else {\n                            this._device = devices.find(function (device) {\n                                return device.label === labelOrId || device.deviceId === labelOrId;\n                            });\n                            // didn't find a matching device\n                            if (!this._device && devices.length > 0) {\n                                this._device = devices[0];\n                            }\n                            assert(isDefined(this._device), \"No matching device \" + labelOrId);\n                        }\n                        constraints = {\n                            audio: {\n                                echoCancellation: false,\n                                sampleRate: this.context.sampleRate,\n                                noiseSuppression: false,\n                                mozNoiseSuppression: false,\n                            }\n                        };\n                        if (this._device) {\n                            // @ts-ignore\n                            constraints.audio.deviceId = this._device.deviceId;\n                        }\n                        return [4 /*yield*/, navigator.mediaDevices.getUserMedia(constraints)];\n                    case 2:\n                        stream = _a.sent();\n                        // start a new source only if the previous one is closed\n                        if (!this._stream) {\n                            this._stream = stream;\n                            mediaStreamNode = this.context.createMediaStreamSource(stream);\n                            // Connect the MediaStreamSourceNode to a gate gain node\n                            connect(mediaStreamNode, this.output);\n                            this._mediaStream = mediaStreamNode;\n                        }\n                        return [2 /*return*/, this];\n                }\n            });\n        });\n    };\n    /**\n     * Close the media stream\n     */\n    UserMedia.prototype.close = function () {\n        if (this._stream && this._mediaStream) {\n            this._stream.getAudioTracks().forEach(function (track) {\n                track.stop();\n            });\n            this._stream = undefined;\n            // remove the old media stream\n            this._mediaStream.disconnect();\n            this._mediaStream = undefined;\n        }\n        this._device = undefined;\n        return this;\n    };\n    /**\n     * Returns a promise which resolves with the list of audio input devices available.\n     * @return The promise that is resolved with the devices\n     * @example\n     * import { UserMedia } from \"tone\";\n     * UserMedia.enumerateDevices().then((devices) => {\n     * \t// print the device labels\n     * \tconsole.log(devices.map(device => device.label));\n     * });\n     */\n    UserMedia.enumerateDevices = function () {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var allDevices;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, navigator.mediaDevices.enumerateDevices()];\n                    case 1:\n                        allDevices = _a.sent();\n                        return [2 /*return*/, allDevices.filter(function (device) {\n                                return device.kind === \"audioinput\";\n                            })];\n                }\n            });\n        });\n    };\n    Object.defineProperty(UserMedia.prototype, \"state\", {\n        /**\n         * Returns the playback state of the source, \"started\" when the microphone is open\n         * and \"stopped\" when the mic is closed.\n         */\n        get: function () {\n            return this._stream && this._stream.active ? \"started\" : \"stopped\";\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(UserMedia.prototype, \"deviceId\", {\n        /**\n         * Returns an identifier for the represented device that is\n         * persisted across sessions. It is un-guessable by other applications and\n         * unique to the origin of the calling application. It is reset when the\n         * user clears cookies (for Private Browsing, a different identifier is\n         * used that is not persisted across sessions). Returns undefined when the\n         * device is not open.\n         */\n        get: function () {\n            if (this._device) {\n                return this._device.deviceId;\n            }\n            else {\n                return undefined;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(UserMedia.prototype, \"groupId\", {\n        /**\n         * Returns a group identifier. Two devices have the\n         * same group identifier if they belong to the same physical device.\n         * Returns null  when the device is not open.\n         */\n        get: function () {\n            if (this._device) {\n                return this._device.groupId;\n            }\n            else {\n                return undefined;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(UserMedia.prototype, \"label\", {\n        /**\n         * Returns a label describing this device (for example \"Built-in Microphone\").\n         * Returns undefined when the device is not open or label is not available\n         * because of permissions.\n         */\n        get: function () {\n            if (this._device) {\n                return this._device.label;\n            }\n            else {\n                return undefined;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(UserMedia.prototype, \"mute\", {\n        /**\n         * Mute the output.\n         * @example\n         * import { UserMedia } from \"tone\";\n         * const mic = new UserMedia();\n         * mic.open().then(() => {\n         * \t// promise resolves when input is available\n         * });\n         * // mute the output\n         * mic.mute = true;\n         */\n        get: function () {\n            return this._volume.mute;\n        },\n        set: function (mute) {\n            this._volume.mute = mute;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    UserMedia.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this.close();\n        this._volume.dispose();\n        this.volume.dispose();\n        return this;\n    };\n    Object.defineProperty(UserMedia, \"supported\", {\n        /**\n         * If getUserMedia is supported by the browser.\n         */\n        get: function () {\n            return isDefined(navigator.mediaDevices) &&\n                isDefined(navigator.mediaDevices.getUserMedia);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return UserMedia;\n}(ToneAudioNode));\nexport { UserMedia };\n//# sourceMappingURL=UserMedia.js.map"]},"metadata":{},"sourceType":"module"}