{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { Gain } from \"../core/context/Gain\";\nimport { connect, disconnect } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { SignalOperator } from \"./SignalOperator\";\n/**\n * Tone.Zero outputs 0's at audio-rate. The reason this has to be\n * it's own class is that many browsers optimize out Tone.Signal\n * with a value of 0 and will not process nodes further down the graph.\n * @category Signal\n */\n\nvar Zero =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Zero, _super);\n\n  function Zero() {\n    var _this = _super.call(this, Object.assign(optionsFromArguments(Zero.getDefaults(), arguments))) || this;\n\n    _this.name = \"Zero\";\n    /**\n     * The gain node which connects the constant source to the output\n     */\n\n    _this._gain = new Gain({\n      context: _this.context\n    });\n    /**\n     * Only outputs 0\n     */\n\n    _this.output = _this._gain;\n    /**\n     * no input node\n     */\n\n    _this.input = undefined;\n    connect(_this.context.getConstant(0), _this._gain);\n    return _this;\n  }\n  /**\n   * clean up\n   */\n\n\n  Zero.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    disconnect(this.context.getConstant(0), this._gain);\n    return this;\n  };\n\n  return Zero;\n}(SignalOperator);\n\nexport { Zero };","map":{"version":3,"sources":["../../../Tone/signal/Zero.ts"],"names":[],"mappings":";AAAA,SAAS,IAAT,QAAqB,sBAArB;AACA,SAAS,OAAT,EAAkB,UAAlB,QAA0D,+BAA1D;AACA,SAAS,oBAAT,QAAqC,uBAArC;AACA,SAAS,cAAT,QAA+B,kBAA/B;AAEA;;;;;;;AAMA,IAAA,IAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAA0B,EAAA,OAAA,CAAA,SAAA,CAAA,IAAA,EAAA,MAAA;;AAoBzB,WAAA,IAAA,GAAA;AAAA,QAAA,KAAA,GACC,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,MAAM,CAAC,MAAP,CAAc,oBAAoB,CAAC,IAAI,CAAC,WAAL,EAAD,EAAqB,SAArB,CAAlC,CAAN,KAAyE,IAD1E;;AAlBS,IAAA,KAAA,CAAA,IAAA,GAAe,MAAf;AAET;;;;AAGQ,IAAA,KAAA,CAAA,KAAA,GAAQ,IAAI,IAAJ,CAAS;AAAE,MAAA,OAAO,EAAE,KAAI,CAAC;AAAhB,KAAT,CAAR;AAER;;;;AAGA,IAAA,KAAA,CAAA,MAAA,GAAS,KAAI,CAAC,KAAd;AAEA;;;;AAGA,IAAA,KAAA,CAAA,KAAA,GAAQ,SAAR;AAKC,IAAA,OAAO,CAAC,KAAI,CAAC,OAAL,CAAa,WAAb,CAAyB,CAAzB,CAAD,EAA8B,KAAI,CAAC,KAAnC,CAAP;;AACA;AAED;;;;;AAGA,EAAA,IAAA,CAAA,SAAA,CAAA,OAAA,GAAA,YAAA;AACC,IAAA,MAAA,CAAA,SAAA,CAAM,OAAN,CAAa,IAAb,CAAa,IAAb;;AACA,IAAA,UAAU,CAAC,KAAK,OAAL,CAAa,WAAb,CAAyB,CAAzB,CAAD,EAA8B,KAAK,KAAnC,CAAV;AACA,WAAO,IAAP;AACA,GAJD;;AAKD,SAAA,IAAA;AAAC,CAjCD,CAA0B,cAA1B,CAAA","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { Gain } from \"../core/context/Gain\";\nimport { connect, disconnect } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { SignalOperator } from \"./SignalOperator\";\n/**\n * Tone.Zero outputs 0's at audio-rate. The reason this has to be\n * it's own class is that many browsers optimize out Tone.Signal\n * with a value of 0 and will not process nodes further down the graph.\n * @category Signal\n */\nvar Zero = /** @class */ (function (_super) {\n    tslib_1.__extends(Zero, _super);\n    function Zero() {\n        var _this = _super.call(this, Object.assign(optionsFromArguments(Zero.getDefaults(), arguments))) || this;\n        _this.name = \"Zero\";\n        /**\n         * The gain node which connects the constant source to the output\n         */\n        _this._gain = new Gain({ context: _this.context });\n        /**\n         * Only outputs 0\n         */\n        _this.output = _this._gain;\n        /**\n         * no input node\n         */\n        _this.input = undefined;\n        connect(_this.context.getConstant(0), _this._gain);\n        return _this;\n    }\n    /**\n     * clean up\n     */\n    Zero.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        disconnect(this.context.getConstant(0), this._gain);\n        return this;\n    };\n    return Zero;\n}(SignalOperator));\nexport { Zero };\n//# sourceMappingURL=Zero.js.map"]},"metadata":{},"sourceType":"module"}