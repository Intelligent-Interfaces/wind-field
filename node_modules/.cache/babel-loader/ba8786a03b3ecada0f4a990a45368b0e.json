{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Split } from \"../channel/Split\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { assert, assertRange } from \"../../core/util/Debug\";\n/**\n * Wrapper around the native Web Audio's [AnalyserNode](http://webaudio.github.io/web-audio-api/#idl-def-AnalyserNode).\n * Extracts FFT or Waveform data from the incoming signal.\n * @category Component\n */\n\nvar Analyser =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Analyser, _super);\n\n  function Analyser() {\n    var _this = _super.call(this, optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"])) || this;\n\n    _this.name = \"Analyser\";\n    /**\n     * The analyser node.\n     */\n\n    _this._analysers = [];\n    /**\n     * The buffer that the FFT data is written to\n     */\n\n    _this._buffers = [];\n    var options = optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]);\n    _this.input = _this.output = _this._gain = new Gain({\n      context: _this.context\n    });\n    _this._split = new Split({\n      context: _this.context,\n      channels: options.channels\n    });\n\n    _this.input.connect(_this._split);\n\n    assertRange(options.channels, 1); // create the analysers\n\n    for (var channel = 0; channel < options.channels; channel++) {\n      _this._analysers[channel] = _this.context.createAnalyser();\n\n      _this._split.connect(_this._analysers[channel], channel, 0);\n    } // set the values initially\n\n\n    _this.size = options.size;\n    _this.type = options.type;\n    return _this;\n  }\n\n  Analyser.getDefaults = function () {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      size: 1024,\n      smoothing: 0.8,\n      type: \"fft\",\n      channels: 1\n    });\n  };\n  /**\n   * Run the analysis given the current settings. If [[channels]] = 1,\n   * it will return a Float32Array. If [[channels]] > 1, it will\n   * return an array of Float32Arrays where each index in the array\n   * represents the analysis done on a channel.\n   */\n\n\n  Analyser.prototype.getValue = function () {\n    var _this = this;\n\n    this._analysers.forEach(function (analyser, index) {\n      var buffer = _this._buffers[index];\n\n      if (_this._type === \"fft\") {\n        analyser.getFloatFrequencyData(buffer);\n      } else if (_this._type === \"waveform\") {\n        analyser.getFloatTimeDomainData(buffer);\n      }\n    });\n\n    if (this.channels === 1) {\n      return this._buffers[0];\n    } else {\n      return this._buffers;\n    }\n  };\n\n  Object.defineProperty(Analyser.prototype, \"size\", {\n    /**\n     * The size of analysis. This must be a power of two in the range 16 to 16384.\n     */\n    get: function () {\n      return this._analysers[0].frequencyBinCount;\n    },\n    set: function (size) {\n      var _this = this;\n\n      this._analysers.forEach(function (analyser, index) {\n        analyser.fftSize = size * 2;\n        _this._buffers[index] = new Float32Array(size);\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Analyser.prototype, \"channels\", {\n    /**\n     * The number of channels the analyser does the analysis on. Channel\n     * separation is done using [[Split]]\n     */\n    get: function () {\n      return this._analysers.length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Analyser.prototype, \"type\", {\n    /**\n     * The analysis function returned by analyser.getValue(), either \"fft\" or \"waveform\".\n     */\n    get: function () {\n      return this._type;\n    },\n    set: function (type) {\n      assert(type === \"waveform\" || type === \"fft\", \"Analyser: invalid type: \" + type);\n      this._type = type;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Analyser.prototype, \"smoothing\", {\n    /**\n     * 0 represents no time averaging with the last analysis frame.\n     */\n    get: function () {\n      return this._analysers[0].smoothingTimeConstant;\n    },\n    set: function (val) {\n      this._analysers.forEach(function (a) {\n        return a.smoothingTimeConstant = val;\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Clean up.\n   */\n\n  Analyser.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._analysers.forEach(function (a) {\n      return a.disconnect();\n    });\n\n    this._split.dispose();\n\n    this._gain.dispose();\n\n    return this;\n  };\n\n  return Analyser;\n}(ToneAudioNode);\n\nexport { Analyser };","map":{"version":3,"sources":["../../../../Tone/component/analysis/Analyser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Split } from \"../channel/Split\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { assert, assertRange } from \"../../core/util/Debug\";\n/**\n * Wrapper around the native Web Audio's [AnalyserNode](http://webaudio.github.io/web-audio-api/#idl-def-AnalyserNode).\n * Extracts FFT or Waveform data from the incoming signal.\n * @category Component\n */\nvar Analyser = /** @class */ (function (_super) {\n    tslib_1.__extends(Analyser, _super);\n    function Analyser() {\n        var _this = _super.call(this, optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"])) || this;\n        _this.name = \"Analyser\";\n        /**\n         * The analyser node.\n         */\n        _this._analysers = [];\n        /**\n         * The buffer that the FFT data is written to\n         */\n        _this._buffers = [];\n        var options = optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]);\n        _this.input = _this.output = _this._gain = new Gain({ context: _this.context });\n        _this._split = new Split({\n            context: _this.context,\n            channels: options.channels,\n        });\n        _this.input.connect(_this._split);\n        assertRange(options.channels, 1);\n        // create the analysers\n        for (var channel = 0; channel < options.channels; channel++) {\n            _this._analysers[channel] = _this.context.createAnalyser();\n            _this._split.connect(_this._analysers[channel], channel, 0);\n        }\n        // set the values initially\n        _this.size = options.size;\n        _this.type = options.type;\n        return _this;\n    }\n    Analyser.getDefaults = function () {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            size: 1024,\n            smoothing: 0.8,\n            type: \"fft\",\n            channels: 1,\n        });\n    };\n    /**\n     * Run the analysis given the current settings. If [[channels]] = 1,\n     * it will return a Float32Array. If [[channels]] > 1, it will\n     * return an array of Float32Arrays where each index in the array\n     * represents the analysis done on a channel.\n     */\n    Analyser.prototype.getValue = function () {\n        var _this = this;\n        this._analysers.forEach(function (analyser, index) {\n            var buffer = _this._buffers[index];\n            if (_this._type === \"fft\") {\n                analyser.getFloatFrequencyData(buffer);\n            }\n            else if (_this._type === \"waveform\") {\n                analyser.getFloatTimeDomainData(buffer);\n            }\n        });\n        if (this.channels === 1) {\n            return this._buffers[0];\n        }\n        else {\n            return this._buffers;\n        }\n    };\n    Object.defineProperty(Analyser.prototype, \"size\", {\n        /**\n         * The size of analysis. This must be a power of two in the range 16 to 16384.\n         */\n        get: function () {\n            return this._analysers[0].frequencyBinCount;\n        },\n        set: function (size) {\n            var _this = this;\n            this._analysers.forEach(function (analyser, index) {\n                analyser.fftSize = size * 2;\n                _this._buffers[index] = new Float32Array(size);\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Analyser.prototype, \"channels\", {\n        /**\n         * The number of channels the analyser does the analysis on. Channel\n         * separation is done using [[Split]]\n         */\n        get: function () {\n            return this._analysers.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Analyser.prototype, \"type\", {\n        /**\n         * The analysis function returned by analyser.getValue(), either \"fft\" or \"waveform\".\n         */\n        get: function () {\n            return this._type;\n        },\n        set: function (type) {\n            assert(type === \"waveform\" || type === \"fft\", \"Analyser: invalid type: \" + type);\n            this._type = type;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Analyser.prototype, \"smoothing\", {\n        /**\n         * 0 represents no time averaging with the last analysis frame.\n         */\n        get: function () {\n            return this._analysers[0].smoothingTimeConstant;\n        },\n        set: function (val) {\n            this._analysers.forEach(function (a) { return a.smoothingTimeConstant = val; });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Clean up.\n     */\n    Analyser.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this._analysers.forEach(function (a) { return a.disconnect(); });\n        this._split.dispose();\n        this._gain.dispose();\n        return this;\n    };\n    return Analyser;\n}(ToneAudioNode));\nexport { Analyser };\n//# sourceMappingURL=Analyser.js.map"]},"metadata":{},"sourceType":"module"}