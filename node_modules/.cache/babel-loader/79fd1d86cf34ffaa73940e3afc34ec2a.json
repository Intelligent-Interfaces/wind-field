{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { ToneAudioWorklet } from \"../core/context/ToneAudioWorklet\";\nimport { Effect } from \"./Effect\";\nimport { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { connectSeries } from \"../core/context/ToneAudioNode\";\nimport { Param } from \"../core/context/Param\";\n/**\n * BitCrusher down-samples the incoming signal to a different bit depth.\n * Lowering the bit depth of the signal creates distortion. Read more about BitCrushing\n * on [Wikipedia](https://en.wikipedia.org/wiki/Bitcrusher).\n * @example\n * import { BitCrusher, Synth } from \"tone\";\n * // initialize crusher and route a synth through it\n * const crusher = new BitCrusher(4).toDestination();\n * const synth = new Synth().connect(crusher);\n * synth.triggerAttackRelease(\"C2\", 2);\n *\n * @category Effect\n */\n\nvar BitCrusher =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(BitCrusher, _super);\n\n  function BitCrusher() {\n    var _this = _super.call(this, optionsFromArguments(BitCrusher.getDefaults(), arguments, [\"bits\"])) || this;\n\n    _this.name = \"BitCrusher\";\n    var options = optionsFromArguments(BitCrusher.getDefaults(), arguments, [\"bits\"]);\n    _this._bitCrusherWorklet = new BitCrusherWorklet({\n      context: _this.context,\n      bits: options.bits\n    }); // connect it up\n\n    _this.connectEffect(_this._bitCrusherWorklet);\n\n    _this.bits = _this._bitCrusherWorklet.bits;\n    return _this;\n  }\n\n  BitCrusher.getDefaults = function () {\n    return Object.assign(Effect.getDefaults(), {\n      bits: 4,\n      frequencyReduction: 0.5\n    });\n  };\n\n  BitCrusher.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._bitCrusherWorklet.dispose();\n\n    return this;\n  };\n\n  return BitCrusher;\n}(Effect);\n\nexport { BitCrusher };\n/**\n * Internal class which creates an AudioWorklet to do the bit crushing\n */\n\nvar BitCrusherWorklet =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(BitCrusherWorklet, _super);\n\n  function BitCrusherWorklet() {\n    var _this = _super.call(this, optionsFromArguments(BitCrusherWorklet.getDefaults(), arguments)) || this;\n\n    _this.name = \"BitCrusherWorklet\";\n    _this.workletOptions = {\n      numberOfInputs: 1,\n      numberOfOutputs: 1\n    };\n    var options = optionsFromArguments(BitCrusherWorklet.getDefaults(), arguments);\n    _this.input = new Gain({\n      context: _this.context\n    });\n    _this.output = new Gain({\n      context: _this.context\n    });\n\n    var dummyGain = _this.context.createGain();\n\n    _this.bits = new Param({\n      context: _this.context,\n      value: options.bits,\n      units: \"positive\",\n      minValue: 1,\n      maxValue: 16,\n      param: dummyGain.gain,\n      swappable: true\n    });\n    return _this;\n  }\n\n  BitCrusherWorklet.getDefaults = function () {\n    return Object.assign(ToneAudioWorklet.getDefaults(), {\n      bits: 12\n    });\n  };\n\n  BitCrusherWorklet.prototype._audioWorkletName = function () {\n    return \"bit-crusher\";\n  };\n\n  BitCrusherWorklet.prototype._audioWorklet = function () {\n    return (\n      /* javascript */\n      \" \\n\\t\\tregisterProcessor(\\\"\" + this._audioWorkletName() + \"\\\", class extends AudioWorkletProcessor {\\n\\t\\t\\tstatic get parameterDescriptors () {\\n\\t\\t\\t\\treturn [{\\n\\t\\t\\t\\t\\tname: 'bits',\\n\\t\\t\\t\\t\\tdefaultValue: 12,\\n\\t\\t\\t\\t\\tminValue: 1,\\n\\t\\t\\t\\t\\tmaxValue: 16\\n\\t\\t\\t\\t}];\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tprocess (inputs, outputs, parameters) {\\n\\t\\t\\t\\tconst input = inputs[0];\\n\\t\\t\\t\\tconst output = outputs[0];\\n\\t\\t\\t\\tif (input && output && input.length === output.length) {\\n\\t\\t\\t\\t\\tconst bits = parameters.bits;\\n\\t\\t\\t\\t\\tfor (let channelNum = 0; channelNum < input.length; channelNum++) {\\n\\t\\t\\t\\t\\t\\tconst inputChannel = input[channelNum];\\n\\t\\t\\t\\t\\t\\tfor (let index = 0; index < inputChannel.length; index++) {\\n\\t\\t\\t\\t\\t\\t\\tconst value = inputChannel[index];\\n\\t\\t\\t\\t\\t\\t\\tconst step = bits.length > 1 ? Math.pow(0.5, bits[index]) : Math.pow(0.5, bits[0]);\\n\\t\\t\\t\\t\\t\\t\\tconst val = step * Math.floor(value / step + 0.5);\\n\\t\\t\\t\\t\\t\\t\\toutput[channelNum][index] = val;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\t\"\n    );\n  };\n\n  BitCrusherWorklet.prototype.onReady = function (node) {\n    connectSeries(this.input, node, this.output); // @ts-ignore\n\n    var bits = node.parameters.get(\"bits\");\n    this.bits.setParam(bits);\n  };\n\n  BitCrusherWorklet.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.input.dispose();\n    this.output.dispose();\n    this.bits.dispose();\n    return this;\n  };\n\n  return BitCrusherWorklet;\n}(ToneAudioWorklet);","map":{"version":3,"sources":["../../../Tone/effect/BitCrusher.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { ToneAudioWorklet } from \"../core/context/ToneAudioWorklet\";\nimport { Effect } from \"./Effect\";\nimport { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { connectSeries } from \"../core/context/ToneAudioNode\";\nimport { Param } from \"../core/context/Param\";\n/**\n * BitCrusher down-samples the incoming signal to a different bit depth.\n * Lowering the bit depth of the signal creates distortion. Read more about BitCrushing\n * on [Wikipedia](https://en.wikipedia.org/wiki/Bitcrusher).\n * @example\n * import { BitCrusher, Synth } from \"tone\";\n * // initialize crusher and route a synth through it\n * const crusher = new BitCrusher(4).toDestination();\n * const synth = new Synth().connect(crusher);\n * synth.triggerAttackRelease(\"C2\", 2);\n *\n * @category Effect\n */\nvar BitCrusher = /** @class */ (function (_super) {\n    tslib_1.__extends(BitCrusher, _super);\n    function BitCrusher() {\n        var _this = _super.call(this, optionsFromArguments(BitCrusher.getDefaults(), arguments, [\"bits\"])) || this;\n        _this.name = \"BitCrusher\";\n        var options = optionsFromArguments(BitCrusher.getDefaults(), arguments, [\"bits\"]);\n        _this._bitCrusherWorklet = new BitCrusherWorklet({\n            context: _this.context,\n            bits: options.bits,\n        });\n        // connect it up\n        _this.connectEffect(_this._bitCrusherWorklet);\n        _this.bits = _this._bitCrusherWorklet.bits;\n        return _this;\n    }\n    BitCrusher.getDefaults = function () {\n        return Object.assign(Effect.getDefaults(), {\n            bits: 4,\n            frequencyReduction: 0.5,\n        });\n    };\n    BitCrusher.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this._bitCrusherWorklet.dispose();\n        return this;\n    };\n    return BitCrusher;\n}(Effect));\nexport { BitCrusher };\n/**\n * Internal class which creates an AudioWorklet to do the bit crushing\n */\nvar BitCrusherWorklet = /** @class */ (function (_super) {\n    tslib_1.__extends(BitCrusherWorklet, _super);\n    function BitCrusherWorklet() {\n        var _this = _super.call(this, optionsFromArguments(BitCrusherWorklet.getDefaults(), arguments)) || this;\n        _this.name = \"BitCrusherWorklet\";\n        _this.workletOptions = {\n            numberOfInputs: 1,\n            numberOfOutputs: 1,\n        };\n        var options = optionsFromArguments(BitCrusherWorklet.getDefaults(), arguments);\n        _this.input = new Gain({ context: _this.context });\n        _this.output = new Gain({ context: _this.context });\n        var dummyGain = _this.context.createGain();\n        _this.bits = new Param({\n            context: _this.context,\n            value: options.bits,\n            units: \"positive\",\n            minValue: 1,\n            maxValue: 16,\n            param: dummyGain.gain,\n            swappable: true,\n        });\n        return _this;\n    }\n    BitCrusherWorklet.getDefaults = function () {\n        return Object.assign(ToneAudioWorklet.getDefaults(), {\n            bits: 12,\n        });\n    };\n    BitCrusherWorklet.prototype._audioWorkletName = function () {\n        return \"bit-crusher\";\n    };\n    BitCrusherWorklet.prototype._audioWorklet = function () {\n        return /* javascript */ \" \\n\\t\\tregisterProcessor(\\\"\" + this._audioWorkletName() + \"\\\", class extends AudioWorkletProcessor {\\n\\t\\t\\tstatic get parameterDescriptors () {\\n\\t\\t\\t\\treturn [{\\n\\t\\t\\t\\t\\tname: 'bits',\\n\\t\\t\\t\\t\\tdefaultValue: 12,\\n\\t\\t\\t\\t\\tminValue: 1,\\n\\t\\t\\t\\t\\tmaxValue: 16\\n\\t\\t\\t\\t}];\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tprocess (inputs, outputs, parameters) {\\n\\t\\t\\t\\tconst input = inputs[0];\\n\\t\\t\\t\\tconst output = outputs[0];\\n\\t\\t\\t\\tif (input && output && input.length === output.length) {\\n\\t\\t\\t\\t\\tconst bits = parameters.bits;\\n\\t\\t\\t\\t\\tfor (let channelNum = 0; channelNum < input.length; channelNum++) {\\n\\t\\t\\t\\t\\t\\tconst inputChannel = input[channelNum];\\n\\t\\t\\t\\t\\t\\tfor (let index = 0; index < inputChannel.length; index++) {\\n\\t\\t\\t\\t\\t\\t\\tconst value = inputChannel[index];\\n\\t\\t\\t\\t\\t\\t\\tconst step = bits.length > 1 ? Math.pow(0.5, bits[index]) : Math.pow(0.5, bits[0]);\\n\\t\\t\\t\\t\\t\\t\\tconst val = step * Math.floor(value / step + 0.5);\\n\\t\\t\\t\\t\\t\\t\\toutput[channelNum][index] = val;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\t\";\n    };\n    BitCrusherWorklet.prototype.onReady = function (node) {\n        connectSeries(this.input, node, this.output);\n        // @ts-ignore\n        var bits = node.parameters.get(\"bits\");\n        this.bits.setParam(bits);\n    };\n    BitCrusherWorklet.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this.input.dispose();\n        this.output.dispose();\n        this.bits.dispose();\n        return this;\n    };\n    return BitCrusherWorklet;\n}(ToneAudioWorklet));\n//# sourceMappingURL=BitCrusher.js.map"]},"metadata":{},"sourceType":"module"}